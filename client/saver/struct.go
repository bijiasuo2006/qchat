package saver

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"time"
)

type UserAppid struct {
	User  string
	Appid uint16
}

type ChatRoomMemberUpdate struct {
	RoomID string
	Appid  uint16
	Type   string
	Count  int
}

type UserChatRoom struct {
	User   string
	RoomId string
	Appid  uint16
}

type ChatRoomsAppid struct {
	Appid   uint16
	RoomIDs []string
}

const (
	GroupJoined  = "join"
	GroupCreated = "owner"
	GroupAll     = "all"
)

const (
	ReqRoleGroupExited = 1
	ReqRoleGroupUser   = 2
	ReqRoleGroupOwner  = 4

	ReqRoleGroupUserOrOwner = 6
	ReqRoleGroupAll         = 255
)

type GroupAppid struct {
	AppId    uint16
	GroupId  string
	UserId   string
	SinceId  int
	PageSize int
	Version  int64
	ReqType  string
	Extras   []string
}

type FetchChatRoomMessageReq struct {
	RoomID string
	Appid  uint16
	MsgIDs []uint
}

type GroupMsgReq struct {
	AppId   uint16
	GroupId string
	StartId uint64
	Offset  int32
}

type GetActiveReq struct {
	AppId  uint16
	ZoneId uint16
}

const (
	ChatChannelNotify   = "peer"
	ChatChannelPublic   = "public"
	ChatChannelIM       = "im"
	ChatChannelIMInbox  = "iminbox"
	ChatChannelIMOutbox = "imoutbox"
)

var (
	ErrNotFound    = errors.New("specified message not found")
	ErrRecalledYet = errors.New("message has been recalled yet")
)

/*
 * Message struct, is used to store/retrieve the messages from saver
 *
 * Caller filled fields:
 * Content: the message's content
 * Type: the message content's type
 * To: the key info, such as jid, of message recipient
 * From: the key info, such as jid, of message sender
 * TraceSN: the unique message sequence number
 * ExpireInterval: indicates that message will be deleted after expire time interval from saved time,
 *      the unit is second. The value range of this filed is min ~ max expire time interval seconds which
 *      defined in config; saver will treat all data less than min as min while treat all
 *      data more than max as max.
 *      If this field is not set, the default is used.
 *      By default, the default is 604,800s (7 days), min is 3600s (1 hours)
 *      while max is 8,640,000s (100 days).
 *      Also we allow to define independent expire time interval for special message types in config
 *
 * StoreOutbox: indicate the message retrieved from which message box, 0 is from inbox, 1 is from outbox.
 *      This field is used by 'im' channel messages only and will not be stored
 *
 * Below fields usually are generated by saver
 * MsgId: unique message id if message saved successfully
 * Creation: the time when the message is saved in storage
 * ExpireTime: the time when the message is expired, it means saver will remove this message from storage after that point
 * Box: indicates the message is retrieved from which message box, 0 is from inbox, 1 is from outbox.
 */
type ChatMessage struct {
	Content        string // content of the message
	Type           uint32 // message type, like text, voice, picture or others
	To             string // message recipient
	From           string // message initiator
	TraceSN        int64  // the unique message sequence number used to trace message
	ExpireInterval int    // expire time interval, the unit is second
	StoreOutbox    uint8  // indicate the message box to store, 0 for inbox only, 1 for both inbox and outbox.

	// below fields usually are generated by saver
	MsgId      uint64    // unique message id
	Creation   time.Time // the time when the message is saved
	ExpireTime time.Time // the time when the message is expired, it means saver will remove this message from DB after that point
	Box        uint8     // indicate the message is retrieved from which message box, 0 is from inbox, 1 is from outbox.
}

/*
 * default string will not include content information
 */
func (msg *ChatMessage) String() string {
	box := "inbox"
	if msg.Box != 0 {
		box = "outbox"
	}
	return "ChatMessage{ To[" + msg.To + "] From[" + msg.From + "] TraceSN[" + strconv.FormatInt(msg.TraceSN, 10) +
		"] Type[" + strconv.FormatUint(uint64(msg.Type), 10) +
		"] ExpireInterval[" + strconv.FormatUint(uint64(msg.ExpireInterval), 10) +
		"] StoreOutbox[" + strconv.FormatUint(uint64(msg.StoreOutbox), 10) +
		"] MsgID[" + strconv.FormatUint(uint64(msg.MsgId), 10) + "] CreationTime[" + msg.Creation.String() +
		"] ExpireTime[" + msg.ExpireTime.String() + "] Box[" + box + "]}"
}

func (msg *ChatMessage) ToString(args ...string) string {
	result := ""
	for _, arg := range args {
		switch arg {
		case "To":
			result = fmt.Sprint(result, "To["+msg.To+"] ")
		case "From":
			result = fmt.Sprint(result, "From["+msg.From+"] ")
		case "TraceSN":
			result = fmt.Sprint(result, "TraceSN["+strconv.FormatInt(msg.TraceSN, 10)+"] ")
		case "Content":
			result = fmt.Sprint(result, "Content["+msg.Content+"] ")
		case "Type":
			result = fmt.Sprint(result,
				"Type["+strconv.FormatUint(uint64(msg.Type), 10)+"] ")
		case "ExpireInterval":
			result = fmt.Sprint(result,
				"ExpireInterval["+strconv.FormatUint(uint64(msg.ExpireInterval), 10)+"] ")
		case "StoreOutbox":
			result = fmt.Sprint(result,
				"StoreOutbox["+strconv.FormatUint(uint64(msg.StoreOutbox), 10)+"] ")
		case "MsgID":
			result = fmt.Sprint(result, "MsgID["+strconv.FormatUint(uint64(msg.MsgId), 10)+"] ")
		case "CreationTime":
			result = fmt.Sprint(result, "CreationTime["+msg.Creation.String()+"] ")
		case "ExpireTime":
			result = fmt.Sprint(result, "ExpireTime["+msg.ExpireTime.String()+"] ")
		case "Box":
			if msg.Box != 0 {
				result = fmt.Sprint(result, "Box[outbox] ")
			} else {
				result = fmt.Sprint(result, "Box[inbox] ")
			}
		}
	}

	if result != "" {
		return fmt.Sprint("ChatMessage{", result, "}")
	}

	// default format
	return msg.String()
}

func (msg *ChatMessage) JsonString() string {
	if data, err := json.Marshal(*msg); err != nil {
		return fmt.Sprintf("{}")
	} else {
		return string(data)
	}
}

/*
 * [Request] other modules -> saver; this is used by store notification/im/public messages functions
 * Appid: application id
 * Messages: messages need to store; key is receiver of stored messages
 * ChatChannel: tells the channel type of the message to store, so far only 'notify', 'im' and 'public'
 *      are supported. If this field isn't filled, saver treats it as 'notify' type.
 *      If this field is filled and value isn't 'notify', 'im' and 'public',
 *      a error code will be returned.
 *  'notify' type: requires all caller filled fields in Message. And 'To' and 'From' fields cannot be
 *      empty string, otherwise the message will be discarded directly with no correspond message in response.
 *      This type message supports to set its own expire time during in range 1~604800 seconds
 *      The default expire time is 604800 seconds if ExpireInterval field isn't filled
 *  'public' type: requires that ExpireInterval field of messages is filled, otherwise the message
 *      will be discarded directly. This type message does not require 'to' and 'from' fields
 *  'im' type: IM message, likes 'notify' message but it allows messages are store to outbox too if need
 */
type StoreMessagesRequest struct {
	Appid       uint16
	Messages    map[string]*ChatMessage
	ChatChannel string
	TraceSN     string
}

func (req StoreMessagesRequest) String() string {
	result := fmt.Sprint("StoreMessagesRequest{Appid:", req.Appid, " Channel:", req.ChatChannel,
		" TraceSN:", req.TraceSN, " Messages:[")

	for _, message := range req.Messages {
		result = fmt.Sprint(result, message, " ")
	}

	result = fmt.Sprint(result, "]}")
	return result
}

/*
 * [Response] saver -> other modules; this is used by store notification/im/public messages response
 *  Note that store functions will not return error if any message is discarded for invalid value;
 *      if a message cannot be found in response by its TraceSN, it is discarded for invalid value
 *
 * Inbox: messages have been stored to inbox of receiver; key is receiver of stored messages
 * Outbox: messages have been stored to outbox of sender; key is receiver of stored messages
 *  Note: the count of Messages might not be equal to request.Messages for they might be discarded for invalid value
 */
type StoreMessagesResponse struct {
	Inbox  map[string]*ChatMessage
	Outbox map[string]*ChatMessage
}

func (resp StoreMessagesResponse) String() string {
	result := fmt.Sprint("StoreMessagesResponse{Inbox messages:[")
	for _, message := range resp.Inbox {
		result = fmt.Sprint(result, message, " ")
	}
	if len(resp.Outbox) > 0 {
		result = fmt.Sprint(result, "] Outbox messages:[")
		for _, message := range resp.Outbox {
			result = fmt.Sprint(result, message, " ")
		}
	}
	result = fmt.Sprint(result, "]}")

	return result
}

/*
 * RetrieveChannel indicates message of what channel will be retrieved
 * Channel: tells the channel type of the message to be retrieved, so far only 'notify', 'public', 'im', 'imInbox' and
 *      'imOutbox' are supported.
 *      If this field is filled and value isn't 'notify', 'public', 'im', 'imInbox' and 'imOutbox' or not filled,
 *      this entry will be ignored when saver is handling retrieve message request.
 *  'notify' type: request to retrieve notification channel messages
 *  'public' type: request to retrieve public channel messages
 *  'im' type: request to retrieve im channel messages, both inbox and outbox
 *  'imInbox' type: request to retrieve im channel messages, inbox only
 *  'imOutBox' type: request to retrieve im channel messages, outbox only
 * StartMsgId: inclusive message id base;
 *      set as 0 will return messages from last read include last read,
 *      set as negative will return latest messages
 *      otherwise will return from request start id if there are
 * MaxCount: max return count in this request; this field is set as 0 will use default value 5
 *      this field is set as negative will return messages before start id
 */
type RetrieveChannel struct {
	Channel    string
	StartMsgId int64
	MaxCount   int
}

func (info RetrieveChannel) String() string {
	return fmt.Sprintf("RetrieveChannel{Channel:%s StartMsgId:%v MaxCount:%v}",
		info.Channel, info.StartMsgId, info.MaxCount)
}

/*
 * [Request] other modules -> saver; this is used by retrieve notification/im/public messages functions
 * Appid: application id
 * Owner: owner who requests to retrieve messages
 * ChatChannels: indicates information of channels will be retrieved
 */
type RetrieveMessagesRequest struct {
	Appid        uint16
	Owner        string
	ChatChannels map[string]*RetrieveChannel
	TraceSN      string
}

func (req RetrieveMessagesRequest) String() string {
	result := fmt.Sprint("RetrieveMessagesRequest{Appid:", req.Appid, " Owner:", req.Owner,
		" TraceSN:", req.TraceSN, " Channels:[")

	for _, chatChannel := range req.ChatChannels {
		result = fmt.Sprint(result, chatChannel, " ")
	}

	result = fmt.Sprint(result, "]}")
	return result
}

/*
 * [Response] saver -> other modules; this is used by retrieve notification/im/public messages response
 *
 * Inbox: messages have been retrieved from inbox storage; key is channels in request and value are message slice of
 *      channel. If a channel in request is not found in Inbox means there isn't any messages from specified start id
 *      have response in this field
 * Outbox: messages have been retrieved from inbox storage; key is channels in request and value are message slice of
 *      channel. So far only IM channel may have outbox
 * LatestID: each latest ID of channels in request
 * LastReadID: each last read ID of channels in request
 */
type RetrieveMessagesResponse struct {
	Inbox      map[string][]*ChatMessage
	Outbox     map[string][]*ChatMessage
	LatestID   map[string]uint64
	LastReadID map[string]uint64
	Appid      uint16
	Owner      string
}

func (resp RetrieveMessagesResponse) String() string {
	result := fmt.Sprint("RetrieveMessagesResponse{")
	for chatChannel, latestId := range resp.LatestID {
		result = fmt.Sprint(result, chatChannel, " channel", "{")
		result = fmt.Sprint(result, " LatestID:", latestId)
		result = fmt.Sprint(result, " LastReadID:", resp.LastReadID[chatChannel])
		result = fmt.Sprint(result, " Inbox messages:[")

		if messages, ok := resp.Inbox[chatChannel]; ok {
			for _, message := range messages {
				result = fmt.Sprint(result, message, " ")
			}
		}

		if messages, ok := resp.Outbox[chatChannel]; ok && len(messages) > 0 {
			result = fmt.Sprint(result, "]")
			result = fmt.Sprint(result, " Outbox messages:[")
			for _, message := range messages {
				result = fmt.Sprint(result, message, " ")
			}
		}

		result = fmt.Sprint(result, "]")
		result = fmt.Sprint(result, "}")
	}

	result = fmt.Sprint(result, "}")

	return result
}

/*
 * [Request] other modules -> saver; this is used by recall notification/im messages functions
 * Appid: application id
 * ChatChannel: indicates information of channels will be recalled
 * Sender: the sender of message which need to be recalled
 * Receiver: the receiver of message which need to be recalled
 * InboxId: the msg id from inbox to indicate which one should be delete
 */
type RecallMessagesRequest struct {
	Appid       uint16
	ChatChannel string
	Sender      string
	Receiver    string
	InboxId     uint64
	TraceSN     string
}

func (req RecallMessagesRequest) String() string {
	return fmt.Sprintf("RecallMessagesRequest{Appid:%v Channel:%v Sender:%v Receiver:%v InboxId:%v TraceSN:%v}",
		req.Appid, req.ChatChannel, req.Sender, req.Receiver, req.InboxId, req.TraceSN)
}

type ChatroomCountKeysRequest struct {
	Appid   uint16
	Roomids []string
}

type ChatroomCountKeysResponse struct {
	Roomids []string
}

type GetChatroomCountKeysRequest struct {
	Appid     uint16
	ClientIP  string
	RpcIndex  int
	RpcLength int
}

type QpsCount struct {
	Module string
	API    string
	Limit  int
}
