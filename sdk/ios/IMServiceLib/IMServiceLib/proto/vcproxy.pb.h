// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vcproxy.proto

#ifndef PROTOBUF_vcproxy_2eproto__INCLUDED
#define PROTOBUF_vcproxy_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace qihoo {
namespace protocol {
namespace vcproxy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_vcproxy_2eproto();
void protobuf_AssignDesc_vcproxy_2eproto();
void protobuf_ShutdownFile_vcproxy_2eproto();

class CRPair;
class ErrorInfo;
class user_info;
class CreateChannelRequest;
class CreateChannelResponse;
class CheckChannelRequest;
class CheckChannelResponse;
class RestoreChannelRequest;
class RestoreChannelResponse;
class NewChannelNotify;
class VCProxyUserToServer;
class VCProxyServerToUser;
class VCProxyNotify;
class VCProxyPacket;

// ===================================================================

class CRPair : public ::google::protobuf::Message {
 public:
  CRPair();
  virtual ~CRPair();

  CRPair(const CRPair& from);

  inline CRPair& operator=(const CRPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CRPair& default_instance();

  void Swap(CRPair* other);

  // implements Message ----------------------------------------------

  CRPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CRPair& from);
  void MergeFrom(const CRPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.CRPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static CRPair* default_instance_;
};
// -------------------------------------------------------------------

class ErrorInfo : public ::google::protobuf::Message {
 public:
  ErrorInfo();
  virtual ~ErrorInfo();

  ErrorInfo(const ErrorInfo& from);

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorInfo& default_instance();

  void Swap(ErrorInfo* other);

  // implements Message ----------------------------------------------

  ErrorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorInfo& from);
  void MergeFrom(const ErrorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 error_no = 1;
  inline bool has_error_no() const;
  inline void clear_error_no();
  static const int kErrorNoFieldNumber = 1;
  inline ::google::protobuf::int32 error_no() const;
  inline void set_error_no(::google::protobuf::int32 value);

  // optional string error_desc = 2;
  inline bool has_error_desc() const;
  inline void clear_error_desc();
  static const int kErrorDescFieldNumber = 2;
  inline const ::std::string& error_desc() const;
  inline void set_error_desc(const ::std::string& value);
  inline void set_error_desc(const char* value);
  inline void set_error_desc(const char* value, size_t size);
  inline ::std::string* mutable_error_desc();
  inline ::std::string* release_error_desc();
  inline void set_allocated_error_desc(::std::string* error_desc);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.ErrorInfo)
 private:
  inline void set_has_error_no();
  inline void clear_has_error_no();
  inline void set_has_error_desc();
  inline void clear_has_error_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_desc_;
  ::google::protobuf::int32 error_no_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static ErrorInfo* default_instance_;
};
// -------------------------------------------------------------------

class user_info : public ::google::protobuf::Message {
 public:
  user_info();
  virtual ~user_info();

  user_info(const user_info& from);

  inline user_info& operator=(const user_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_info& default_instance();

  void Swap(user_info* other);

  // implements Message ----------------------------------------------

  user_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_info& from);
  void MergeFrom(const user_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // optional uint32 operator_id = 2 [default = 0];
  inline bool has_operator_id() const;
  inline void clear_operator_id();
  static const int kOperatorIdFieldNumber = 2;
  inline ::google::protobuf::uint32 operator_id() const;
  inline void set_operator_id(::google::protobuf::uint32 value);

  // optional uint32 area_id = 3 [default = 0];
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 area_id() const;
  inline void set_area_id(::google::protobuf::uint32 value);

  // optional uint32 net_type = 4;
  inline bool has_net_type() const;
  inline void clear_net_type();
  static const int kNetTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 net_type() const;
  inline void set_net_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.user_info)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_operator_id();
  inline void clear_has_operator_id();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_net_type();
  inline void clear_has_net_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_id_;
  ::google::protobuf::uint32 operator_id_;
  ::google::protobuf::uint32 area_id_;
  ::google::protobuf::uint32 net_type_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static user_info* default_instance_;
};
// -------------------------------------------------------------------

class CreateChannelRequest : public ::google::protobuf::Message {
 public:
  CreateChannelRequest();
  virtual ~CreateChannelRequest();

  CreateChannelRequest(const CreateChannelRequest& from);

  inline CreateChannelRequest& operator=(const CreateChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateChannelRequest& default_instance();

  void Swap(CreateChannelRequest* other);

  // implements Message ----------------------------------------------

  CreateChannelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateChannelRequest& from);
  void MergeFrom(const CreateChannelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string requester = 1;
  inline bool has_requester() const;
  inline void clear_requester();
  static const int kRequesterFieldNumber = 1;
  inline const ::std::string& requester() const;
  inline void set_requester(const ::std::string& value);
  inline void set_requester(const char* value);
  inline void set_requester(const char* value, size_t size);
  inline ::std::string* mutable_requester();
  inline ::std::string* release_requester();
  inline void set_allocated_requester(::std::string* requester);

  // optional uint32 operator_id = 2 [default = 0];
  inline bool has_operator_id() const;
  inline void clear_operator_id();
  static const int kOperatorIdFieldNumber = 2;
  inline ::google::protobuf::uint32 operator_id() const;
  inline void set_operator_id(::google::protobuf::uint32 value);

  // optional uint32 area_id = 3 [default = 0];
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  inline ::google::protobuf::uint32 area_id() const;
  inline void set_area_id(::google::protobuf::uint32 value);

  // optional uint32 net_type = 4;
  inline bool has_net_type() const;
  inline void clear_net_type();
  static const int kNetTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 net_type() const;
  inline void set_net_type(::google::protobuf::uint32 value);

  // repeated .qihoo.protocol.vcproxy.user_info member_list = 5;
  inline int member_list_size() const;
  inline void clear_member_list();
  static const int kMemberListFieldNumber = 5;
  inline const ::qihoo::protocol::vcproxy::user_info& member_list(int index) const;
  inline ::qihoo::protocol::vcproxy::user_info* mutable_member_list(int index);
  inline ::qihoo::protocol::vcproxy::user_info* add_member_list();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::vcproxy::user_info >&
      member_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::vcproxy::user_info >*
      mutable_member_list();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.CreateChannelRequest)
 private:
  inline void set_has_requester();
  inline void clear_has_requester();
  inline void set_has_operator_id();
  inline void clear_has_operator_id();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_net_type();
  inline void clear_has_net_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* requester_;
  ::google::protobuf::uint32 operator_id_;
  ::google::protobuf::uint32 area_id_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::vcproxy::user_info > member_list_;
  ::google::protobuf::uint32 net_type_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static CreateChannelRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateChannelResponse : public ::google::protobuf::Message {
 public:
  CreateChannelResponse();
  virtual ~CreateChannelResponse();

  CreateChannelResponse(const CreateChannelResponse& from);

  inline CreateChannelResponse& operator=(const CreateChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateChannelResponse& default_instance();

  void Swap(CreateChannelResponse* other);

  // implements Message ----------------------------------------------

  CreateChannelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateChannelResponse& from);
  void MergeFrom(const CreateChannelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // required bytes channel_info = 2;
  inline bool has_channel_info() const;
  inline void clear_channel_info();
  static const int kChannelInfoFieldNumber = 2;
  inline const ::std::string& channel_info() const;
  inline void set_channel_info(const ::std::string& value);
  inline void set_channel_info(const char* value);
  inline void set_channel_info(const void* value, size_t size);
  inline ::std::string* mutable_channel_info();
  inline ::std::string* release_channel_info();
  inline void set_allocated_channel_info(::std::string* channel_info);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.CreateChannelResponse)
 private:
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_channel_info();
  inline void clear_has_channel_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* channel_id_;
  ::std::string* channel_info_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static CreateChannelResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckChannelRequest : public ::google::protobuf::Message {
 public:
  CheckChannelRequest();
  virtual ~CheckChannelRequest();

  CheckChannelRequest(const CheckChannelRequest& from);

  inline CheckChannelRequest& operator=(const CheckChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChannelRequest& default_instance();

  void Swap(CheckChannelRequest* other);

  // implements Message ----------------------------------------------

  CheckChannelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChannelRequest& from);
  void MergeFrom(const CheckChannelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string requester = 1;
  inline bool has_requester() const;
  inline void clear_requester();
  static const int kRequesterFieldNumber = 1;
  inline const ::std::string& requester() const;
  inline void set_requester(const ::std::string& value);
  inline void set_requester(const char* value);
  inline void set_requester(const char* value, size_t size);
  inline ::std::string* mutable_requester();
  inline ::std::string* release_requester();
  inline void set_allocated_requester(::std::string* requester);

  // required bytes channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.CheckChannelRequest)
 private:
  inline void set_has_requester();
  inline void clear_has_requester();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* requester_;
  ::std::string* channel_id_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static CheckChannelRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckChannelResponse : public ::google::protobuf::Message {
 public:
  CheckChannelResponse();
  virtual ~CheckChannelResponse();

  CheckChannelResponse(const CheckChannelResponse& from);

  inline CheckChannelResponse& operator=(const CheckChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChannelResponse& default_instance();

  void Swap(CheckChannelResponse* other);

  // implements Message ----------------------------------------------

  CheckChannelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChannelResponse& from);
  void MergeFrom(const CheckChannelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 curr_member_num = 1;
  inline bool has_curr_member_num() const;
  inline void clear_curr_member_num();
  static const int kCurrMemberNumFieldNumber = 1;
  inline ::google::protobuf::int32 curr_member_num() const;
  inline void set_curr_member_num(::google::protobuf::int32 value);

  // repeated string curr_member_list = 2;
  inline int curr_member_list_size() const;
  inline void clear_curr_member_list();
  static const int kCurrMemberListFieldNumber = 2;
  inline const ::std::string& curr_member_list(int index) const;
  inline ::std::string* mutable_curr_member_list(int index);
  inline void set_curr_member_list(int index, const ::std::string& value);
  inline void set_curr_member_list(int index, const char* value);
  inline void set_curr_member_list(int index, const char* value, size_t size);
  inline ::std::string* add_curr_member_list();
  inline void add_curr_member_list(const ::std::string& value);
  inline void add_curr_member_list(const char* value);
  inline void add_curr_member_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& curr_member_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_curr_member_list();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.CheckChannelResponse)
 private:
  inline void set_has_curr_member_num();
  inline void clear_has_curr_member_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> curr_member_list_;
  ::google::protobuf::int32 curr_member_num_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static CheckChannelResponse* default_instance_;
};
// -------------------------------------------------------------------

class RestoreChannelRequest : public ::google::protobuf::Message {
 public:
  RestoreChannelRequest();
  virtual ~RestoreChannelRequest();

  RestoreChannelRequest(const RestoreChannelRequest& from);

  inline RestoreChannelRequest& operator=(const RestoreChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreChannelRequest& default_instance();

  void Swap(RestoreChannelRequest* other);

  // implements Message ----------------------------------------------

  RestoreChannelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RestoreChannelRequest& from);
  void MergeFrom(const RestoreChannelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string requester = 1;
  inline bool has_requester() const;
  inline void clear_requester();
  static const int kRequesterFieldNumber = 1;
  inline const ::std::string& requester() const;
  inline void set_requester(const ::std::string& value);
  inline void set_requester(const char* value);
  inline void set_requester(const char* value, size_t size);
  inline ::std::string* mutable_requester();
  inline ::std::string* release_requester();
  inline void set_allocated_requester(::std::string* requester);

  // required bytes channel_id = 2;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_channel_id();
  inline ::std::string* release_channel_id();
  inline void set_allocated_channel_id(::std::string* channel_id);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.RestoreChannelRequest)
 private:
  inline void set_has_requester();
  inline void clear_has_requester();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* requester_;
  ::std::string* channel_id_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static RestoreChannelRequest* default_instance_;
};
// -------------------------------------------------------------------

class RestoreChannelResponse : public ::google::protobuf::Message {
 public:
  RestoreChannelResponse();
  virtual ~RestoreChannelResponse();

  RestoreChannelResponse(const RestoreChannelResponse& from);

  inline RestoreChannelResponse& operator=(const RestoreChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreChannelResponse& default_instance();

  void Swap(RestoreChannelResponse* other);

  // implements Message ----------------------------------------------

  RestoreChannelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RestoreChannelResponse& from);
  void MergeFrom(const RestoreChannelResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes new_channel_id = 1;
  inline bool has_new_channel_id() const;
  inline void clear_new_channel_id();
  static const int kNewChannelIdFieldNumber = 1;
  inline const ::std::string& new_channel_id() const;
  inline void set_new_channel_id(const ::std::string& value);
  inline void set_new_channel_id(const char* value);
  inline void set_new_channel_id(const void* value, size_t size);
  inline ::std::string* mutable_new_channel_id();
  inline ::std::string* release_new_channel_id();
  inline void set_allocated_new_channel_id(::std::string* new_channel_id);

  // required bytes new_channel_info = 2;
  inline bool has_new_channel_info() const;
  inline void clear_new_channel_info();
  static const int kNewChannelInfoFieldNumber = 2;
  inline const ::std::string& new_channel_info() const;
  inline void set_new_channel_info(const ::std::string& value);
  inline void set_new_channel_info(const char* value);
  inline void set_new_channel_info(const void* value, size_t size);
  inline ::std::string* mutable_new_channel_info();
  inline ::std::string* release_new_channel_info();
  inline void set_allocated_new_channel_info(::std::string* new_channel_info);

  // optional uint32 curr_member_num = 3;
  inline bool has_curr_member_num() const;
  inline void clear_curr_member_num();
  static const int kCurrMemberNumFieldNumber = 3;
  inline ::google::protobuf::uint32 curr_member_num() const;
  inline void set_curr_member_num(::google::protobuf::uint32 value);

  // repeated string curr_member_list = 4;
  inline int curr_member_list_size() const;
  inline void clear_curr_member_list();
  static const int kCurrMemberListFieldNumber = 4;
  inline const ::std::string& curr_member_list(int index) const;
  inline ::std::string* mutable_curr_member_list(int index);
  inline void set_curr_member_list(int index, const ::std::string& value);
  inline void set_curr_member_list(int index, const char* value);
  inline void set_curr_member_list(int index, const char* value, size_t size);
  inline ::std::string* add_curr_member_list();
  inline void add_curr_member_list(const ::std::string& value);
  inline void add_curr_member_list(const char* value);
  inline void add_curr_member_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& curr_member_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_curr_member_list();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.RestoreChannelResponse)
 private:
  inline void set_has_new_channel_id();
  inline void clear_has_new_channel_id();
  inline void set_has_new_channel_info();
  inline void clear_has_new_channel_info();
  inline void set_has_curr_member_num();
  inline void clear_has_curr_member_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* new_channel_id_;
  ::std::string* new_channel_info_;
  ::google::protobuf::RepeatedPtrField< ::std::string> curr_member_list_;
  ::google::protobuf::uint32 curr_member_num_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static RestoreChannelResponse* default_instance_;
};
// -------------------------------------------------------------------

class NewChannelNotify : public ::google::protobuf::Message {
 public:
  NewChannelNotify();
  virtual ~NewChannelNotify();

  NewChannelNotify(const NewChannelNotify& from);

  inline NewChannelNotify& operator=(const NewChannelNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewChannelNotify& default_instance();

  void Swap(NewChannelNotify* other);

  // implements Message ----------------------------------------------

  NewChannelNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewChannelNotify& from);
  void MergeFrom(const NewChannelNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.NewChannelNotify)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static NewChannelNotify* default_instance_;
};
// -------------------------------------------------------------------

class VCProxyUserToServer : public ::google::protobuf::Message {
 public:
  VCProxyUserToServer();
  virtual ~VCProxyUserToServer();

  VCProxyUserToServer(const VCProxyUserToServer& from);

  inline VCProxyUserToServer& operator=(const VCProxyUserToServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VCProxyUserToServer& default_instance();

  void Swap(VCProxyUserToServer* other);

  // implements Message ----------------------------------------------

  VCProxyUserToServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VCProxyUserToServer& from);
  void MergeFrom(const VCProxyUserToServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.vcproxy.CreateChannelRequest create_channel_req = 1;
  inline bool has_create_channel_req() const;
  inline void clear_create_channel_req();
  static const int kCreateChannelReqFieldNumber = 1;
  inline const ::qihoo::protocol::vcproxy::CreateChannelRequest& create_channel_req() const;
  inline ::qihoo::protocol::vcproxy::CreateChannelRequest* mutable_create_channel_req();
  inline ::qihoo::protocol::vcproxy::CreateChannelRequest* release_create_channel_req();
  inline void set_allocated_create_channel_req(::qihoo::protocol::vcproxy::CreateChannelRequest* create_channel_req);

  // optional .qihoo.protocol.vcproxy.CheckChannelRequest check_channel_req = 2;
  inline bool has_check_channel_req() const;
  inline void clear_check_channel_req();
  static const int kCheckChannelReqFieldNumber = 2;
  inline const ::qihoo::protocol::vcproxy::CheckChannelRequest& check_channel_req() const;
  inline ::qihoo::protocol::vcproxy::CheckChannelRequest* mutable_check_channel_req();
  inline ::qihoo::protocol::vcproxy::CheckChannelRequest* release_check_channel_req();
  inline void set_allocated_check_channel_req(::qihoo::protocol::vcproxy::CheckChannelRequest* check_channel_req);

  // optional .qihoo.protocol.vcproxy.RestoreChannelRequest restore_channel_req = 3;
  inline bool has_restore_channel_req() const;
  inline void clear_restore_channel_req();
  static const int kRestoreChannelReqFieldNumber = 3;
  inline const ::qihoo::protocol::vcproxy::RestoreChannelRequest& restore_channel_req() const;
  inline ::qihoo::protocol::vcproxy::RestoreChannelRequest* mutable_restore_channel_req();
  inline ::qihoo::protocol::vcproxy::RestoreChannelRequest* release_restore_channel_req();
  inline void set_allocated_restore_channel_req(::qihoo::protocol::vcproxy::RestoreChannelRequest* restore_channel_req);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.VCProxyUserToServer)
 private:
  inline void set_has_create_channel_req();
  inline void clear_has_create_channel_req();
  inline void set_has_check_channel_req();
  inline void clear_has_check_channel_req();
  inline void set_has_restore_channel_req();
  inline void clear_has_restore_channel_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::vcproxy::CreateChannelRequest* create_channel_req_;
  ::qihoo::protocol::vcproxy::CheckChannelRequest* check_channel_req_;
  ::qihoo::protocol::vcproxy::RestoreChannelRequest* restore_channel_req_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static VCProxyUserToServer* default_instance_;
};
// -------------------------------------------------------------------

class VCProxyServerToUser : public ::google::protobuf::Message {
 public:
  VCProxyServerToUser();
  virtual ~VCProxyServerToUser();

  VCProxyServerToUser(const VCProxyServerToUser& from);

  inline VCProxyServerToUser& operator=(const VCProxyServerToUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VCProxyServerToUser& default_instance();

  void Swap(VCProxyServerToUser* other);

  // implements Message ----------------------------------------------

  VCProxyServerToUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VCProxyServerToUser& from);
  void MergeFrom(const VCProxyServerToUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .qihoo.protocol.vcproxy.ErrorInfo error_info = 2;
  inline bool has_error_info() const;
  inline void clear_error_info();
  static const int kErrorInfoFieldNumber = 2;
  inline const ::qihoo::protocol::vcproxy::ErrorInfo& error_info() const;
  inline ::qihoo::protocol::vcproxy::ErrorInfo* mutable_error_info();
  inline ::qihoo::protocol::vcproxy::ErrorInfo* release_error_info();
  inline void set_allocated_error_info(::qihoo::protocol::vcproxy::ErrorInfo* error_info);

  // optional .qihoo.protocol.vcproxy.CreateChannelResponse create_channel_resp = 3;
  inline bool has_create_channel_resp() const;
  inline void clear_create_channel_resp();
  static const int kCreateChannelRespFieldNumber = 3;
  inline const ::qihoo::protocol::vcproxy::CreateChannelResponse& create_channel_resp() const;
  inline ::qihoo::protocol::vcproxy::CreateChannelResponse* mutable_create_channel_resp();
  inline ::qihoo::protocol::vcproxy::CreateChannelResponse* release_create_channel_resp();
  inline void set_allocated_create_channel_resp(::qihoo::protocol::vcproxy::CreateChannelResponse* create_channel_resp);

  // optional .qihoo.protocol.vcproxy.CheckChannelResponse check_channel_resp = 4;
  inline bool has_check_channel_resp() const;
  inline void clear_check_channel_resp();
  static const int kCheckChannelRespFieldNumber = 4;
  inline const ::qihoo::protocol::vcproxy::CheckChannelResponse& check_channel_resp() const;
  inline ::qihoo::protocol::vcproxy::CheckChannelResponse* mutable_check_channel_resp();
  inline ::qihoo::protocol::vcproxy::CheckChannelResponse* release_check_channel_resp();
  inline void set_allocated_check_channel_resp(::qihoo::protocol::vcproxy::CheckChannelResponse* check_channel_resp);

  // optional .qihoo.protocol.vcproxy.RestoreChannelResponse restore_channel_resp = 5;
  inline bool has_restore_channel_resp() const;
  inline void clear_restore_channel_resp();
  static const int kRestoreChannelRespFieldNumber = 5;
  inline const ::qihoo::protocol::vcproxy::RestoreChannelResponse& restore_channel_resp() const;
  inline ::qihoo::protocol::vcproxy::RestoreChannelResponse* mutable_restore_channel_resp();
  inline ::qihoo::protocol::vcproxy::RestoreChannelResponse* release_restore_channel_resp();
  inline void set_allocated_restore_channel_resp(::qihoo::protocol::vcproxy::RestoreChannelResponse* restore_channel_resp);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.VCProxyServerToUser)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_info();
  inline void clear_has_error_info();
  inline void set_has_create_channel_resp();
  inline void clear_has_create_channel_resp();
  inline void set_has_check_channel_resp();
  inline void clear_has_check_channel_resp();
  inline void set_has_restore_channel_resp();
  inline void clear_has_restore_channel_resp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::vcproxy::ErrorInfo* error_info_;
  ::qihoo::protocol::vcproxy::CreateChannelResponse* create_channel_resp_;
  ::qihoo::protocol::vcproxy::CheckChannelResponse* check_channel_resp_;
  ::qihoo::protocol::vcproxy::RestoreChannelResponse* restore_channel_resp_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static VCProxyServerToUser* default_instance_;
};
// -------------------------------------------------------------------

class VCProxyNotify : public ::google::protobuf::Message {
 public:
  VCProxyNotify();
  virtual ~VCProxyNotify();

  VCProxyNotify(const VCProxyNotify& from);

  inline VCProxyNotify& operator=(const VCProxyNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VCProxyNotify& default_instance();

  void Swap(VCProxyNotify* other);

  // implements Message ----------------------------------------------

  VCProxyNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VCProxyNotify& from);
  void MergeFrom(const VCProxyNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.vcproxy.NewChannelNotify new_channel_notify = 1;
  inline bool has_new_channel_notify() const;
  inline void clear_new_channel_notify();
  static const int kNewChannelNotifyFieldNumber = 1;
  inline const ::qihoo::protocol::vcproxy::NewChannelNotify& new_channel_notify() const;
  inline ::qihoo::protocol::vcproxy::NewChannelNotify* mutable_new_channel_notify();
  inline ::qihoo::protocol::vcproxy::NewChannelNotify* release_new_channel_notify();
  inline void set_allocated_new_channel_notify(::qihoo::protocol::vcproxy::NewChannelNotify* new_channel_notify);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.VCProxyNotify)
 private:
  inline void set_has_new_channel_notify();
  inline void clear_has_new_channel_notify();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::vcproxy::NewChannelNotify* new_channel_notify_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static VCProxyNotify* default_instance_;
};
// -------------------------------------------------------------------

class VCProxyPacket : public ::google::protobuf::Message {
 public:
  VCProxyPacket();
  virtual ~VCProxyPacket();

  VCProxyPacket(const VCProxyPacket& from);

  inline VCProxyPacket& operator=(const VCProxyPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VCProxyPacket& default_instance();

  void Swap(VCProxyPacket* other);

  // implements Message ----------------------------------------------

  VCProxyPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VCProxyPacket& from);
  void MergeFrom(const VCProxyPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 payload_type = 1;
  inline bool has_payload_type() const;
  inline void clear_payload_type();
  static const int kPayloadTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 payload_type() const;
  inline void set_payload_type(::google::protobuf::uint32 value);

  // optional .qihoo.protocol.vcproxy.VCProxyUserToServer user_data = 2;
  inline bool has_user_data() const;
  inline void clear_user_data();
  static const int kUserDataFieldNumber = 2;
  inline const ::qihoo::protocol::vcproxy::VCProxyUserToServer& user_data() const;
  inline ::qihoo::protocol::vcproxy::VCProxyUserToServer* mutable_user_data();
  inline ::qihoo::protocol::vcproxy::VCProxyUserToServer* release_user_data();
  inline void set_allocated_user_data(::qihoo::protocol::vcproxy::VCProxyUserToServer* user_data);

  // optional .qihoo.protocol.vcproxy.VCProxyServerToUser server_data = 3;
  inline bool has_server_data() const;
  inline void clear_server_data();
  static const int kServerDataFieldNumber = 3;
  inline const ::qihoo::protocol::vcproxy::VCProxyServerToUser& server_data() const;
  inline ::qihoo::protocol::vcproxy::VCProxyServerToUser* mutable_server_data();
  inline ::qihoo::protocol::vcproxy::VCProxyServerToUser* release_server_data();
  inline void set_allocated_server_data(::qihoo::protocol::vcproxy::VCProxyServerToUser* server_data);

  // optional .qihoo.protocol.vcproxy.VCProxyNotify notify_data = 4;
  inline bool has_notify_data() const;
  inline void clear_notify_data();
  static const int kNotifyDataFieldNumber = 4;
  inline const ::qihoo::protocol::vcproxy::VCProxyNotify& notify_data() const;
  inline ::qihoo::protocol::vcproxy::VCProxyNotify* mutable_notify_data();
  inline ::qihoo::protocol::vcproxy::VCProxyNotify* release_notify_data();
  inline void set_allocated_notify_data(::qihoo::protocol::vcproxy::VCProxyNotify* notify_data);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.vcproxy.VCProxyPacket)
 private:
  inline void set_has_payload_type();
  inline void clear_has_payload_type();
  inline void set_has_user_data();
  inline void clear_has_user_data();
  inline void set_has_server_data();
  inline void clear_has_server_data();
  inline void set_has_notify_data();
  inline void clear_has_notify_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::vcproxy::VCProxyUserToServer* user_data_;
  ::qihoo::protocol::vcproxy::VCProxyServerToUser* server_data_;
  ::qihoo::protocol::vcproxy::VCProxyNotify* notify_data_;
  ::google::protobuf::uint32 payload_type_;
  friend void  protobuf_AddDesc_vcproxy_2eproto();
  friend void protobuf_AssignDesc_vcproxy_2eproto();
  friend void protobuf_ShutdownFile_vcproxy_2eproto();

  void InitAsDefaultInstance();
  static VCProxyPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// CRPair

// required string key = 1;
inline bool CRPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CRPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CRPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CRPair::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CRPair::key() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CRPair.key)
  return *key_;
}
inline void CRPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CRPair.key)
}
inline void CRPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CRPair.key)
}
inline void CRPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CRPair.key)
}
inline ::std::string* CRPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CRPair.key)
  return key_;
}
inline ::std::string* CRPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CRPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CRPair.key)
}

// optional bytes value = 2;
inline bool CRPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CRPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CRPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CRPair::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CRPair::value() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CRPair.value)
  return *value_;
}
inline void CRPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CRPair.value)
}
inline void CRPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CRPair.value)
}
inline void CRPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CRPair.value)
}
inline ::std::string* CRPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CRPair.value)
  return value_;
}
inline ::std::string* CRPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CRPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CRPair.value)
}

// -------------------------------------------------------------------

// ErrorInfo

// required int32 error_no = 1;
inline bool ErrorInfo::has_error_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorInfo::set_has_error_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorInfo::clear_has_error_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorInfo::clear_error_no() {
  error_no_ = 0;
  clear_has_error_no();
}
inline ::google::protobuf::int32 ErrorInfo::error_no() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.ErrorInfo.error_no)
  return error_no_;
}
inline void ErrorInfo::set_error_no(::google::protobuf::int32 value) {
  set_has_error_no();
  error_no_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.ErrorInfo.error_no)
}

// optional string error_desc = 2;
inline bool ErrorInfo::has_error_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorInfo::set_has_error_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorInfo::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorInfo::clear_error_desc() {
  if (error_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_desc_->clear();
  }
  clear_has_error_desc();
}
inline const ::std::string& ErrorInfo::error_desc() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
  return *error_desc_;
}
inline void ErrorInfo::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
}
inline void ErrorInfo::set_error_desc(const char* value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
}
inline void ErrorInfo::set_error_desc(const char* value, size_t size) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
}
inline ::std::string* ErrorInfo::mutable_error_desc() {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
  return error_desc_;
}
inline ::std::string* ErrorInfo::release_error_desc() {
  clear_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_desc_;
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ErrorInfo::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_desc_;
  }
  if (error_desc) {
    set_has_error_desc();
    error_desc_ = error_desc;
  } else {
    clear_has_error_desc();
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.ErrorInfo.error_desc)
}

// -------------------------------------------------------------------

// user_info

// required string user_id = 1;
inline bool user_info::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_info::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_info::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_info::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& user_info::user_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.user_info.user_id)
  return *user_id_;
}
inline void user_info::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.user_info.user_id)
}
inline void user_info::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.user_info.user_id)
}
inline void user_info::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.user_info.user_id)
}
inline ::std::string* user_info::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.user_info.user_id)
  return user_id_;
}
inline ::std::string* user_info::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void user_info::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.user_info.user_id)
}

// optional uint32 operator_id = 2 [default = 0];
inline bool user_info::has_operator_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_info::set_has_operator_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_info::clear_has_operator_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_info::clear_operator_id() {
  operator_id_ = 0u;
  clear_has_operator_id();
}
inline ::google::protobuf::uint32 user_info::operator_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.user_info.operator_id)
  return operator_id_;
}
inline void user_info::set_operator_id(::google::protobuf::uint32 value) {
  set_has_operator_id();
  operator_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.user_info.operator_id)
}

// optional uint32 area_id = 3 [default = 0];
inline bool user_info::has_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_info::set_has_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_info::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_info::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 user_info::area_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.user_info.area_id)
  return area_id_;
}
inline void user_info::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.user_info.area_id)
}

// optional uint32 net_type = 4;
inline bool user_info::has_net_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_info::set_has_net_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_info::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_info::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 user_info::net_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.user_info.net_type)
  return net_type_;
}
inline void user_info::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.user_info.net_type)
}

// -------------------------------------------------------------------

// CreateChannelRequest

// required string requester = 1;
inline bool CreateChannelRequest::has_requester() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateChannelRequest::set_has_requester() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateChannelRequest::clear_has_requester() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateChannelRequest::clear_requester() {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_->clear();
  }
  clear_has_requester();
}
inline const ::std::string& CreateChannelRequest::requester() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
  return *requester_;
}
inline void CreateChannelRequest::set_requester(const ::std::string& value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
}
inline void CreateChannelRequest::set_requester(const char* value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
}
inline void CreateChannelRequest::set_requester(const char* value, size_t size) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
}
inline ::std::string* CreateChannelRequest::mutable_requester() {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
  return requester_;
}
inline ::std::string* CreateChannelRequest::release_requester() {
  clear_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requester_;
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateChannelRequest::set_allocated_requester(::std::string* requester) {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requester_;
  }
  if (requester) {
    set_has_requester();
    requester_ = requester;
  } else {
    clear_has_requester();
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CreateChannelRequest.requester)
}

// optional uint32 operator_id = 2 [default = 0];
inline bool CreateChannelRequest::has_operator_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateChannelRequest::set_has_operator_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateChannelRequest::clear_has_operator_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateChannelRequest::clear_operator_id() {
  operator_id_ = 0u;
  clear_has_operator_id();
}
inline ::google::protobuf::uint32 CreateChannelRequest::operator_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelRequest.operator_id)
  return operator_id_;
}
inline void CreateChannelRequest::set_operator_id(::google::protobuf::uint32 value) {
  set_has_operator_id();
  operator_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelRequest.operator_id)
}

// optional uint32 area_id = 3 [default = 0];
inline bool CreateChannelRequest::has_area_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateChannelRequest::set_has_area_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateChannelRequest::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateChannelRequest::clear_area_id() {
  area_id_ = 0u;
  clear_has_area_id();
}
inline ::google::protobuf::uint32 CreateChannelRequest::area_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelRequest.area_id)
  return area_id_;
}
inline void CreateChannelRequest::set_area_id(::google::protobuf::uint32 value) {
  set_has_area_id();
  area_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelRequest.area_id)
}

// optional uint32 net_type = 4;
inline bool CreateChannelRequest::has_net_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateChannelRequest::set_has_net_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateChannelRequest::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateChannelRequest::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 CreateChannelRequest::net_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelRequest.net_type)
  return net_type_;
}
inline void CreateChannelRequest::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelRequest.net_type)
}

// repeated .qihoo.protocol.vcproxy.user_info member_list = 5;
inline int CreateChannelRequest::member_list_size() const {
  return member_list_.size();
}
inline void CreateChannelRequest::clear_member_list() {
  member_list_.Clear();
}
inline const ::qihoo::protocol::vcproxy::user_info& CreateChannelRequest::member_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelRequest.member_list)
  return member_list_.Get(index);
}
inline ::qihoo::protocol::vcproxy::user_info* CreateChannelRequest::mutable_member_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CreateChannelRequest.member_list)
  return member_list_.Mutable(index);
}
inline ::qihoo::protocol::vcproxy::user_info* CreateChannelRequest::add_member_list() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.vcproxy.CreateChannelRequest.member_list)
  return member_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::vcproxy::user_info >&
CreateChannelRequest::member_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.vcproxy.CreateChannelRequest.member_list)
  return member_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::vcproxy::user_info >*
CreateChannelRequest::mutable_member_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.vcproxy.CreateChannelRequest.member_list)
  return &member_list_;
}

// -------------------------------------------------------------------

// CreateChannelResponse

// required bytes channel_id = 1;
inline bool CreateChannelResponse::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateChannelResponse::set_has_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateChannelResponse::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateChannelResponse::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& CreateChannelResponse::channel_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
  return *channel_id_;
}
inline void CreateChannelResponse::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
}
inline void CreateChannelResponse::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
}
inline void CreateChannelResponse::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
}
inline ::std::string* CreateChannelResponse::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
  return channel_id_;
}
inline ::std::string* CreateChannelResponse::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateChannelResponse::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CreateChannelResponse.channel_id)
}

// required bytes channel_info = 2;
inline bool CreateChannelResponse::has_channel_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateChannelResponse::set_has_channel_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateChannelResponse::clear_has_channel_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateChannelResponse::clear_channel_info() {
  if (channel_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_info_->clear();
  }
  clear_has_channel_info();
}
inline const ::std::string& CreateChannelResponse::channel_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
  return *channel_info_;
}
inline void CreateChannelResponse::set_channel_info(const ::std::string& value) {
  set_has_channel_info();
  if (channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_info_ = new ::std::string;
  }
  channel_info_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
}
inline void CreateChannelResponse::set_channel_info(const char* value) {
  set_has_channel_info();
  if (channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_info_ = new ::std::string;
  }
  channel_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
}
inline void CreateChannelResponse::set_channel_info(const void* value, size_t size) {
  set_has_channel_info();
  if (channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_info_ = new ::std::string;
  }
  channel_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
}
inline ::std::string* CreateChannelResponse::mutable_channel_info() {
  set_has_channel_info();
  if (channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
  return channel_info_;
}
inline ::std::string* CreateChannelResponse::release_channel_info() {
  clear_has_channel_info();
  if (channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_info_;
    channel_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateChannelResponse::set_allocated_channel_info(::std::string* channel_info) {
  if (channel_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_info_;
  }
  if (channel_info) {
    set_has_channel_info();
    channel_info_ = channel_info;
  } else {
    clear_has_channel_info();
    channel_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CreateChannelResponse.channel_info)
}

// -------------------------------------------------------------------

// CheckChannelRequest

// required string requester = 1;
inline bool CheckChannelRequest::has_requester() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckChannelRequest::set_has_requester() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckChannelRequest::clear_has_requester() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckChannelRequest::clear_requester() {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_->clear();
  }
  clear_has_requester();
}
inline const ::std::string& CheckChannelRequest::requester() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
  return *requester_;
}
inline void CheckChannelRequest::set_requester(const ::std::string& value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
}
inline void CheckChannelRequest::set_requester(const char* value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
}
inline void CheckChannelRequest::set_requester(const char* value, size_t size) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
}
inline ::std::string* CheckChannelRequest::mutable_requester() {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
  return requester_;
}
inline ::std::string* CheckChannelRequest::release_requester() {
  clear_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requester_;
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CheckChannelRequest::set_allocated_requester(::std::string* requester) {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requester_;
  }
  if (requester) {
    set_has_requester();
    requester_ = requester;
  } else {
    clear_has_requester();
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CheckChannelRequest.requester)
}

// required bytes channel_id = 2;
inline bool CheckChannelRequest::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckChannelRequest::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckChannelRequest::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckChannelRequest::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& CheckChannelRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
  return *channel_id_;
}
inline void CheckChannelRequest::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
}
inline void CheckChannelRequest::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
}
inline void CheckChannelRequest::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
}
inline ::std::string* CheckChannelRequest::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
  return channel_id_;
}
inline ::std::string* CheckChannelRequest::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CheckChannelRequest::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.CheckChannelRequest.channel_id)
}

// -------------------------------------------------------------------

// CheckChannelResponse

// required int32 curr_member_num = 1;
inline bool CheckChannelResponse::has_curr_member_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckChannelResponse::set_has_curr_member_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckChannelResponse::clear_has_curr_member_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckChannelResponse::clear_curr_member_num() {
  curr_member_num_ = 0;
  clear_has_curr_member_num();
}
inline ::google::protobuf::int32 CheckChannelResponse::curr_member_num() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_num)
  return curr_member_num_;
}
inline void CheckChannelResponse::set_curr_member_num(::google::protobuf::int32 value) {
  set_has_curr_member_num();
  curr_member_num_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_num)
}

// repeated string curr_member_list = 2;
inline int CheckChannelResponse::curr_member_list_size() const {
  return curr_member_list_.size();
}
inline void CheckChannelResponse::clear_curr_member_list() {
  curr_member_list_.Clear();
}
inline const ::std::string& CheckChannelResponse::curr_member_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
  return curr_member_list_.Get(index);
}
inline ::std::string* CheckChannelResponse::mutable_curr_member_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
  return curr_member_list_.Mutable(index);
}
inline void CheckChannelResponse::set_curr_member_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
  curr_member_list_.Mutable(index)->assign(value);
}
inline void CheckChannelResponse::set_curr_member_list(int index, const char* value) {
  curr_member_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
}
inline void CheckChannelResponse::set_curr_member_list(int index, const char* value, size_t size) {
  curr_member_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
}
inline ::std::string* CheckChannelResponse::add_curr_member_list() {
  return curr_member_list_.Add();
}
inline void CheckChannelResponse::add_curr_member_list(const ::std::string& value) {
  curr_member_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
}
inline void CheckChannelResponse::add_curr_member_list(const char* value) {
  curr_member_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
}
inline void CheckChannelResponse::add_curr_member_list(const char* value, size_t size) {
  curr_member_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CheckChannelResponse::curr_member_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
  return curr_member_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CheckChannelResponse::mutable_curr_member_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.vcproxy.CheckChannelResponse.curr_member_list)
  return &curr_member_list_;
}

// -------------------------------------------------------------------

// RestoreChannelRequest

// required string requester = 1;
inline bool RestoreChannelRequest::has_requester() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestoreChannelRequest::set_has_requester() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestoreChannelRequest::clear_has_requester() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestoreChannelRequest::clear_requester() {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_->clear();
  }
  clear_has_requester();
}
inline const ::std::string& RestoreChannelRequest::requester() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
  return *requester_;
}
inline void RestoreChannelRequest::set_requester(const ::std::string& value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
}
inline void RestoreChannelRequest::set_requester(const char* value) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
}
inline void RestoreChannelRequest::set_requester(const char* value, size_t size) {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  requester_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
}
inline ::std::string* RestoreChannelRequest::mutable_requester() {
  set_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    requester_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
  return requester_;
}
inline ::std::string* RestoreChannelRequest::release_requester() {
  clear_has_requester();
  if (requester_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = requester_;
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RestoreChannelRequest::set_allocated_requester(::std::string* requester) {
  if (requester_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete requester_;
  }
  if (requester) {
    set_has_requester();
    requester_ = requester;
  } else {
    clear_has_requester();
    requester_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.RestoreChannelRequest.requester)
}

// required bytes channel_id = 2;
inline bool RestoreChannelRequest::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RestoreChannelRequest::set_has_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RestoreChannelRequest::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RestoreChannelRequest::clear_channel_id() {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_->clear();
  }
  clear_has_channel_id();
}
inline const ::std::string& RestoreChannelRequest::channel_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
  return *channel_id_;
}
inline void RestoreChannelRequest::set_channel_id(const ::std::string& value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
}
inline void RestoreChannelRequest::set_channel_id(const char* value) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
}
inline void RestoreChannelRequest::set_channel_id(const void* value, size_t size) {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
}
inline ::std::string* RestoreChannelRequest::mutable_channel_id() {
  set_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    channel_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
  return channel_id_;
}
inline ::std::string* RestoreChannelRequest::release_channel_id() {
  clear_has_channel_id();
  if (channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = channel_id_;
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RestoreChannelRequest::set_allocated_channel_id(::std::string* channel_id) {
  if (channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete channel_id_;
  }
  if (channel_id) {
    set_has_channel_id();
    channel_id_ = channel_id;
  } else {
    clear_has_channel_id();
    channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.RestoreChannelRequest.channel_id)
}

// -------------------------------------------------------------------

// RestoreChannelResponse

// required bytes new_channel_id = 1;
inline bool RestoreChannelResponse::has_new_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestoreChannelResponse::set_has_new_channel_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestoreChannelResponse::clear_has_new_channel_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestoreChannelResponse::clear_new_channel_id() {
  if (new_channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_id_->clear();
  }
  clear_has_new_channel_id();
}
inline const ::std::string& RestoreChannelResponse::new_channel_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
  return *new_channel_id_;
}
inline void RestoreChannelResponse::set_new_channel_id(const ::std::string& value) {
  set_has_new_channel_id();
  if (new_channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_id_ = new ::std::string;
  }
  new_channel_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
}
inline void RestoreChannelResponse::set_new_channel_id(const char* value) {
  set_has_new_channel_id();
  if (new_channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_id_ = new ::std::string;
  }
  new_channel_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
}
inline void RestoreChannelResponse::set_new_channel_id(const void* value, size_t size) {
  set_has_new_channel_id();
  if (new_channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_id_ = new ::std::string;
  }
  new_channel_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
}
inline ::std::string* RestoreChannelResponse::mutable_new_channel_id() {
  set_has_new_channel_id();
  if (new_channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
  return new_channel_id_;
}
inline ::std::string* RestoreChannelResponse::release_new_channel_id() {
  clear_has_new_channel_id();
  if (new_channel_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_channel_id_;
    new_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RestoreChannelResponse::set_allocated_new_channel_id(::std::string* new_channel_id) {
  if (new_channel_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_channel_id_;
  }
  if (new_channel_id) {
    set_has_new_channel_id();
    new_channel_id_ = new_channel_id;
  } else {
    clear_has_new_channel_id();
    new_channel_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_id)
}

// required bytes new_channel_info = 2;
inline bool RestoreChannelResponse::has_new_channel_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RestoreChannelResponse::set_has_new_channel_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RestoreChannelResponse::clear_has_new_channel_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RestoreChannelResponse::clear_new_channel_info() {
  if (new_channel_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_info_->clear();
  }
  clear_has_new_channel_info();
}
inline const ::std::string& RestoreChannelResponse::new_channel_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
  return *new_channel_info_;
}
inline void RestoreChannelResponse::set_new_channel_info(const ::std::string& value) {
  set_has_new_channel_info();
  if (new_channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_info_ = new ::std::string;
  }
  new_channel_info_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
}
inline void RestoreChannelResponse::set_new_channel_info(const char* value) {
  set_has_new_channel_info();
  if (new_channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_info_ = new ::std::string;
  }
  new_channel_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
}
inline void RestoreChannelResponse::set_new_channel_info(const void* value, size_t size) {
  set_has_new_channel_info();
  if (new_channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_info_ = new ::std::string;
  }
  new_channel_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
}
inline ::std::string* RestoreChannelResponse::mutable_new_channel_info() {
  set_has_new_channel_info();
  if (new_channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_channel_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
  return new_channel_info_;
}
inline ::std::string* RestoreChannelResponse::release_new_channel_info() {
  clear_has_new_channel_info();
  if (new_channel_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_channel_info_;
    new_channel_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RestoreChannelResponse::set_allocated_new_channel_info(::std::string* new_channel_info) {
  if (new_channel_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_channel_info_;
  }
  if (new_channel_info) {
    set_has_new_channel_info();
    new_channel_info_ = new_channel_info;
  } else {
    clear_has_new_channel_info();
    new_channel_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.RestoreChannelResponse.new_channel_info)
}

// optional uint32 curr_member_num = 3;
inline bool RestoreChannelResponse::has_curr_member_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RestoreChannelResponse::set_has_curr_member_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RestoreChannelResponse::clear_has_curr_member_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RestoreChannelResponse::clear_curr_member_num() {
  curr_member_num_ = 0u;
  clear_has_curr_member_num();
}
inline ::google::protobuf::uint32 RestoreChannelResponse::curr_member_num() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_num)
  return curr_member_num_;
}
inline void RestoreChannelResponse::set_curr_member_num(::google::protobuf::uint32 value) {
  set_has_curr_member_num();
  curr_member_num_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_num)
}

// repeated string curr_member_list = 4;
inline int RestoreChannelResponse::curr_member_list_size() const {
  return curr_member_list_.size();
}
inline void RestoreChannelResponse::clear_curr_member_list() {
  curr_member_list_.Clear();
}
inline const ::std::string& RestoreChannelResponse::curr_member_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
  return curr_member_list_.Get(index);
}
inline ::std::string* RestoreChannelResponse::mutable_curr_member_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
  return curr_member_list_.Mutable(index);
}
inline void RestoreChannelResponse::set_curr_member_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
  curr_member_list_.Mutable(index)->assign(value);
}
inline void RestoreChannelResponse::set_curr_member_list(int index, const char* value) {
  curr_member_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
}
inline void RestoreChannelResponse::set_curr_member_list(int index, const char* value, size_t size) {
  curr_member_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
}
inline ::std::string* RestoreChannelResponse::add_curr_member_list() {
  return curr_member_list_.Add();
}
inline void RestoreChannelResponse::add_curr_member_list(const ::std::string& value) {
  curr_member_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
}
inline void RestoreChannelResponse::add_curr_member_list(const char* value) {
  curr_member_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
}
inline void RestoreChannelResponse::add_curr_member_list(const char* value, size_t size) {
  curr_member_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RestoreChannelResponse::curr_member_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
  return curr_member_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RestoreChannelResponse::mutable_curr_member_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.vcproxy.RestoreChannelResponse.curr_member_list)
  return &curr_member_list_;
}

// -------------------------------------------------------------------

// NewChannelNotify

// -------------------------------------------------------------------

// VCProxyUserToServer

// optional .qihoo.protocol.vcproxy.CreateChannelRequest create_channel_req = 1;
inline bool VCProxyUserToServer::has_create_channel_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VCProxyUserToServer::set_has_create_channel_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VCProxyUserToServer::clear_has_create_channel_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VCProxyUserToServer::clear_create_channel_req() {
  if (create_channel_req_ != NULL) create_channel_req_->::qihoo::protocol::vcproxy::CreateChannelRequest::Clear();
  clear_has_create_channel_req();
}
inline const ::qihoo::protocol::vcproxy::CreateChannelRequest& VCProxyUserToServer::create_channel_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyUserToServer.create_channel_req)
  return create_channel_req_ != NULL ? *create_channel_req_ : *default_instance_->create_channel_req_;
}
inline ::qihoo::protocol::vcproxy::CreateChannelRequest* VCProxyUserToServer::mutable_create_channel_req() {
  set_has_create_channel_req();
  if (create_channel_req_ == NULL) create_channel_req_ = new ::qihoo::protocol::vcproxy::CreateChannelRequest;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyUserToServer.create_channel_req)
  return create_channel_req_;
}
inline ::qihoo::protocol::vcproxy::CreateChannelRequest* VCProxyUserToServer::release_create_channel_req() {
  clear_has_create_channel_req();
  ::qihoo::protocol::vcproxy::CreateChannelRequest* temp = create_channel_req_;
  create_channel_req_ = NULL;
  return temp;
}
inline void VCProxyUserToServer::set_allocated_create_channel_req(::qihoo::protocol::vcproxy::CreateChannelRequest* create_channel_req) {
  delete create_channel_req_;
  create_channel_req_ = create_channel_req;
  if (create_channel_req) {
    set_has_create_channel_req();
  } else {
    clear_has_create_channel_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyUserToServer.create_channel_req)
}

// optional .qihoo.protocol.vcproxy.CheckChannelRequest check_channel_req = 2;
inline bool VCProxyUserToServer::has_check_channel_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VCProxyUserToServer::set_has_check_channel_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VCProxyUserToServer::clear_has_check_channel_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VCProxyUserToServer::clear_check_channel_req() {
  if (check_channel_req_ != NULL) check_channel_req_->::qihoo::protocol::vcproxy::CheckChannelRequest::Clear();
  clear_has_check_channel_req();
}
inline const ::qihoo::protocol::vcproxy::CheckChannelRequest& VCProxyUserToServer::check_channel_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyUserToServer.check_channel_req)
  return check_channel_req_ != NULL ? *check_channel_req_ : *default_instance_->check_channel_req_;
}
inline ::qihoo::protocol::vcproxy::CheckChannelRequest* VCProxyUserToServer::mutable_check_channel_req() {
  set_has_check_channel_req();
  if (check_channel_req_ == NULL) check_channel_req_ = new ::qihoo::protocol::vcproxy::CheckChannelRequest;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyUserToServer.check_channel_req)
  return check_channel_req_;
}
inline ::qihoo::protocol::vcproxy::CheckChannelRequest* VCProxyUserToServer::release_check_channel_req() {
  clear_has_check_channel_req();
  ::qihoo::protocol::vcproxy::CheckChannelRequest* temp = check_channel_req_;
  check_channel_req_ = NULL;
  return temp;
}
inline void VCProxyUserToServer::set_allocated_check_channel_req(::qihoo::protocol::vcproxy::CheckChannelRequest* check_channel_req) {
  delete check_channel_req_;
  check_channel_req_ = check_channel_req;
  if (check_channel_req) {
    set_has_check_channel_req();
  } else {
    clear_has_check_channel_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyUserToServer.check_channel_req)
}

// optional .qihoo.protocol.vcproxy.RestoreChannelRequest restore_channel_req = 3;
inline bool VCProxyUserToServer::has_restore_channel_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VCProxyUserToServer::set_has_restore_channel_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VCProxyUserToServer::clear_has_restore_channel_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VCProxyUserToServer::clear_restore_channel_req() {
  if (restore_channel_req_ != NULL) restore_channel_req_->::qihoo::protocol::vcproxy::RestoreChannelRequest::Clear();
  clear_has_restore_channel_req();
}
inline const ::qihoo::protocol::vcproxy::RestoreChannelRequest& VCProxyUserToServer::restore_channel_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyUserToServer.restore_channel_req)
  return restore_channel_req_ != NULL ? *restore_channel_req_ : *default_instance_->restore_channel_req_;
}
inline ::qihoo::protocol::vcproxy::RestoreChannelRequest* VCProxyUserToServer::mutable_restore_channel_req() {
  set_has_restore_channel_req();
  if (restore_channel_req_ == NULL) restore_channel_req_ = new ::qihoo::protocol::vcproxy::RestoreChannelRequest;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyUserToServer.restore_channel_req)
  return restore_channel_req_;
}
inline ::qihoo::protocol::vcproxy::RestoreChannelRequest* VCProxyUserToServer::release_restore_channel_req() {
  clear_has_restore_channel_req();
  ::qihoo::protocol::vcproxy::RestoreChannelRequest* temp = restore_channel_req_;
  restore_channel_req_ = NULL;
  return temp;
}
inline void VCProxyUserToServer::set_allocated_restore_channel_req(::qihoo::protocol::vcproxy::RestoreChannelRequest* restore_channel_req) {
  delete restore_channel_req_;
  restore_channel_req_ = restore_channel_req;
  if (restore_channel_req) {
    set_has_restore_channel_req();
  } else {
    clear_has_restore_channel_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyUserToServer.restore_channel_req)
}

// -------------------------------------------------------------------

// VCProxyServerToUser

// required int32 result = 1;
inline bool VCProxyServerToUser::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VCProxyServerToUser::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VCProxyServerToUser::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VCProxyServerToUser::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 VCProxyServerToUser::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyServerToUser.result)
  return result_;
}
inline void VCProxyServerToUser::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.VCProxyServerToUser.result)
}

// optional .qihoo.protocol.vcproxy.ErrorInfo error_info = 2;
inline bool VCProxyServerToUser::has_error_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VCProxyServerToUser::set_has_error_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VCProxyServerToUser::clear_has_error_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VCProxyServerToUser::clear_error_info() {
  if (error_info_ != NULL) error_info_->::qihoo::protocol::vcproxy::ErrorInfo::Clear();
  clear_has_error_info();
}
inline const ::qihoo::protocol::vcproxy::ErrorInfo& VCProxyServerToUser::error_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyServerToUser.error_info)
  return error_info_ != NULL ? *error_info_ : *default_instance_->error_info_;
}
inline ::qihoo::protocol::vcproxy::ErrorInfo* VCProxyServerToUser::mutable_error_info() {
  set_has_error_info();
  if (error_info_ == NULL) error_info_ = new ::qihoo::protocol::vcproxy::ErrorInfo;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyServerToUser.error_info)
  return error_info_;
}
inline ::qihoo::protocol::vcproxy::ErrorInfo* VCProxyServerToUser::release_error_info() {
  clear_has_error_info();
  ::qihoo::protocol::vcproxy::ErrorInfo* temp = error_info_;
  error_info_ = NULL;
  return temp;
}
inline void VCProxyServerToUser::set_allocated_error_info(::qihoo::protocol::vcproxy::ErrorInfo* error_info) {
  delete error_info_;
  error_info_ = error_info;
  if (error_info) {
    set_has_error_info();
  } else {
    clear_has_error_info();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyServerToUser.error_info)
}

// optional .qihoo.protocol.vcproxy.CreateChannelResponse create_channel_resp = 3;
inline bool VCProxyServerToUser::has_create_channel_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VCProxyServerToUser::set_has_create_channel_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VCProxyServerToUser::clear_has_create_channel_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VCProxyServerToUser::clear_create_channel_resp() {
  if (create_channel_resp_ != NULL) create_channel_resp_->::qihoo::protocol::vcproxy::CreateChannelResponse::Clear();
  clear_has_create_channel_resp();
}
inline const ::qihoo::protocol::vcproxy::CreateChannelResponse& VCProxyServerToUser::create_channel_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyServerToUser.create_channel_resp)
  return create_channel_resp_ != NULL ? *create_channel_resp_ : *default_instance_->create_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::CreateChannelResponse* VCProxyServerToUser::mutable_create_channel_resp() {
  set_has_create_channel_resp();
  if (create_channel_resp_ == NULL) create_channel_resp_ = new ::qihoo::protocol::vcproxy::CreateChannelResponse;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyServerToUser.create_channel_resp)
  return create_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::CreateChannelResponse* VCProxyServerToUser::release_create_channel_resp() {
  clear_has_create_channel_resp();
  ::qihoo::protocol::vcproxy::CreateChannelResponse* temp = create_channel_resp_;
  create_channel_resp_ = NULL;
  return temp;
}
inline void VCProxyServerToUser::set_allocated_create_channel_resp(::qihoo::protocol::vcproxy::CreateChannelResponse* create_channel_resp) {
  delete create_channel_resp_;
  create_channel_resp_ = create_channel_resp;
  if (create_channel_resp) {
    set_has_create_channel_resp();
  } else {
    clear_has_create_channel_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyServerToUser.create_channel_resp)
}

// optional .qihoo.protocol.vcproxy.CheckChannelResponse check_channel_resp = 4;
inline bool VCProxyServerToUser::has_check_channel_resp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VCProxyServerToUser::set_has_check_channel_resp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VCProxyServerToUser::clear_has_check_channel_resp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VCProxyServerToUser::clear_check_channel_resp() {
  if (check_channel_resp_ != NULL) check_channel_resp_->::qihoo::protocol::vcproxy::CheckChannelResponse::Clear();
  clear_has_check_channel_resp();
}
inline const ::qihoo::protocol::vcproxy::CheckChannelResponse& VCProxyServerToUser::check_channel_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyServerToUser.check_channel_resp)
  return check_channel_resp_ != NULL ? *check_channel_resp_ : *default_instance_->check_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::CheckChannelResponse* VCProxyServerToUser::mutable_check_channel_resp() {
  set_has_check_channel_resp();
  if (check_channel_resp_ == NULL) check_channel_resp_ = new ::qihoo::protocol::vcproxy::CheckChannelResponse;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyServerToUser.check_channel_resp)
  return check_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::CheckChannelResponse* VCProxyServerToUser::release_check_channel_resp() {
  clear_has_check_channel_resp();
  ::qihoo::protocol::vcproxy::CheckChannelResponse* temp = check_channel_resp_;
  check_channel_resp_ = NULL;
  return temp;
}
inline void VCProxyServerToUser::set_allocated_check_channel_resp(::qihoo::protocol::vcproxy::CheckChannelResponse* check_channel_resp) {
  delete check_channel_resp_;
  check_channel_resp_ = check_channel_resp;
  if (check_channel_resp) {
    set_has_check_channel_resp();
  } else {
    clear_has_check_channel_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyServerToUser.check_channel_resp)
}

// optional .qihoo.protocol.vcproxy.RestoreChannelResponse restore_channel_resp = 5;
inline bool VCProxyServerToUser::has_restore_channel_resp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VCProxyServerToUser::set_has_restore_channel_resp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VCProxyServerToUser::clear_has_restore_channel_resp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VCProxyServerToUser::clear_restore_channel_resp() {
  if (restore_channel_resp_ != NULL) restore_channel_resp_->::qihoo::protocol::vcproxy::RestoreChannelResponse::Clear();
  clear_has_restore_channel_resp();
}
inline const ::qihoo::protocol::vcproxy::RestoreChannelResponse& VCProxyServerToUser::restore_channel_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyServerToUser.restore_channel_resp)
  return restore_channel_resp_ != NULL ? *restore_channel_resp_ : *default_instance_->restore_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::RestoreChannelResponse* VCProxyServerToUser::mutable_restore_channel_resp() {
  set_has_restore_channel_resp();
  if (restore_channel_resp_ == NULL) restore_channel_resp_ = new ::qihoo::protocol::vcproxy::RestoreChannelResponse;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyServerToUser.restore_channel_resp)
  return restore_channel_resp_;
}
inline ::qihoo::protocol::vcproxy::RestoreChannelResponse* VCProxyServerToUser::release_restore_channel_resp() {
  clear_has_restore_channel_resp();
  ::qihoo::protocol::vcproxy::RestoreChannelResponse* temp = restore_channel_resp_;
  restore_channel_resp_ = NULL;
  return temp;
}
inline void VCProxyServerToUser::set_allocated_restore_channel_resp(::qihoo::protocol::vcproxy::RestoreChannelResponse* restore_channel_resp) {
  delete restore_channel_resp_;
  restore_channel_resp_ = restore_channel_resp;
  if (restore_channel_resp) {
    set_has_restore_channel_resp();
  } else {
    clear_has_restore_channel_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyServerToUser.restore_channel_resp)
}

// -------------------------------------------------------------------

// VCProxyNotify

// optional .qihoo.protocol.vcproxy.NewChannelNotify new_channel_notify = 1;
inline bool VCProxyNotify::has_new_channel_notify() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VCProxyNotify::set_has_new_channel_notify() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VCProxyNotify::clear_has_new_channel_notify() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VCProxyNotify::clear_new_channel_notify() {
  if (new_channel_notify_ != NULL) new_channel_notify_->::qihoo::protocol::vcproxy::NewChannelNotify::Clear();
  clear_has_new_channel_notify();
}
inline const ::qihoo::protocol::vcproxy::NewChannelNotify& VCProxyNotify::new_channel_notify() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyNotify.new_channel_notify)
  return new_channel_notify_ != NULL ? *new_channel_notify_ : *default_instance_->new_channel_notify_;
}
inline ::qihoo::protocol::vcproxy::NewChannelNotify* VCProxyNotify::mutable_new_channel_notify() {
  set_has_new_channel_notify();
  if (new_channel_notify_ == NULL) new_channel_notify_ = new ::qihoo::protocol::vcproxy::NewChannelNotify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyNotify.new_channel_notify)
  return new_channel_notify_;
}
inline ::qihoo::protocol::vcproxy::NewChannelNotify* VCProxyNotify::release_new_channel_notify() {
  clear_has_new_channel_notify();
  ::qihoo::protocol::vcproxy::NewChannelNotify* temp = new_channel_notify_;
  new_channel_notify_ = NULL;
  return temp;
}
inline void VCProxyNotify::set_allocated_new_channel_notify(::qihoo::protocol::vcproxy::NewChannelNotify* new_channel_notify) {
  delete new_channel_notify_;
  new_channel_notify_ = new_channel_notify;
  if (new_channel_notify) {
    set_has_new_channel_notify();
  } else {
    clear_has_new_channel_notify();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyNotify.new_channel_notify)
}

// -------------------------------------------------------------------

// VCProxyPacket

// required uint32 payload_type = 1;
inline bool VCProxyPacket::has_payload_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VCProxyPacket::set_has_payload_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VCProxyPacket::clear_has_payload_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VCProxyPacket::clear_payload_type() {
  payload_type_ = 0u;
  clear_has_payload_type();
}
inline ::google::protobuf::uint32 VCProxyPacket::payload_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyPacket.payload_type)
  return payload_type_;
}
inline void VCProxyPacket::set_payload_type(::google::protobuf::uint32 value) {
  set_has_payload_type();
  payload_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.vcproxy.VCProxyPacket.payload_type)
}

// optional .qihoo.protocol.vcproxy.VCProxyUserToServer user_data = 2;
inline bool VCProxyPacket::has_user_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VCProxyPacket::set_has_user_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VCProxyPacket::clear_has_user_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VCProxyPacket::clear_user_data() {
  if (user_data_ != NULL) user_data_->::qihoo::protocol::vcproxy::VCProxyUserToServer::Clear();
  clear_has_user_data();
}
inline const ::qihoo::protocol::vcproxy::VCProxyUserToServer& VCProxyPacket::user_data() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyPacket.user_data)
  return user_data_ != NULL ? *user_data_ : *default_instance_->user_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyUserToServer* VCProxyPacket::mutable_user_data() {
  set_has_user_data();
  if (user_data_ == NULL) user_data_ = new ::qihoo::protocol::vcproxy::VCProxyUserToServer;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyPacket.user_data)
  return user_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyUserToServer* VCProxyPacket::release_user_data() {
  clear_has_user_data();
  ::qihoo::protocol::vcproxy::VCProxyUserToServer* temp = user_data_;
  user_data_ = NULL;
  return temp;
}
inline void VCProxyPacket::set_allocated_user_data(::qihoo::protocol::vcproxy::VCProxyUserToServer* user_data) {
  delete user_data_;
  user_data_ = user_data;
  if (user_data) {
    set_has_user_data();
  } else {
    clear_has_user_data();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyPacket.user_data)
}

// optional .qihoo.protocol.vcproxy.VCProxyServerToUser server_data = 3;
inline bool VCProxyPacket::has_server_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VCProxyPacket::set_has_server_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VCProxyPacket::clear_has_server_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VCProxyPacket::clear_server_data() {
  if (server_data_ != NULL) server_data_->::qihoo::protocol::vcproxy::VCProxyServerToUser::Clear();
  clear_has_server_data();
}
inline const ::qihoo::protocol::vcproxy::VCProxyServerToUser& VCProxyPacket::server_data() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyPacket.server_data)
  return server_data_ != NULL ? *server_data_ : *default_instance_->server_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyServerToUser* VCProxyPacket::mutable_server_data() {
  set_has_server_data();
  if (server_data_ == NULL) server_data_ = new ::qihoo::protocol::vcproxy::VCProxyServerToUser;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyPacket.server_data)
  return server_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyServerToUser* VCProxyPacket::release_server_data() {
  clear_has_server_data();
  ::qihoo::protocol::vcproxy::VCProxyServerToUser* temp = server_data_;
  server_data_ = NULL;
  return temp;
}
inline void VCProxyPacket::set_allocated_server_data(::qihoo::protocol::vcproxy::VCProxyServerToUser* server_data) {
  delete server_data_;
  server_data_ = server_data;
  if (server_data) {
    set_has_server_data();
  } else {
    clear_has_server_data();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyPacket.server_data)
}

// optional .qihoo.protocol.vcproxy.VCProxyNotify notify_data = 4;
inline bool VCProxyPacket::has_notify_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VCProxyPacket::set_has_notify_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VCProxyPacket::clear_has_notify_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VCProxyPacket::clear_notify_data() {
  if (notify_data_ != NULL) notify_data_->::qihoo::protocol::vcproxy::VCProxyNotify::Clear();
  clear_has_notify_data();
}
inline const ::qihoo::protocol::vcproxy::VCProxyNotify& VCProxyPacket::notify_data() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.vcproxy.VCProxyPacket.notify_data)
  return notify_data_ != NULL ? *notify_data_ : *default_instance_->notify_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyNotify* VCProxyPacket::mutable_notify_data() {
  set_has_notify_data();
  if (notify_data_ == NULL) notify_data_ = new ::qihoo::protocol::vcproxy::VCProxyNotify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.vcproxy.VCProxyPacket.notify_data)
  return notify_data_;
}
inline ::qihoo::protocol::vcproxy::VCProxyNotify* VCProxyPacket::release_notify_data() {
  clear_has_notify_data();
  ::qihoo::protocol::vcproxy::VCProxyNotify* temp = notify_data_;
  notify_data_ = NULL;
  return temp;
}
inline void VCProxyPacket::set_allocated_notify_data(::qihoo::protocol::vcproxy::VCProxyNotify* notify_data) {
  delete notify_data_;
  notify_data_ = notify_data;
  if (notify_data) {
    set_has_notify_data();
  } else {
    clear_has_notify_data();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.vcproxy.VCProxyPacket.notify_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vcproxy
}  // namespace protocol
}  // namespace qihoo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vcproxy_2eproto__INCLUDED
