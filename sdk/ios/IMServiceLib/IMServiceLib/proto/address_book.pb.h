// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: address_book.proto

#ifndef PROTOBUF_address_5fbook_2eproto__INCLUDED
#define PROTOBUF_address_5fbook_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace qihoo {
namespace protocol {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_address_5fbook_2eproto();
void protobuf_AssignDesc_address_5fbook_2eproto();
void protobuf_ShutdownFile_address_5fbook_2eproto();

class Pair;
class Error;
class User;
class Info;
class LoginReq;
class LoginResp;
class ChatReq;
class ChatResp;
class GetInfoReq;
class GetInfoResp;
class GetMultiInfosReq;
class GetMultiInfosResp;
class LogoutReq;
class LogoutResp;
class InitLoginReq;
class InitLoginResp;
class Service_Req;
class Service_Resp;
class ReqEQ1User;
class RespEQ1User;
class Ex1QueryUserStatusReq;
class Ex1QueryUserStatusResp;
class Request;
class Response;
class NewMessageNotify;
class ReLoginNotify;
class ReConnectNotify;
class Notify;
class Ack;
class RouteInfo;
class Proxy;
class Message;

// ===================================================================

class Pair : public ::google::protobuf::Message {
 public:
  Pair();
  virtual ~Pair();

  Pair(const Pair& from);

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pair& default_instance();

  void Swap(Pair* other);

  // implements Message ----------------------------------------------

  Pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Pair* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional bytes description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const void* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Error)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* description_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // repeated .qihoo.protocol.messages.Pair property_pairs = 2;
  inline int property_pairs_size() const;
  inline void clear_property_pairs();
  static const int kPropertyPairsFieldNumber = 2;
  inline const ::qihoo::protocol::messages::Pair& property_pairs(int index) const;
  inline ::qihoo::protocol::messages::Pair* mutable_property_pairs(int index);
  inline ::qihoo::protocol::messages::Pair* add_property_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
      property_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
      mutable_property_pairs();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.User)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair > property_pairs_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Info : public ::google::protobuf::Message {
 public:
  Info();
  virtual ~Info();

  Info(const Info& from);

  inline Info& operator=(const Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Info& default_instance();

  void Swap(Info* other);

  // implements Message ----------------------------------------------

  Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Info& from);
  void MergeFrom(const Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.Pair property_pairs = 1;
  inline int property_pairs_size() const;
  inline void clear_property_pairs();
  static const int kPropertyPairsFieldNumber = 1;
  inline const ::qihoo::protocol::messages::Pair& property_pairs(int index) const;
  inline ::qihoo::protocol::messages::Pair* mutable_property_pairs(int index);
  inline ::qihoo::protocol::messages::Pair* add_property_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
      property_pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
      mutable_property_pairs();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair > property_pairs_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Info* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mobile_type = 1;
  inline bool has_mobile_type() const;
  inline void clear_mobile_type();
  static const int kMobileTypeFieldNumber = 1;
  inline const ::std::string& mobile_type() const;
  inline void set_mobile_type(const ::std::string& value);
  inline void set_mobile_type(const char* value);
  inline void set_mobile_type(const char* value, size_t size);
  inline ::std::string* mutable_mobile_type();
  inline ::std::string* release_mobile_type();
  inline void set_allocated_mobile_type(::std::string* mobile_type);

  // required uint32 net_type = 2;
  inline bool has_net_type() const;
  inline void clear_net_type();
  static const int kNetTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 net_type() const;
  inline void set_net_type(::google::protobuf::uint32 value);

  // required string server_ram = 3;
  inline bool has_server_ram() const;
  inline void clear_server_ram();
  static const int kServerRamFieldNumber = 3;
  inline const ::std::string& server_ram() const;
  inline void set_server_ram(const ::std::string& value);
  inline void set_server_ram(const char* value);
  inline void set_server_ram(const char* value, size_t size);
  inline ::std::string* mutable_server_ram();
  inline ::std::string* release_server_ram();
  inline void set_allocated_server_ram(::std::string* server_ram);

  // optional bytes secret_ram = 4;
  inline bool has_secret_ram() const;
  inline void clear_secret_ram();
  static const int kSecretRamFieldNumber = 4;
  inline const ::std::string& secret_ram() const;
  inline void set_secret_ram(const ::std::string& value);
  inline void set_secret_ram(const char* value);
  inline void set_secret_ram(const void* value, size_t size);
  inline ::std::string* mutable_secret_ram();
  inline ::std::string* release_secret_ram();
  inline void set_allocated_secret_ram(::std::string* secret_ram);

  // optional uint32 app_id = 5 [default = 2000];
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 5;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 heart_feq = 6 [default = 300];
  inline bool has_heart_feq() const;
  inline void clear_heart_feq();
  static const int kHeartFeqFieldNumber = 6;
  inline ::google::protobuf::uint32 heart_feq() const;
  inline void set_heart_feq(::google::protobuf::uint32 value);

  // optional string deviceid = 7 [default = ""];
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 7;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string platform = 8;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 8;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string verf_code = 9;
  inline bool has_verf_code() const;
  inline void clear_verf_code();
  static const int kVerfCodeFieldNumber = 9;
  inline const ::std::string& verf_code() const;
  inline void set_verf_code(const ::std::string& value);
  inline void set_verf_code(const char* value);
  inline void set_verf_code(const char* value, size_t size);
  inline ::std::string* mutable_verf_code();
  inline ::std::string* release_verf_code();
  inline void set_allocated_verf_code(::std::string* verf_code);

  // optional bool not_encrypt = 10;
  inline bool has_not_encrypt() const;
  inline void clear_not_encrypt();
  static const int kNotEncryptFieldNumber = 10;
  inline bool not_encrypt() const;
  inline void set_not_encrypt(bool value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LoginReq)
 private:
  inline void set_has_mobile_type();
  inline void clear_has_mobile_type();
  inline void set_has_net_type();
  inline void clear_has_net_type();
  inline void set_has_server_ram();
  inline void clear_has_server_ram();
  inline void set_has_secret_ram();
  inline void clear_has_secret_ram();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_heart_feq();
  inline void clear_has_heart_feq();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_verf_code();
  inline void clear_has_verf_code();
  inline void set_has_not_encrypt();
  inline void clear_has_not_encrypt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mobile_type_;
  ::std::string* server_ram_;
  ::google::protobuf::uint32 net_type_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* secret_ram_;
  ::std::string* deviceid_;
  ::std::string* platform_;
  ::google::protobuf::uint32 heart_feq_;
  bool not_encrypt_;
  ::std::string* verf_code_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginResp : public ::google::protobuf::Message {
 public:
  LoginResp();
  virtual ~LoginResp();

  LoginResp(const LoginResp& from);

  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResp& default_instance();

  void Swap(LoginResp* other);

  // implements Message ----------------------------------------------

  LoginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResp& from);
  void MergeFrom(const LoginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // required string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // required string session_key = 3;
  inline bool has_session_key() const;
  inline void clear_session_key();
  static const int kSessionKeyFieldNumber = 3;
  inline const ::std::string& session_key() const;
  inline void set_session_key(const ::std::string& value);
  inline void set_session_key(const char* value);
  inline void set_session_key(const char* value, size_t size);
  inline ::std::string* mutable_session_key();
  inline ::std::string* release_session_key();
  inline void set_allocated_session_key(::std::string* session_key);

  // optional string client_login_ip = 4;
  inline bool has_client_login_ip() const;
  inline void clear_client_login_ip();
  static const int kClientLoginIpFieldNumber = 4;
  inline const ::std::string& client_login_ip() const;
  inline void set_client_login_ip(const ::std::string& value);
  inline void set_client_login_ip(const char* value);
  inline void set_client_login_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_login_ip();
  inline ::std::string* release_client_login_ip();
  inline void set_allocated_client_login_ip(::std::string* client_login_ip);

  // optional string serverip = 5;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServeripFieldNumber = 5;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LoginResp)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_key();
  inline void clear_has_session_key();
  inline void set_has_client_login_ip();
  inline void clear_has_client_login_ip();
  inline void set_has_serverip();
  inline void clear_has_serverip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* session_id_;
  ::std::string* session_key_;
  ::std::string* client_login_ip_;
  ::std::string* serverip_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static LoginResp* default_instance_;
};
// -------------------------------------------------------------------

class ChatReq : public ::google::protobuf::Message {
 public:
  ChatReq();
  virtual ~ChatReq();

  ChatReq(const ChatReq& from);

  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReq& default_instance();

  void Swap(ChatReq* other);

  // implements Message ----------------------------------------------

  ChatReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes body = 1;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 1;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional uint32 body_id = 2;
  inline bool has_body_id() const;
  inline void clear_body_id();
  static const int kBodyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 body_id() const;
  inline void set_body_id(::google::protobuf::uint32 value);

  // optional uint32 more_flag = 3;
  inline bool has_more_flag() const;
  inline void clear_more_flag();
  static const int kMoreFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 more_flag() const;
  inline void set_more_flag(::google::protobuf::uint32 value);

  // required uint32 body_type = 4;
  inline bool has_body_type() const;
  inline void clear_body_type();
  static const int kBodyTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 body_type() const;
  inline void set_body_type(::google::protobuf::uint32 value);

  // optional bool store = 5;
  inline bool has_store() const;
  inline void clear_store();
  static const int kStoreFieldNumber = 5;
  inline bool store() const;
  inline void set_store(bool value);

  // optional bytes m_parameter = 6;
  inline bool has_m_parameter() const;
  inline void clear_m_parameter();
  static const int kMParameterFieldNumber = 6;
  inline const ::std::string& m_parameter() const;
  inline void set_m_parameter(const ::std::string& value);
  inline void set_m_parameter(const char* value);
  inline void set_m_parameter(const void* value, size_t size);
  inline ::std::string* mutable_m_parameter();
  inline ::std::string* release_m_parameter();
  inline void set_allocated_m_parameter(::std::string* m_parameter);

  // optional uint32 service_id = 7;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 7;
  inline ::google::protobuf::uint32 service_id() const;
  inline void set_service_id(::google::protobuf::uint32 value);

  // optional bytes s_parameter = 8;
  inline bool has_s_parameter() const;
  inline void clear_s_parameter();
  static const int kSParameterFieldNumber = 8;
  inline const ::std::string& s_parameter() const;
  inline void set_s_parameter(const ::std::string& value);
  inline void set_s_parameter(const char* value);
  inline void set_s_parameter(const void* value, size_t size);
  inline ::std::string* mutable_s_parameter();
  inline ::std::string* release_s_parameter();
  inline void set_allocated_s_parameter(::std::string* s_parameter);

  // optional uint32 expire_time = 12;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 expire_time() const;
  inline void set_expire_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ChatReq)
 private:
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_body_id();
  inline void clear_has_body_id();
  inline void set_has_more_flag();
  inline void clear_has_more_flag();
  inline void set_has_body_type();
  inline void clear_has_body_type();
  inline void set_has_store();
  inline void clear_has_store();
  inline void set_has_m_parameter();
  inline void clear_has_m_parameter();
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_s_parameter();
  inline void clear_has_s_parameter();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* body_;
  ::google::protobuf::uint32 body_id_;
  ::google::protobuf::uint32 more_flag_;
  ::google::protobuf::uint32 body_type_;
  bool store_;
  ::std::string* m_parameter_;
  ::std::string* s_parameter_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::uint32 expire_time_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static ChatReq* default_instance_;
};
// -------------------------------------------------------------------

class ChatResp : public ::google::protobuf::Message {
 public:
  ChatResp();
  virtual ~ChatResp();

  ChatResp(const ChatResp& from);

  inline ChatResp& operator=(const ChatResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatResp& default_instance();

  void Swap(ChatResp* other);

  // implements Message ----------------------------------------------

  ChatResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatResp& from);
  void MergeFrom(const ChatResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 body_id = 2;
  inline bool has_body_id() const;
  inline void clear_body_id();
  static const int kBodyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 body_id() const;
  inline void set_body_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ChatResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_body_id();
  inline void clear_has_body_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 body_id_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static ChatResp* default_instance_;
};
// -------------------------------------------------------------------

class GetInfoReq : public ::google::protobuf::Message {
 public:
  GetInfoReq();
  virtual ~GetInfoReq();

  GetInfoReq(const GetInfoReq& from);

  inline GetInfoReq& operator=(const GetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInfoReq& default_instance();

  void Swap(GetInfoReq* other);

  // implements Message ----------------------------------------------

  GetInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInfoReq& from);
  void MergeFrom(const GetInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline const ::std::string& info_type() const;
  inline void set_info_type(const ::std::string& value);
  inline void set_info_type(const char* value);
  inline void set_info_type(const char* value, size_t size);
  inline ::std::string* mutable_info_type();
  inline ::std::string* release_info_type();
  inline void set_allocated_info_type(::std::string* info_type);

  // required int64 get_info_id = 2;
  inline bool has_get_info_id() const;
  inline void clear_get_info_id();
  static const int kGetInfoIdFieldNumber = 2;
  inline ::google::protobuf::int64 get_info_id() const;
  inline void set_get_info_id(::google::protobuf::int64 value);

  // optional int32 get_info_offset = 3;
  inline bool has_get_info_offset() const;
  inline void clear_get_info_offset();
  static const int kGetInfoOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 get_info_offset() const;
  inline void set_get_info_offset(::google::protobuf::int32 value);

  // optional bytes s_parameter = 4;
  inline bool has_s_parameter() const;
  inline void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  inline const ::std::string& s_parameter() const;
  inline void set_s_parameter(const ::std::string& value);
  inline void set_s_parameter(const char* value);
  inline void set_s_parameter(const void* value, size_t size);
  inline ::std::string* mutable_s_parameter();
  inline ::std::string* release_s_parameter();
  inline void set_allocated_s_parameter(::std::string* s_parameter);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetInfoReq)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_get_info_id();
  inline void clear_has_get_info_id();
  inline void set_has_get_info_offset();
  inline void clear_has_get_info_offset();
  inline void set_has_s_parameter();
  inline void clear_has_s_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_type_;
  ::google::protobuf::int64 get_info_id_;
  ::std::string* s_parameter_;
  ::google::protobuf::int32 get_info_offset_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static GetInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GetInfoResp : public ::google::protobuf::Message {
 public:
  GetInfoResp();
  virtual ~GetInfoResp();

  GetInfoResp(const GetInfoResp& from);

  inline GetInfoResp& operator=(const GetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInfoResp& default_instance();

  void Swap(GetInfoResp* other);

  // implements Message ----------------------------------------------

  GetInfoResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInfoResp& from);
  void MergeFrom(const GetInfoResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline const ::std::string& info_type() const;
  inline void set_info_type(const ::std::string& value);
  inline void set_info_type(const char* value);
  inline void set_info_type(const char* value, size_t size);
  inline ::std::string* mutable_info_type();
  inline ::std::string* release_info_type();
  inline void set_allocated_info_type(::std::string* info_type);

  // repeated .qihoo.protocol.messages.Info infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::qihoo::protocol::messages::Info& infos(int index) const;
  inline ::qihoo::protocol::messages::Info* mutable_infos(int index);
  inline ::qihoo::protocol::messages::Info* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
      mutable_infos();

  // optional int64 last_info_id = 3;
  inline bool has_last_info_id() const;
  inline void clear_last_info_id();
  static const int kLastInfoIdFieldNumber = 3;
  inline ::google::protobuf::int64 last_info_id() const;
  inline void set_last_info_id(::google::protobuf::int64 value);

  // optional bytes s_parameter = 4;
  inline bool has_s_parameter() const;
  inline void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  inline const ::std::string& s_parameter() const;
  inline void set_s_parameter(const ::std::string& value);
  inline void set_s_parameter(const char* value);
  inline void set_s_parameter(const void* value, size_t size);
  inline ::std::string* mutable_s_parameter();
  inline ::std::string* release_s_parameter();
  inline void set_allocated_s_parameter(::std::string* s_parameter);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetInfoResp)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_last_info_id();
  inline void clear_has_last_info_id();
  inline void set_has_s_parameter();
  inline void clear_has_s_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_type_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info > infos_;
  ::google::protobuf::int64 last_info_id_;
  ::std::string* s_parameter_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static GetInfoResp* default_instance_;
};
// -------------------------------------------------------------------

class GetMultiInfosReq : public ::google::protobuf::Message {
 public:
  GetMultiInfosReq();
  virtual ~GetMultiInfosReq();

  GetMultiInfosReq(const GetMultiInfosReq& from);

  inline GetMultiInfosReq& operator=(const GetMultiInfosReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMultiInfosReq& default_instance();

  void Swap(GetMultiInfosReq* other);

  // implements Message ----------------------------------------------

  GetMultiInfosReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMultiInfosReq& from);
  void MergeFrom(const GetMultiInfosReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline const ::std::string& info_type() const;
  inline void set_info_type(const ::std::string& value);
  inline void set_info_type(const char* value);
  inline void set_info_type(const char* value, size_t size);
  inline ::std::string* mutable_info_type();
  inline ::std::string* release_info_type();
  inline void set_allocated_info_type(::std::string* info_type);

  // repeated int64 get_info_ids = 2;
  inline int get_info_ids_size() const;
  inline void clear_get_info_ids();
  static const int kGetInfoIdsFieldNumber = 2;
  inline ::google::protobuf::int64 get_info_ids(int index) const;
  inline void set_get_info_ids(int index, ::google::protobuf::int64 value);
  inline void add_get_info_ids(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      get_info_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_get_info_ids();

  // optional bytes s_parameter = 3;
  inline bool has_s_parameter() const;
  inline void clear_s_parameter();
  static const int kSParameterFieldNumber = 3;
  inline const ::std::string& s_parameter() const;
  inline void set_s_parameter(const ::std::string& value);
  inline void set_s_parameter(const char* value);
  inline void set_s_parameter(const void* value, size_t size);
  inline ::std::string* mutable_s_parameter();
  inline ::std::string* release_s_parameter();
  inline void set_allocated_s_parameter(::std::string* s_parameter);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetMultiInfosReq)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_s_parameter();
  inline void clear_has_s_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > get_info_ids_;
  ::std::string* s_parameter_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static GetMultiInfosReq* default_instance_;
};
// -------------------------------------------------------------------

class GetMultiInfosResp : public ::google::protobuf::Message {
 public:
  GetMultiInfosResp();
  virtual ~GetMultiInfosResp();

  GetMultiInfosResp(const GetMultiInfosResp& from);

  inline GetMultiInfosResp& operator=(const GetMultiInfosResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMultiInfosResp& default_instance();

  void Swap(GetMultiInfosResp* other);

  // implements Message ----------------------------------------------

  GetMultiInfosResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMultiInfosResp& from);
  void MergeFrom(const GetMultiInfosResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline const ::std::string& info_type() const;
  inline void set_info_type(const ::std::string& value);
  inline void set_info_type(const char* value);
  inline void set_info_type(const char* value, size_t size);
  inline ::std::string* mutable_info_type();
  inline ::std::string* release_info_type();
  inline void set_allocated_info_type(::std::string* info_type);

  // repeated .qihoo.protocol.messages.Info infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::qihoo::protocol::messages::Info& infos(int index) const;
  inline ::qihoo::protocol::messages::Info* mutable_infos(int index);
  inline ::qihoo::protocol::messages::Info* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
      mutable_infos();

  // optional int64 last_info_id = 3;
  inline bool has_last_info_id() const;
  inline void clear_last_info_id();
  static const int kLastInfoIdFieldNumber = 3;
  inline ::google::protobuf::int64 last_info_id() const;
  inline void set_last_info_id(::google::protobuf::int64 value);

  // optional bytes s_parameter = 4;
  inline bool has_s_parameter() const;
  inline void clear_s_parameter();
  static const int kSParameterFieldNumber = 4;
  inline const ::std::string& s_parameter() const;
  inline void set_s_parameter(const ::std::string& value);
  inline void set_s_parameter(const char* value);
  inline void set_s_parameter(const void* value, size_t size);
  inline ::std::string* mutable_s_parameter();
  inline ::std::string* release_s_parameter();
  inline void set_allocated_s_parameter(::std::string* s_parameter);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.GetMultiInfosResp)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_last_info_id();
  inline void clear_has_last_info_id();
  inline void set_has_s_parameter();
  inline void clear_has_s_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_type_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info > infos_;
  ::google::protobuf::int64 last_info_id_;
  ::std::string* s_parameter_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static GetMultiInfosResp* default_instance_;
};
// -------------------------------------------------------------------

class LogoutReq : public ::google::protobuf::Message {
 public:
  LogoutReq();
  virtual ~LogoutReq();

  LogoutReq(const LogoutReq& from);

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutReq& default_instance();

  void Swap(LogoutReq* other);

  // implements Message ----------------------------------------------

  LogoutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutReq& from);
  void MergeFrom(const LogoutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LogoutReq)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static LogoutReq* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResp : public ::google::protobuf::Message {
 public:
  LogoutResp();
  virtual ~LogoutResp();

  LogoutResp(const LogoutResp& from);

  inline LogoutResp& operator=(const LogoutResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResp& default_instance();

  void Swap(LogoutResp* other);

  // implements Message ----------------------------------------------

  LogoutResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResp& from);
  void MergeFrom(const LogoutResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.LogoutResp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static LogoutResp* default_instance_;
};
// -------------------------------------------------------------------

class InitLoginReq : public ::google::protobuf::Message {
 public:
  InitLoginReq();
  virtual ~InitLoginReq();

  InitLoginReq(const InitLoginReq& from);

  inline InitLoginReq& operator=(const InitLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitLoginReq& default_instance();

  void Swap(InitLoginReq* other);

  // implements Message ----------------------------------------------

  InitLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitLoginReq& from);
  void MergeFrom(const InitLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_ram = 1;
  inline bool has_client_ram() const;
  inline void clear_client_ram();
  static const int kClientRamFieldNumber = 1;
  inline const ::std::string& client_ram() const;
  inline void set_client_ram(const ::std::string& value);
  inline void set_client_ram(const char* value);
  inline void set_client_ram(const char* value, size_t size);
  inline ::std::string* mutable_client_ram();
  inline ::std::string* release_client_ram();
  inline void set_allocated_client_ram(::std::string* client_ram);

  // optional string sig = 2;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 2;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const char* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.InitLoginReq)
 private:
  inline void set_has_client_ram();
  inline void clear_has_client_ram();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_ram_;
  ::std::string* sig_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static InitLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class InitLoginResp : public ::google::protobuf::Message {
 public:
  InitLoginResp();
  virtual ~InitLoginResp();

  InitLoginResp(const InitLoginResp& from);

  inline InitLoginResp& operator=(const InitLoginResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitLoginResp& default_instance();

  void Swap(InitLoginResp* other);

  // implements Message ----------------------------------------------

  InitLoginResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitLoginResp& from);
  void MergeFrom(const InitLoginResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_ram = 1;
  inline bool has_client_ram() const;
  inline void clear_client_ram();
  static const int kClientRamFieldNumber = 1;
  inline const ::std::string& client_ram() const;
  inline void set_client_ram(const ::std::string& value);
  inline void set_client_ram(const char* value);
  inline void set_client_ram(const char* value, size_t size);
  inline ::std::string* mutable_client_ram();
  inline ::std::string* release_client_ram();
  inline void set_allocated_client_ram(::std::string* client_ram);

  // required string server_ram = 2;
  inline bool has_server_ram() const;
  inline void clear_server_ram();
  static const int kServerRamFieldNumber = 2;
  inline const ::std::string& server_ram() const;
  inline void set_server_ram(const ::std::string& value);
  inline void set_server_ram(const char* value);
  inline void set_server_ram(const char* value, size_t size);
  inline ::std::string* mutable_server_ram();
  inline ::std::string* release_server_ram();
  inline void set_allocated_server_ram(::std::string* server_ram);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.InitLoginResp)
 private:
  inline void set_has_client_ram();
  inline void clear_has_client_ram();
  inline void set_has_server_ram();
  inline void clear_has_server_ram();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_ram_;
  ::std::string* server_ram_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static InitLoginResp* default_instance_;
};
// -------------------------------------------------------------------

class Service_Req : public ::google::protobuf::Message {
 public:
  Service_Req();
  virtual ~Service_Req();

  Service_Req(const Service_Req& from);

  inline Service_Req& operator=(const Service_Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service_Req& default_instance();

  void Swap(Service_Req* other);

  // implements Message ----------------------------------------------

  Service_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service_Req& from);
  void MergeFrom(const Service_Req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 service_id() const;
  inline void set_service_id(::google::protobuf::uint32 value);

  // required bytes request = 2;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 2;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const void* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  inline void set_allocated_request(::std::string* request);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Service_Req)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_request();
  inline void clear_has_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* request_;
  ::google::protobuf::uint32 service_id_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Service_Req* default_instance_;
};
// -------------------------------------------------------------------

class Service_Resp : public ::google::protobuf::Message {
 public:
  Service_Resp();
  virtual ~Service_Resp();

  Service_Resp(const Service_Resp& from);

  inline Service_Resp& operator=(const Service_Resp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service_Resp& default_instance();

  void Swap(Service_Resp* other);

  // implements Message ----------------------------------------------

  Service_Resp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service_Resp& from);
  void MergeFrom(const Service_Resp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 service_id() const;
  inline void set_service_id(::google::protobuf::uint32 value);

  // required bytes response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  inline ::std::string* release_response();
  inline void set_allocated_response(::std::string* response);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Service_Resp)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* response_;
  ::google::protobuf::uint32 service_id_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Service_Resp* default_instance_;
};
// -------------------------------------------------------------------

class ReqEQ1User : public ::google::protobuf::Message {
 public:
  ReqEQ1User();
  virtual ~ReqEQ1User();

  ReqEQ1User(const ReqEQ1User& from);

  inline ReqEQ1User& operator=(const ReqEQ1User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEQ1User& default_instance();

  void Swap(ReqEQ1User* other);

  // implements Message ----------------------------------------------

  ReqEQ1User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEQ1User& from);
  void MergeFrom(const ReqEQ1User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string user_type = 2;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  inline const ::std::string& user_type() const;
  inline void set_user_type(const ::std::string& value);
  inline void set_user_type(const char* value);
  inline void set_user_type(const char* value, size_t size);
  inline ::std::string* mutable_user_type();
  inline ::std::string* release_user_type();
  inline void set_allocated_user_type(::std::string* user_type);

  // optional uint32 app_id = 3;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReqEQ1User)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* user_type_;
  ::google::protobuf::uint32 app_id_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static ReqEQ1User* default_instance_;
};
// -------------------------------------------------------------------

class RespEQ1User : public ::google::protobuf::Message {
 public:
  RespEQ1User();
  virtual ~RespEQ1User();

  RespEQ1User(const RespEQ1User& from);

  inline RespEQ1User& operator=(const RespEQ1User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespEQ1User& default_instance();

  void Swap(RespEQ1User* other);

  // implements Message ----------------------------------------------

  RespEQ1User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespEQ1User& from);
  void MergeFrom(const RespEQ1User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string user_type = 2;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  inline const ::std::string& user_type() const;
  inline void set_user_type(const ::std::string& value);
  inline void set_user_type(const char* value);
  inline void set_user_type(const char* value, size_t size);
  inline ::std::string* mutable_user_type();
  inline ::std::string* release_user_type();
  inline void set_allocated_user_type(::std::string* user_type);

  // required int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string jid = 4;
  inline bool has_jid() const;
  inline void clear_jid();
  static const int kJidFieldNumber = 4;
  inline const ::std::string& jid() const;
  inline void set_jid(const ::std::string& value);
  inline void set_jid(const char* value);
  inline void set_jid(const char* value, size_t size);
  inline ::std::string* mutable_jid();
  inline ::std::string* release_jid();
  inline void set_allocated_jid(::std::string* jid);

  // optional uint32 app_id = 5;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 5;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional string platform = 6;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 6;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string mobile_type = 7;
  inline bool has_mobile_type() const;
  inline void clear_mobile_type();
  static const int kMobileTypeFieldNumber = 7;
  inline const ::std::string& mobile_type() const;
  inline void set_mobile_type(const ::std::string& value);
  inline void set_mobile_type(const char* value);
  inline void set_mobile_type(const char* value, size_t size);
  inline ::std::string* mutable_mobile_type();
  inline ::std::string* release_mobile_type();
  inline void set_allocated_mobile_type(::std::string* mobile_type);

  // optional uint32 client_ver = 8;
  inline bool has_client_ver() const;
  inline void clear_client_ver();
  static const int kClientVerFieldNumber = 8;
  inline ::google::protobuf::uint32 client_ver() const;
  inline void set_client_ver(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.RespEQ1User)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_jid();
  inline void clear_has_jid();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_mobile_type();
  inline void clear_has_mobile_type();
  inline void set_has_client_ver();
  inline void clear_has_client_ver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* user_type_;
  ::std::string* jid_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint32 app_id_;
  ::std::string* platform_;
  ::std::string* mobile_type_;
  ::google::protobuf::uint32 client_ver_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static RespEQ1User* default_instance_;
};
// -------------------------------------------------------------------

class Ex1QueryUserStatusReq : public ::google::protobuf::Message {
 public:
  Ex1QueryUserStatusReq();
  virtual ~Ex1QueryUserStatusReq();

  Ex1QueryUserStatusReq(const Ex1QueryUserStatusReq& from);

  inline Ex1QueryUserStatusReq& operator=(const Ex1QueryUserStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ex1QueryUserStatusReq& default_instance();

  void Swap(Ex1QueryUserStatusReq* other);

  // implements Message ----------------------------------------------

  Ex1QueryUserStatusReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ex1QueryUserStatusReq& from);
  void MergeFrom(const Ex1QueryUserStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.ReqEQ1User user_list = 1;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 1;
  inline const ::qihoo::protocol::messages::ReqEQ1User& user_list(int index) const;
  inline ::qihoo::protocol::messages::ReqEQ1User* mutable_user_list(int index);
  inline ::qihoo::protocol::messages::ReqEQ1User* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >*
      mutable_user_list();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ex1QueryUserStatusReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User > user_list_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Ex1QueryUserStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class Ex1QueryUserStatusResp : public ::google::protobuf::Message {
 public:
  Ex1QueryUserStatusResp();
  virtual ~Ex1QueryUserStatusResp();

  Ex1QueryUserStatusResp(const Ex1QueryUserStatusResp& from);

  inline Ex1QueryUserStatusResp& operator=(const Ex1QueryUserStatusResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ex1QueryUserStatusResp& default_instance();

  void Swap(Ex1QueryUserStatusResp* other);

  // implements Message ----------------------------------------------

  Ex1QueryUserStatusResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ex1QueryUserStatusResp& from);
  void MergeFrom(const Ex1QueryUserStatusResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .qihoo.protocol.messages.RespEQ1User user_list = 1;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 1;
  inline const ::qihoo::protocol::messages::RespEQ1User& user_list(int index) const;
  inline ::qihoo::protocol::messages::RespEQ1User* mutable_user_list(int index);
  inline ::qihoo::protocol::messages::RespEQ1User* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >*
      mutable_user_list();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ex1QueryUserStatusResp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User > user_list_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Ex1QueryUserStatusResp* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.LoginReq login = 2;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 2;
  inline const ::qihoo::protocol::messages::LoginReq& login() const;
  inline ::qihoo::protocol::messages::LoginReq* mutable_login();
  inline ::qihoo::protocol::messages::LoginReq* release_login();
  inline void set_allocated_login(::qihoo::protocol::messages::LoginReq* login);

  // optional .qihoo.protocol.messages.ChatReq chat = 3;
  inline bool has_chat() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 3;
  inline const ::qihoo::protocol::messages::ChatReq& chat() const;
  inline ::qihoo::protocol::messages::ChatReq* mutable_chat();
  inline ::qihoo::protocol::messages::ChatReq* release_chat();
  inline void set_allocated_chat(::qihoo::protocol::messages::ChatReq* chat);

  // optional .qihoo.protocol.messages.GetInfoReq get_info = 5;
  inline bool has_get_info() const;
  inline void clear_get_info();
  static const int kGetInfoFieldNumber = 5;
  inline const ::qihoo::protocol::messages::GetInfoReq& get_info() const;
  inline ::qihoo::protocol::messages::GetInfoReq* mutable_get_info();
  inline ::qihoo::protocol::messages::GetInfoReq* release_get_info();
  inline void set_allocated_get_info(::qihoo::protocol::messages::GetInfoReq* get_info);

  // optional .qihoo.protocol.messages.LogoutReq logout = 6;
  inline bool has_logout() const;
  inline void clear_logout();
  static const int kLogoutFieldNumber = 6;
  inline const ::qihoo::protocol::messages::LogoutReq& logout() const;
  inline ::qihoo::protocol::messages::LogoutReq* mutable_logout();
  inline ::qihoo::protocol::messages::LogoutReq* release_logout();
  inline void set_allocated_logout(::qihoo::protocol::messages::LogoutReq* logout);

  // optional .qihoo.protocol.messages.InitLoginReq init_login_req = 9;
  inline bool has_init_login_req() const;
  inline void clear_init_login_req();
  static const int kInitLoginReqFieldNumber = 9;
  inline const ::qihoo::protocol::messages::InitLoginReq& init_login_req() const;
  inline ::qihoo::protocol::messages::InitLoginReq* mutable_init_login_req();
  inline ::qihoo::protocol::messages::InitLoginReq* release_init_login_req();
  inline void set_allocated_init_login_req(::qihoo::protocol::messages::InitLoginReq* init_login_req);

  // optional .qihoo.protocol.messages.Service_Req service_req = 11;
  inline bool has_service_req() const;
  inline void clear_service_req();
  static const int kServiceReqFieldNumber = 11;
  inline const ::qihoo::protocol::messages::Service_Req& service_req() const;
  inline ::qihoo::protocol::messages::Service_Req* mutable_service_req();
  inline ::qihoo::protocol::messages::Service_Req* release_service_req();
  inline void set_allocated_service_req(::qihoo::protocol::messages::Service_Req* service_req);

  // optional .qihoo.protocol.messages.Ex1QueryUserStatusReq e1_query_user = 12;
  inline bool has_e1_query_user() const;
  inline void clear_e1_query_user();
  static const int kE1QueryUserFieldNumber = 12;
  inline const ::qihoo::protocol::messages::Ex1QueryUserStatusReq& e1_query_user() const;
  inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* mutable_e1_query_user();
  inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* release_e1_query_user();
  inline void set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user);

  // optional .qihoo.protocol.messages.GetMultiInfosReq get_multi_infos = 100;
  inline bool has_get_multi_infos() const;
  inline void clear_get_multi_infos();
  static const int kGetMultiInfosFieldNumber = 100;
  inline const ::qihoo::protocol::messages::GetMultiInfosReq& get_multi_infos() const;
  inline ::qihoo::protocol::messages::GetMultiInfosReq* mutable_get_multi_infos();
  inline ::qihoo::protocol::messages::GetMultiInfosReq* release_get_multi_infos();
  inline void set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Request)
 private:
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_chat();
  inline void clear_has_chat();
  inline void set_has_get_info();
  inline void clear_has_get_info();
  inline void set_has_logout();
  inline void clear_has_logout();
  inline void set_has_init_login_req();
  inline void clear_has_init_login_req();
  inline void set_has_service_req();
  inline void clear_has_service_req();
  inline void set_has_e1_query_user();
  inline void clear_has_e1_query_user();
  inline void set_has_get_multi_infos();
  inline void clear_has_get_multi_infos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::messages::LoginReq* login_;
  ::qihoo::protocol::messages::ChatReq* chat_;
  ::qihoo::protocol::messages::GetInfoReq* get_info_;
  ::qihoo::protocol::messages::LogoutReq* logout_;
  ::qihoo::protocol::messages::InitLoginReq* init_login_req_;
  ::qihoo::protocol::messages::Service_Req* service_req_;
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user_;
  ::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.Error error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::qihoo::protocol::messages::Error& error() const;
  inline ::qihoo::protocol::messages::Error* mutable_error();
  inline ::qihoo::protocol::messages::Error* release_error();
  inline void set_allocated_error(::qihoo::protocol::messages::Error* error);

  // optional .qihoo.protocol.messages.LoginResp login = 3;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 3;
  inline const ::qihoo::protocol::messages::LoginResp& login() const;
  inline ::qihoo::protocol::messages::LoginResp* mutable_login();
  inline ::qihoo::protocol::messages::LoginResp* release_login();
  inline void set_allocated_login(::qihoo::protocol::messages::LoginResp* login);

  // optional .qihoo.protocol.messages.ChatResp chat = 4;
  inline bool has_chat() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 4;
  inline const ::qihoo::protocol::messages::ChatResp& chat() const;
  inline ::qihoo::protocol::messages::ChatResp* mutable_chat();
  inline ::qihoo::protocol::messages::ChatResp* release_chat();
  inline void set_allocated_chat(::qihoo::protocol::messages::ChatResp* chat);

  // optional .qihoo.protocol.messages.GetInfoResp get_info = 6;
  inline bool has_get_info() const;
  inline void clear_get_info();
  static const int kGetInfoFieldNumber = 6;
  inline const ::qihoo::protocol::messages::GetInfoResp& get_info() const;
  inline ::qihoo::protocol::messages::GetInfoResp* mutable_get_info();
  inline ::qihoo::protocol::messages::GetInfoResp* release_get_info();
  inline void set_allocated_get_info(::qihoo::protocol::messages::GetInfoResp* get_info);

  // optional .qihoo.protocol.messages.LogoutResp logout = 7;
  inline bool has_logout() const;
  inline void clear_logout();
  static const int kLogoutFieldNumber = 7;
  inline const ::qihoo::protocol::messages::LogoutResp& logout() const;
  inline ::qihoo::protocol::messages::LogoutResp* mutable_logout();
  inline ::qihoo::protocol::messages::LogoutResp* release_logout();
  inline void set_allocated_logout(::qihoo::protocol::messages::LogoutResp* logout);

  // optional .qihoo.protocol.messages.InitLoginResp init_login_resp = 10;
  inline bool has_init_login_resp() const;
  inline void clear_init_login_resp();
  static const int kInitLoginRespFieldNumber = 10;
  inline const ::qihoo::protocol::messages::InitLoginResp& init_login_resp() const;
  inline ::qihoo::protocol::messages::InitLoginResp* mutable_init_login_resp();
  inline ::qihoo::protocol::messages::InitLoginResp* release_init_login_resp();
  inline void set_allocated_init_login_resp(::qihoo::protocol::messages::InitLoginResp* init_login_resp);

  // optional .qihoo.protocol.messages.Service_Resp service_resp = 12;
  inline bool has_service_resp() const;
  inline void clear_service_resp();
  static const int kServiceRespFieldNumber = 12;
  inline const ::qihoo::protocol::messages::Service_Resp& service_resp() const;
  inline ::qihoo::protocol::messages::Service_Resp* mutable_service_resp();
  inline ::qihoo::protocol::messages::Service_Resp* release_service_resp();
  inline void set_allocated_service_resp(::qihoo::protocol::messages::Service_Resp* service_resp);

  // optional .qihoo.protocol.messages.Ex1QueryUserStatusResp e1_query_user = 13;
  inline bool has_e1_query_user() const;
  inline void clear_e1_query_user();
  static const int kE1QueryUserFieldNumber = 13;
  inline const ::qihoo::protocol::messages::Ex1QueryUserStatusResp& e1_query_user() const;
  inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* mutable_e1_query_user();
  inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* release_e1_query_user();
  inline void set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user);

  // optional .qihoo.protocol.messages.GetMultiInfosResp get_multi_infos = 100;
  inline bool has_get_multi_infos() const;
  inline void clear_get_multi_infos();
  static const int kGetMultiInfosFieldNumber = 100;
  inline const ::qihoo::protocol::messages::GetMultiInfosResp& get_multi_infos() const;
  inline ::qihoo::protocol::messages::GetMultiInfosResp* mutable_get_multi_infos();
  inline ::qihoo::protocol::messages::GetMultiInfosResp* release_get_multi_infos();
  inline void set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Response)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_chat();
  inline void clear_has_chat();
  inline void set_has_get_info();
  inline void clear_has_get_info();
  inline void set_has_logout();
  inline void clear_has_logout();
  inline void set_has_init_login_resp();
  inline void clear_has_init_login_resp();
  inline void set_has_service_resp();
  inline void clear_has_service_resp();
  inline void set_has_e1_query_user();
  inline void clear_has_e1_query_user();
  inline void set_has_get_multi_infos();
  inline void clear_has_get_multi_infos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::messages::Error* error_;
  ::qihoo::protocol::messages::LoginResp* login_;
  ::qihoo::protocol::messages::ChatResp* chat_;
  ::qihoo::protocol::messages::GetInfoResp* get_info_;
  ::qihoo::protocol::messages::LogoutResp* logout_;
  ::qihoo::protocol::messages::InitLoginResp* init_login_resp_;
  ::qihoo::protocol::messages::Service_Resp* service_resp_;
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user_;
  ::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class NewMessageNotify : public ::google::protobuf::Message {
 public:
  NewMessageNotify();
  virtual ~NewMessageNotify();

  NewMessageNotify(const NewMessageNotify& from);

  inline NewMessageNotify& operator=(const NewMessageNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewMessageNotify& default_instance();

  void Swap(NewMessageNotify* other);

  // implements Message ----------------------------------------------

  NewMessageNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewMessageNotify& from);
  void MergeFrom(const NewMessageNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline const ::std::string& info_type() const;
  inline void set_info_type(const ::std::string& value);
  inline void set_info_type(const char* value);
  inline void set_info_type(const char* value, size_t size);
  inline ::std::string* mutable_info_type();
  inline ::std::string* release_info_type();
  inline void set_allocated_info_type(::std::string* info_type);

  // optional bytes info_content = 2;
  inline bool has_info_content() const;
  inline void clear_info_content();
  static const int kInfoContentFieldNumber = 2;
  inline const ::std::string& info_content() const;
  inline void set_info_content(const ::std::string& value);
  inline void set_info_content(const char* value);
  inline void set_info_content(const void* value, size_t size);
  inline ::std::string* mutable_info_content();
  inline ::std::string* release_info_content();
  inline void set_allocated_info_content(::std::string* info_content);

  // optional int64 info_id = 3;
  inline bool has_info_id() const;
  inline void clear_info_id();
  static const int kInfoIdFieldNumber = 3;
  inline ::google::protobuf::int64 info_id() const;
  inline void set_info_id(::google::protobuf::int64 value);

  // optional uint32 query_after_seconds = 4;
  inline bool has_query_after_seconds() const;
  inline void clear_query_after_seconds();
  static const int kQueryAfterSecondsFieldNumber = 4;
  inline ::google::protobuf::uint32 query_after_seconds() const;
  inline void set_query_after_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.NewMessageNotify)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_info_content();
  inline void clear_has_info_content();
  inline void set_has_info_id();
  inline void clear_has_info_id();
  inline void set_has_query_after_seconds();
  inline void clear_has_query_after_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_type_;
  ::std::string* info_content_;
  ::google::protobuf::int64 info_id_;
  ::google::protobuf::uint32 query_after_seconds_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static NewMessageNotify* default_instance_;
};
// -------------------------------------------------------------------

class ReLoginNotify : public ::google::protobuf::Message {
 public:
  ReLoginNotify();
  virtual ~ReLoginNotify();

  ReLoginNotify(const ReLoginNotify& from);

  inline ReLoginNotify& operator=(const ReLoginNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReLoginNotify& default_instance();

  void Swap(ReLoginNotify* other);

  // implements Message ----------------------------------------------

  ReLoginNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReLoginNotify& from);
  void MergeFrom(const ReLoginNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string new_ip = 1;
  inline bool has_new_ip() const;
  inline void clear_new_ip();
  static const int kNewIpFieldNumber = 1;
  inline const ::std::string& new_ip() const;
  inline void set_new_ip(const ::std::string& value);
  inline void set_new_ip(const char* value);
  inline void set_new_ip(const char* value, size_t size);
  inline ::std::string* mutable_new_ip();
  inline ::std::string* release_new_ip();
  inline void set_allocated_new_ip(::std::string* new_ip);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReLoginNotify)
 private:
  inline void set_has_new_ip();
  inline void clear_has_new_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* new_ip_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static ReLoginNotify* default_instance_;
};
// -------------------------------------------------------------------

class ReConnectNotify : public ::google::protobuf::Message {
 public:
  ReConnectNotify();
  virtual ~ReConnectNotify();

  ReConnectNotify(const ReConnectNotify& from);

  inline ReConnectNotify& operator=(const ReConnectNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReConnectNotify& default_instance();

  void Swap(ReConnectNotify* other);

  // implements Message ----------------------------------------------

  ReConnectNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReConnectNotify& from);
  void MergeFrom(const ReConnectNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // repeated string more_ips = 3;
  inline int more_ips_size() const;
  inline void clear_more_ips();
  static const int kMoreIpsFieldNumber = 3;
  inline const ::std::string& more_ips(int index) const;
  inline ::std::string* mutable_more_ips(int index);
  inline void set_more_ips(int index, const ::std::string& value);
  inline void set_more_ips(int index, const char* value);
  inline void set_more_ips(int index, const char* value, size_t size);
  inline ::std::string* add_more_ips();
  inline void add_more_ips(const ::std::string& value);
  inline void add_more_ips(const char* value);
  inline void add_more_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& more_ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_more_ips();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.ReConnectNotify)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::RepeatedPtrField< ::std::string> more_ips_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static ReConnectNotify* default_instance_;
};
// -------------------------------------------------------------------

class Notify : public ::google::protobuf::Message {
 public:
  Notify();
  virtual ~Notify();

  Notify(const Notify& from);

  inline Notify& operator=(const Notify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notify& default_instance();

  void Swap(Notify* other);

  // implements Message ----------------------------------------------

  Notify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Notify& from);
  void MergeFrom(const Notify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qihoo.protocol.messages.NewMessageNotify newinfo_ntf = 1;
  inline bool has_newinfo_ntf() const;
  inline void clear_newinfo_ntf();
  static const int kNewinfoNtfFieldNumber = 1;
  inline const ::qihoo::protocol::messages::NewMessageNotify& newinfo_ntf() const;
  inline ::qihoo::protocol::messages::NewMessageNotify* mutable_newinfo_ntf();
  inline ::qihoo::protocol::messages::NewMessageNotify* release_newinfo_ntf();
  inline void set_allocated_newinfo_ntf(::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf);

  // optional .qihoo.protocol.messages.ReLoginNotify relogin_ntf = 2;
  inline bool has_relogin_ntf() const;
  inline void clear_relogin_ntf();
  static const int kReloginNtfFieldNumber = 2;
  inline const ::qihoo::protocol::messages::ReLoginNotify& relogin_ntf() const;
  inline ::qihoo::protocol::messages::ReLoginNotify* mutable_relogin_ntf();
  inline ::qihoo::protocol::messages::ReLoginNotify* release_relogin_ntf();
  inline void set_allocated_relogin_ntf(::qihoo::protocol::messages::ReLoginNotify* relogin_ntf);

  // optional .qihoo.protocol.messages.ReConnectNotify reconnect_ntf = 3;
  inline bool has_reconnect_ntf() const;
  inline void clear_reconnect_ntf();
  static const int kReconnectNtfFieldNumber = 3;
  inline const ::qihoo::protocol::messages::ReConnectNotify& reconnect_ntf() const;
  inline ::qihoo::protocol::messages::ReConnectNotify* mutable_reconnect_ntf();
  inline ::qihoo::protocol::messages::ReConnectNotify* release_reconnect_ntf();
  inline void set_allocated_reconnect_ntf(::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Notify)
 private:
  inline void set_has_newinfo_ntf();
  inline void clear_has_newinfo_ntf();
  inline void set_has_relogin_ntf();
  inline void clear_has_relogin_ntf();
  inline void set_has_reconnect_ntf();
  inline void clear_has_reconnect_ntf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf_;
  ::qihoo::protocol::messages::ReLoginNotify* relogin_ntf_;
  ::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Notify* default_instance_;
};
// -------------------------------------------------------------------

class Ack : public ::google::protobuf::Message {
 public:
  Ack();
  virtual ~Ack();

  Ack(const Ack& from);

  inline Ack& operator=(const Ack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ack& default_instance();

  void Swap(Ack* other);

  // implements Message ----------------------------------------------

  Ack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ack& from);
  void MergeFrom(const Ack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Ack)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 result_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Ack* default_instance_;
};
// -------------------------------------------------------------------

class RouteInfo : public ::google::protobuf::Message {
 public:
  RouteInfo();
  virtual ~RouteInfo();

  RouteInfo(const RouteInfo& from);

  inline RouteInfo& operator=(const RouteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteInfo& default_instance();

  void Swap(RouteInfo* other);

  // implements Message ----------------------------------------------

  RouteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteInfo& from);
  void MergeFrom(const RouteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string msg_exchanger = 2;
  inline bool has_msg_exchanger() const;
  inline void clear_msg_exchanger();
  static const int kMsgExchangerFieldNumber = 2;
  inline const ::std::string& msg_exchanger() const;
  inline void set_msg_exchanger(const ::std::string& value);
  inline void set_msg_exchanger(const char* value);
  inline void set_msg_exchanger(const char* value, size_t size);
  inline ::std::string* mutable_msg_exchanger();
  inline ::std::string* release_msg_exchanger();
  inline void set_allocated_msg_exchanger(::std::string* msg_exchanger);

  // required string msg_router = 3;
  inline bool has_msg_router() const;
  inline void clear_msg_router();
  static const int kMsgRouterFieldNumber = 3;
  inline const ::std::string& msg_router() const;
  inline void set_msg_router(const ::std::string& value);
  inline void set_msg_router(const char* value);
  inline void set_msg_router(const char* value, size_t size);
  inline ::std::string* mutable_msg_router();
  inline ::std::string* release_msg_router();
  inline void set_allocated_msg_router(::std::string* msg_router);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.RouteInfo)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_msg_exchanger();
  inline void clear_has_msg_exchanger();
  inline void set_has_msg_router();
  inline void clear_has_msg_router();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* username_;
  ::std::string* msg_exchanger_;
  ::std::string* msg_router_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static RouteInfo* default_instance_;
};
// -------------------------------------------------------------------

class Proxy : public ::google::protobuf::Message {
 public:
  Proxy();
  virtual ~Proxy();

  Proxy(const Proxy& from);

  inline Proxy& operator=(const Proxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Proxy& default_instance();

  void Swap(Proxy* other);

  // implements Message ----------------------------------------------

  Proxy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Proxy& from);
  void MergeFrom(const Proxy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // repeated .qihoo.protocol.messages.RouteInfo receiver = 2;
  inline int receiver_size() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  inline const ::qihoo::protocol::messages::RouteInfo& receiver(int index) const;
  inline ::qihoo::protocol::messages::RouteInfo* mutable_receiver(int index);
  inline ::qihoo::protocol::messages::RouteInfo* add_receiver();
  inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >&
      receiver() const;
  inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >*
      mutable_receiver();

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Proxy)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sender_;
  ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo > receiver_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Proxy* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msgid = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline ::google::protobuf::uint32 msgid() const;
  inline void set_msgid(::google::protobuf::uint32 value);

  // required uint64 sn = 2;
  inline bool has_sn() const;
  inline void clear_sn();
  static const int kSnFieldNumber = 2;
  inline ::google::protobuf::uint64 sn() const;
  inline void set_sn(::google::protobuf::uint64 value);

  // optional string sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string receiver = 4;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 4;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional string receiver_type = 5;
  inline bool has_receiver_type() const;
  inline void clear_receiver_type();
  static const int kReceiverTypeFieldNumber = 5;
  inline const ::std::string& receiver_type() const;
  inline void set_receiver_type(const ::std::string& value);
  inline void set_receiver_type(const char* value);
  inline void set_receiver_type(const char* value, size_t size);
  inline ::std::string* mutable_receiver_type();
  inline ::std::string* release_receiver_type();
  inline void set_allocated_receiver_type(::std::string* receiver_type);

  // optional .qihoo.protocol.messages.Request req = 6;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 6;
  inline const ::qihoo::protocol::messages::Request& req() const;
  inline ::qihoo::protocol::messages::Request* mutable_req();
  inline ::qihoo::protocol::messages::Request* release_req();
  inline void set_allocated_req(::qihoo::protocol::messages::Request* req);

  // optional .qihoo.protocol.messages.Response resp = 7;
  inline bool has_resp() const;
  inline void clear_resp();
  static const int kRespFieldNumber = 7;
  inline const ::qihoo::protocol::messages::Response& resp() const;
  inline ::qihoo::protocol::messages::Response* mutable_resp();
  inline ::qihoo::protocol::messages::Response* release_resp();
  inline void set_allocated_resp(::qihoo::protocol::messages::Response* resp);

  // optional .qihoo.protocol.messages.Notify notify = 8;
  inline bool has_notify() const;
  inline void clear_notify();
  static const int kNotifyFieldNumber = 8;
  inline const ::qihoo::protocol::messages::Notify& notify() const;
  inline ::qihoo::protocol::messages::Notify* mutable_notify();
  inline ::qihoo::protocol::messages::Notify* release_notify();
  inline void set_allocated_notify(::qihoo::protocol::messages::Notify* notify);

  // optional .qihoo.protocol.messages.Ack ack = 9;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 9;
  inline const ::qihoo::protocol::messages::Ack& ack() const;
  inline ::qihoo::protocol::messages::Ack* mutable_ack();
  inline ::qihoo::protocol::messages::Ack* release_ack();
  inline void set_allocated_ack(::qihoo::protocol::messages::Ack* ack);

  // optional .qihoo.protocol.messages.Proxy proxy_mesg = 10;
  inline bool has_proxy_mesg() const;
  inline void clear_proxy_mesg();
  static const int kProxyMesgFieldNumber = 10;
  inline const ::qihoo::protocol::messages::Proxy& proxy_mesg() const;
  inline ::qihoo::protocol::messages::Proxy* mutable_proxy_mesg();
  inline ::qihoo::protocol::messages::Proxy* release_proxy_mesg();
  inline void set_allocated_proxy_mesg(::qihoo::protocol::messages::Proxy* proxy_mesg);

  // optional uint64 client_data = 11;
  inline bool has_client_data() const;
  inline void clear_client_data();
  static const int kClientDataFieldNumber = 11;
  inline ::google::protobuf::uint64 client_data() const;
  inline void set_client_data(::google::protobuf::uint64 value);

  // optional string sender_type = 12;
  inline bool has_sender_type() const;
  inline void clear_sender_type();
  static const int kSenderTypeFieldNumber = 12;
  inline const ::std::string& sender_type() const;
  inline void set_sender_type(const ::std::string& value);
  inline void set_sender_type(const char* value);
  inline void set_sender_type(const char* value, size_t size);
  inline ::std::string* mutable_sender_type();
  inline ::std::string* release_sender_type();
  inline void set_allocated_sender_type(::std::string* sender_type);

  // optional string sender_jid = 13;
  inline bool has_sender_jid() const;
  inline void clear_sender_jid();
  static const int kSenderJidFieldNumber = 13;
  inline const ::std::string& sender_jid() const;
  inline void set_sender_jid(const ::std::string& value);
  inline void set_sender_jid(const char* value);
  inline void set_sender_jid(const char* value, size_t size);
  inline ::std::string* mutable_sender_jid();
  inline ::std::string* release_sender_jid();
  inline void set_allocated_sender_jid(::std::string* sender_jid);

  // @@protoc_insertion_point(class_scope:qihoo.protocol.messages.Message)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_receiver_type();
  inline void clear_has_receiver_type();
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_resp();
  inline void clear_has_resp();
  inline void set_has_notify();
  inline void clear_has_notify();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_proxy_mesg();
  inline void clear_has_proxy_mesg();
  inline void set_has_client_data();
  inline void clear_has_client_data();
  inline void set_has_sender_type();
  inline void clear_has_sender_type();
  inline void set_has_sender_jid();
  inline void clear_has_sender_jid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sn_;
  ::std::string* sender_;
  ::std::string* receiver_;
  ::std::string* receiver_type_;
  ::qihoo::protocol::messages::Request* req_;
  ::qihoo::protocol::messages::Response* resp_;
  ::qihoo::protocol::messages::Notify* notify_;
  ::qihoo::protocol::messages::Ack* ack_;
  ::qihoo::protocol::messages::Proxy* proxy_mesg_;
  ::google::protobuf::uint64 client_data_;
  ::std::string* sender_type_;
  ::std::string* sender_jid_;
  ::google::protobuf::uint32 msgid_;
  friend void  protobuf_AddDesc_address_5fbook_2eproto();
  friend void protobuf_AssignDesc_address_5fbook_2eproto();
  friend void protobuf_ShutdownFile_address_5fbook_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Pair

// required bytes key = 1;
inline bool Pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pair::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Pair::key() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Pair.key)
  return *key_;
}
inline void Pair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Pair.key)
}
inline void Pair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Pair.key)
}
inline void Pair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Pair.key)
}
inline ::std::string* Pair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Pair.key)
  return key_;
}
inline ::std::string* Pair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Pair.key)
}

// optional bytes value = 2;
inline bool Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pair::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Pair::value() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Pair.value)
  return *value_;
}
inline void Pair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Pair.value)
}
inline void Pair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Pair.value)
}
inline void Pair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Pair.value)
}
inline ::std::string* Pair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Pair.value)
  return value_;
}
inline ::std::string* Pair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Pair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Pair.value)
}

// -------------------------------------------------------------------

// Error

// required uint32 id = 1;
inline bool Error::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Error::id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Error.id)
  return id_;
}
inline void Error::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Error.id)
}

// optional bytes description = 2;
inline bool Error::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Error::description() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Error.description)
  return *description_;
}
inline void Error::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Error.description)
}
inline void Error::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Error.description)
}
inline void Error::set_description(const void* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Error.description)
}
inline ::std::string* Error::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Error.description)
  return description_;
}
inline ::std::string* Error::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Error::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Error.description)
}

// -------------------------------------------------------------------

// User

// required string userid = 1;
inline bool User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.User.userid)
  return *userid_;
}
inline void User::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.User.userid)
}
inline void User::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.User.userid)
}
inline void User::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.User.userid)
}
inline ::std::string* User::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.User.userid)
  return userid_;
}
inline ::std::string* User::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void User::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.User.userid)
}

// repeated .qihoo.protocol.messages.Pair property_pairs = 2;
inline int User::property_pairs_size() const {
  return property_pairs_.size();
}
inline void User::clear_property_pairs() {
  property_pairs_.Clear();
}
inline const ::qihoo::protocol::messages::Pair& User::property_pairs(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Get(index);
}
inline ::qihoo::protocol::messages::Pair* User::mutable_property_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Mutable(index);
}
inline ::qihoo::protocol::messages::Pair* User::add_property_pairs() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
User::property_pairs() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.User.property_pairs)
  return property_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
User::mutable_property_pairs() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.User.property_pairs)
  return &property_pairs_;
}

// -------------------------------------------------------------------

// Info

// repeated .qihoo.protocol.messages.Pair property_pairs = 1;
inline int Info::property_pairs_size() const {
  return property_pairs_.size();
}
inline void Info::clear_property_pairs() {
  property_pairs_.Clear();
}
inline const ::qihoo::protocol::messages::Pair& Info::property_pairs(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Get(index);
}
inline ::qihoo::protocol::messages::Pair* Info::mutable_property_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Mutable(index);
}
inline ::qihoo::protocol::messages::Pair* Info::add_property_pairs() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >&
Info::property_pairs() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Info.property_pairs)
  return property_pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Pair >*
Info::mutable_property_pairs() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Info.property_pairs)
  return &property_pairs_;
}

// -------------------------------------------------------------------

// LoginReq

// required string mobile_type = 1;
inline bool LoginReq::has_mobile_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_mobile_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_mobile_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_mobile_type() {
  if (mobile_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_->clear();
  }
  clear_has_mobile_type();
}
inline const ::std::string& LoginReq::mobile_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.mobile_type)
  return *mobile_type_;
}
inline void LoginReq::set_mobile_type(const ::std::string& value) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.mobile_type)
}
inline void LoginReq::set_mobile_type(const char* value) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.mobile_type)
}
inline void LoginReq::set_mobile_type(const char* value, size_t size) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.mobile_type)
}
inline ::std::string* LoginReq::mutable_mobile_type() {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.mobile_type)
  return mobile_type_;
}
inline ::std::string* LoginReq::release_mobile_type() {
  clear_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_type_;
    mobile_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_mobile_type(::std::string* mobile_type) {
  if (mobile_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_type_;
  }
  if (mobile_type) {
    set_has_mobile_type();
    mobile_type_ = mobile_type;
  } else {
    clear_has_mobile_type();
    mobile_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.mobile_type)
}

// required uint32 net_type = 2;
inline bool LoginReq::has_net_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_net_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_net_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_net_type() {
  net_type_ = 0u;
  clear_has_net_type();
}
inline ::google::protobuf::uint32 LoginReq::net_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.net_type)
  return net_type_;
}
inline void LoginReq::set_net_type(::google::protobuf::uint32 value) {
  set_has_net_type();
  net_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.net_type)
}

// required string server_ram = 3;
inline bool LoginReq::has_server_ram() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_server_ram() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_server_ram() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_server_ram() {
  if (server_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_->clear();
  }
  clear_has_server_ram();
}
inline const ::std::string& LoginReq::server_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.server_ram)
  return *server_ram_;
}
inline void LoginReq::set_server_ram(const ::std::string& value) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.server_ram)
}
inline void LoginReq::set_server_ram(const char* value) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.server_ram)
}
inline void LoginReq::set_server_ram(const char* value, size_t size) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.server_ram)
}
inline ::std::string* LoginReq::mutable_server_ram() {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.server_ram)
  return server_ram_;
}
inline ::std::string* LoginReq::release_server_ram() {
  clear_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_ram_;
    server_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_server_ram(::std::string* server_ram) {
  if (server_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_ram_;
  }
  if (server_ram) {
    set_has_server_ram();
    server_ram_ = server_ram;
  } else {
    clear_has_server_ram();
    server_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.server_ram)
}

// optional bytes secret_ram = 4;
inline bool LoginReq::has_secret_ram() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_secret_ram() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_secret_ram() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_secret_ram() {
  if (secret_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ram_->clear();
  }
  clear_has_secret_ram();
}
inline const ::std::string& LoginReq::secret_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.secret_ram)
  return *secret_ram_;
}
inline void LoginReq::set_secret_ram(const ::std::string& value) {
  set_has_secret_ram();
  if (secret_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ram_ = new ::std::string;
  }
  secret_ram_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.secret_ram)
}
inline void LoginReq::set_secret_ram(const char* value) {
  set_has_secret_ram();
  if (secret_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ram_ = new ::std::string;
  }
  secret_ram_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.secret_ram)
}
inline void LoginReq::set_secret_ram(const void* value, size_t size) {
  set_has_secret_ram();
  if (secret_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ram_ = new ::std::string;
  }
  secret_ram_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.secret_ram)
}
inline ::std::string* LoginReq::mutable_secret_ram() {
  set_has_secret_ram();
  if (secret_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secret_ram_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.secret_ram)
  return secret_ram_;
}
inline ::std::string* LoginReq::release_secret_ram() {
  clear_has_secret_ram();
  if (secret_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secret_ram_;
    secret_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_secret_ram(::std::string* secret_ram) {
  if (secret_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secret_ram_;
  }
  if (secret_ram) {
    set_has_secret_ram();
    secret_ram_ = secret_ram;
  } else {
    clear_has_secret_ram();
    secret_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.secret_ram)
}

// optional uint32 app_id = 5 [default = 2000];
inline bool LoginReq::has_app_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_app_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_app_id() {
  app_id_ = 2000u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 LoginReq::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.app_id)
  return app_id_;
}
inline void LoginReq::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.app_id)
}

// optional uint32 heart_feq = 6 [default = 300];
inline bool LoginReq::has_heart_feq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_heart_feq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_heart_feq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_heart_feq() {
  heart_feq_ = 300u;
  clear_has_heart_feq();
}
inline ::google::protobuf::uint32 LoginReq::heart_feq() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.heart_feq)
  return heart_feq_;
}
inline void LoginReq::set_heart_feq(::google::protobuf::uint32 value) {
  set_has_heart_feq();
  heart_feq_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.heart_feq)
}

// optional string deviceid = 7 [default = ""];
inline bool LoginReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginReq::deviceid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.deviceid)
  return *deviceid_;
}
inline void LoginReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.deviceid)
}
inline void LoginReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.deviceid)
}
inline void LoginReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.deviceid)
}
inline ::std::string* LoginReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    deviceid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.deviceid)
  return deviceid_;
}
inline ::std::string* LoginReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.deviceid)
}

// optional string platform = 8;
inline bool LoginReq::has_platform() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_platform() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_platform() {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& LoginReq::platform() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.platform)
  return *platform_;
}
inline void LoginReq::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.platform)
}
inline void LoginReq::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.platform)
}
inline void LoginReq::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.platform)
}
inline ::std::string* LoginReq::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.platform)
  return platform_;
}
inline ::std::string* LoginReq::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.platform)
}

// optional string verf_code = 9;
inline bool LoginReq::has_verf_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_verf_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_verf_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_verf_code() {
  if (verf_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verf_code_->clear();
  }
  clear_has_verf_code();
}
inline const ::std::string& LoginReq::verf_code() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.verf_code)
  return *verf_code_;
}
inline void LoginReq::set_verf_code(const ::std::string& value) {
  set_has_verf_code();
  if (verf_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verf_code_ = new ::std::string;
  }
  verf_code_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.verf_code)
}
inline void LoginReq::set_verf_code(const char* value) {
  set_has_verf_code();
  if (verf_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verf_code_ = new ::std::string;
  }
  verf_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginReq.verf_code)
}
inline void LoginReq::set_verf_code(const char* value, size_t size) {
  set_has_verf_code();
  if (verf_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verf_code_ = new ::std::string;
  }
  verf_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginReq.verf_code)
}
inline ::std::string* LoginReq::mutable_verf_code() {
  set_has_verf_code();
  if (verf_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    verf_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginReq.verf_code)
  return verf_code_;
}
inline ::std::string* LoginReq::release_verf_code() {
  clear_has_verf_code();
  if (verf_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = verf_code_;
    verf_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_verf_code(::std::string* verf_code) {
  if (verf_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete verf_code_;
  }
  if (verf_code) {
    set_has_verf_code();
    verf_code_ = verf_code;
  } else {
    clear_has_verf_code();
    verf_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginReq.verf_code)
}

// optional bool not_encrypt = 10;
inline bool LoginReq::has_not_encrypt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_not_encrypt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_not_encrypt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_not_encrypt() {
  not_encrypt_ = false;
  clear_has_not_encrypt();
}
inline bool LoginReq::not_encrypt() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginReq.not_encrypt)
  return not_encrypt_;
}
inline void LoginReq::set_not_encrypt(bool value) {
  set_has_not_encrypt();
  not_encrypt_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginReq.not_encrypt)
}

// -------------------------------------------------------------------

// LoginResp

// required uint32 timestamp = 1;
inline bool LoginResp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResp::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 LoginResp::timestamp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.timestamp)
  return timestamp_;
}
inline void LoginResp::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.timestamp)
}

// required string session_id = 2;
inline bool LoginResp::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResp::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResp::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResp::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& LoginResp::session_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.session_id)
  return *session_id_;
}
inline void LoginResp::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.session_id)
}
inline void LoginResp::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.session_id)
}
inline void LoginResp::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.session_id)
}
inline ::std::string* LoginResp::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.session_id)
  return session_id_;
}
inline ::std::string* LoginResp::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResp::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.session_id)
}

// required string session_key = 3;
inline bool LoginResp::has_session_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResp::set_has_session_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResp::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResp::clear_session_key() {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_->clear();
  }
  clear_has_session_key();
}
inline const ::std::string& LoginResp::session_key() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.session_key)
  return *session_key_;
}
inline void LoginResp::set_session_key(const ::std::string& value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.session_key)
}
inline void LoginResp::set_session_key(const char* value) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.session_key)
}
inline void LoginResp::set_session_key(const char* value, size_t size) {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  session_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.session_key)
}
inline ::std::string* LoginResp::mutable_session_key() {
  set_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.session_key)
  return session_key_;
}
inline ::std::string* LoginResp::release_session_key() {
  clear_has_session_key();
  if (session_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_key_;
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResp::set_allocated_session_key(::std::string* session_key) {
  if (session_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_key_;
  }
  if (session_key) {
    set_has_session_key();
    session_key_ = session_key;
  } else {
    clear_has_session_key();
    session_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.session_key)
}

// optional string client_login_ip = 4;
inline bool LoginResp::has_client_login_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResp::set_has_client_login_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResp::clear_has_client_login_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResp::clear_client_login_ip() {
  if (client_login_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_login_ip_->clear();
  }
  clear_has_client_login_ip();
}
inline const ::std::string& LoginResp::client_login_ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.client_login_ip)
  return *client_login_ip_;
}
inline void LoginResp::set_client_login_ip(const ::std::string& value) {
  set_has_client_login_ip();
  if (client_login_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_login_ip_ = new ::std::string;
  }
  client_login_ip_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.client_login_ip)
}
inline void LoginResp::set_client_login_ip(const char* value) {
  set_has_client_login_ip();
  if (client_login_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_login_ip_ = new ::std::string;
  }
  client_login_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.client_login_ip)
}
inline void LoginResp::set_client_login_ip(const char* value, size_t size) {
  set_has_client_login_ip();
  if (client_login_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_login_ip_ = new ::std::string;
  }
  client_login_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.client_login_ip)
}
inline ::std::string* LoginResp::mutable_client_login_ip() {
  set_has_client_login_ip();
  if (client_login_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_login_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.client_login_ip)
  return client_login_ip_;
}
inline ::std::string* LoginResp::release_client_login_ip() {
  clear_has_client_login_ip();
  if (client_login_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_login_ip_;
    client_login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResp::set_allocated_client_login_ip(::std::string* client_login_ip) {
  if (client_login_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_login_ip_;
  }
  if (client_login_ip) {
    set_has_client_login_ip();
    client_login_ip_ = client_login_ip;
  } else {
    clear_has_client_login_ip();
    client_login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.client_login_ip)
}

// optional string serverip = 5;
inline bool LoginResp::has_serverip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResp::set_has_serverip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResp::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResp::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& LoginResp::serverip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LoginResp.serverip)
  return *serverip_;
}
inline void LoginResp::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LoginResp.serverip)
}
inline void LoginResp::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LoginResp.serverip)
}
inline void LoginResp::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LoginResp.serverip)
}
inline ::std::string* LoginResp::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LoginResp.serverip)
  return serverip_;
}
inline ::std::string* LoginResp::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginResp::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LoginResp.serverip)
}

// -------------------------------------------------------------------

// ChatReq

// required bytes body = 1;
inline bool ChatReq::has_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::set_has_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReq::clear_has_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReq::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& ChatReq::body() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body)
  return *body_;
}
inline void ChatReq::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body)
}
inline void ChatReq::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.body)
}
inline void ChatReq::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.body)
}
inline ::std::string* ChatReq::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.body)
  return body_;
}
inline ::std::string* ChatReq::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReq::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.body)
}

// optional uint32 body_id = 2;
inline bool ChatReq::has_body_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReq::set_has_body_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReq::clear_has_body_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReq::clear_body_id() {
  body_id_ = 0u;
  clear_has_body_id();
}
inline ::google::protobuf::uint32 ChatReq::body_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body_id)
  return body_id_;
}
inline void ChatReq::set_body_id(::google::protobuf::uint32 value) {
  set_has_body_id();
  body_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body_id)
}

// optional uint32 more_flag = 3;
inline bool ChatReq::has_more_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReq::set_has_more_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReq::clear_has_more_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReq::clear_more_flag() {
  more_flag_ = 0u;
  clear_has_more_flag();
}
inline ::google::protobuf::uint32 ChatReq::more_flag() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.more_flag)
  return more_flag_;
}
inline void ChatReq::set_more_flag(::google::protobuf::uint32 value) {
  set_has_more_flag();
  more_flag_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.more_flag)
}

// required uint32 body_type = 4;
inline bool ChatReq::has_body_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatReq::set_has_body_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatReq::clear_has_body_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatReq::clear_body_type() {
  body_type_ = 0u;
  clear_has_body_type();
}
inline ::google::protobuf::uint32 ChatReq::body_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.body_type)
  return body_type_;
}
inline void ChatReq::set_body_type(::google::protobuf::uint32 value) {
  set_has_body_type();
  body_type_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.body_type)
}

// optional bool store = 5;
inline bool ChatReq::has_store() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChatReq::set_has_store() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChatReq::clear_has_store() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChatReq::clear_store() {
  store_ = false;
  clear_has_store();
}
inline bool ChatReq::store() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.store)
  return store_;
}
inline void ChatReq::set_store(bool value) {
  set_has_store();
  store_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.store)
}

// optional bytes m_parameter = 6;
inline bool ChatReq::has_m_parameter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChatReq::set_has_m_parameter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChatReq::clear_has_m_parameter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChatReq::clear_m_parameter() {
  if (m_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    m_parameter_->clear();
  }
  clear_has_m_parameter();
}
inline const ::std::string& ChatReq::m_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.m_parameter)
  return *m_parameter_;
}
inline void ChatReq::set_m_parameter(const ::std::string& value) {
  set_has_m_parameter();
  if (m_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    m_parameter_ = new ::std::string;
  }
  m_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.m_parameter)
}
inline void ChatReq::set_m_parameter(const char* value) {
  set_has_m_parameter();
  if (m_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    m_parameter_ = new ::std::string;
  }
  m_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.m_parameter)
}
inline void ChatReq::set_m_parameter(const void* value, size_t size) {
  set_has_m_parameter();
  if (m_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    m_parameter_ = new ::std::string;
  }
  m_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.m_parameter)
}
inline ::std::string* ChatReq::mutable_m_parameter() {
  set_has_m_parameter();
  if (m_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    m_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.m_parameter)
  return m_parameter_;
}
inline ::std::string* ChatReq::release_m_parameter() {
  clear_has_m_parameter();
  if (m_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = m_parameter_;
    m_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReq::set_allocated_m_parameter(::std::string* m_parameter) {
  if (m_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete m_parameter_;
  }
  if (m_parameter) {
    set_has_m_parameter();
    m_parameter_ = m_parameter;
  } else {
    clear_has_m_parameter();
    m_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.m_parameter)
}

// optional uint32 service_id = 7;
inline bool ChatReq::has_service_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChatReq::set_has_service_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChatReq::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChatReq::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 ChatReq::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.service_id)
  return service_id_;
}
inline void ChatReq::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.service_id)
}

// optional bytes s_parameter = 8;
inline bool ChatReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChatReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChatReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChatReq::clear_s_parameter() {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_->clear();
  }
  clear_has_s_parameter();
}
inline const ::std::string& ChatReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.s_parameter)
  return *s_parameter_;
}
inline void ChatReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.s_parameter)
}
inline void ChatReq::set_s_parameter(const char* value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ChatReq.s_parameter)
}
inline void ChatReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ChatReq.s_parameter)
}
inline ::std::string* ChatReq::mutable_s_parameter() {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ChatReq.s_parameter)
  return s_parameter_;
}
inline ::std::string* ChatReq::release_s_parameter() {
  clear_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_parameter_;
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChatReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_parameter_;
  }
  if (s_parameter) {
    set_has_s_parameter();
    s_parameter_ = s_parameter;
  } else {
    clear_has_s_parameter();
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ChatReq.s_parameter)
}

// optional uint32 expire_time = 12;
inline bool ChatReq::has_expire_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChatReq::set_has_expire_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChatReq::clear_has_expire_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChatReq::clear_expire_time() {
  expire_time_ = 0u;
  clear_has_expire_time();
}
inline ::google::protobuf::uint32 ChatReq::expire_time() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatReq.expire_time)
  return expire_time_;
}
inline void ChatReq::set_expire_time(::google::protobuf::uint32 value) {
  set_has_expire_time();
  expire_time_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatReq.expire_time)
}

// -------------------------------------------------------------------

// ChatResp

// required uint32 result = 1;
inline bool ChatResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ChatResp::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatResp.result)
  return result_;
}
inline void ChatResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatResp.result)
}

// optional uint32 body_id = 2;
inline bool ChatResp::has_body_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatResp::set_has_body_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatResp::clear_has_body_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatResp::clear_body_id() {
  body_id_ = 0u;
  clear_has_body_id();
}
inline ::google::protobuf::uint32 ChatResp::body_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ChatResp.body_id)
  return body_id_;
}
inline void ChatResp::set_body_id(::google::protobuf::uint32 value) {
  set_has_body_id();
  body_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ChatResp.body_id)
}

// -------------------------------------------------------------------

// GetInfoReq

// required string info_type = 1;
inline bool GetInfoReq::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInfoReq::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInfoReq::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInfoReq::clear_info_type() {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_->clear();
  }
  clear_has_info_type();
}
inline const ::std::string& GetInfoReq::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.info_type)
  return *info_type_;
}
inline void GetInfoReq::set_info_type(const ::std::string& value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.info_type)
}
inline void GetInfoReq::set_info_type(const char* value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoReq.info_type)
}
inline void GetInfoReq::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoReq.info_type)
}
inline ::std::string* GetInfoReq::mutable_info_type() {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoReq.info_type)
  return info_type_;
}
inline ::std::string* GetInfoReq::release_info_type() {
  clear_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_type_;
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetInfoReq::set_allocated_info_type(::std::string* info_type) {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_type_;
  }
  if (info_type) {
    set_has_info_type();
    info_type_ = info_type;
  } else {
    clear_has_info_type();
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoReq.info_type)
}

// required int64 get_info_id = 2;
inline bool GetInfoReq::has_get_info_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetInfoReq::set_has_get_info_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetInfoReq::clear_has_get_info_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetInfoReq::clear_get_info_id() {
  get_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_get_info_id();
}
inline ::google::protobuf::int64 GetInfoReq::get_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.get_info_id)
  return get_info_id_;
}
inline void GetInfoReq::set_get_info_id(::google::protobuf::int64 value) {
  set_has_get_info_id();
  get_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.get_info_id)
}

// optional int32 get_info_offset = 3;
inline bool GetInfoReq::has_get_info_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInfoReq::set_has_get_info_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInfoReq::clear_has_get_info_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInfoReq::clear_get_info_offset() {
  get_info_offset_ = 0;
  clear_has_get_info_offset();
}
inline ::google::protobuf::int32 GetInfoReq::get_info_offset() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.get_info_offset)
  return get_info_offset_;
}
inline void GetInfoReq::set_get_info_offset(::google::protobuf::int32 value) {
  set_has_get_info_offset();
  get_info_offset_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.get_info_offset)
}

// optional bytes s_parameter = 4;
inline bool GetInfoReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetInfoReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetInfoReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetInfoReq::clear_s_parameter() {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_->clear();
  }
  clear_has_s_parameter();
}
inline const ::std::string& GetInfoReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoReq.s_parameter)
  return *s_parameter_;
}
inline void GetInfoReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
inline void GetInfoReq::set_s_parameter(const char* value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
inline void GetInfoReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoReq.s_parameter)
}
inline ::std::string* GetInfoReq::mutable_s_parameter() {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoReq.s_parameter)
  return s_parameter_;
}
inline ::std::string* GetInfoReq::release_s_parameter() {
  clear_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_parameter_;
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetInfoReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_parameter_;
  }
  if (s_parameter) {
    set_has_s_parameter();
    s_parameter_ = s_parameter;
  } else {
    clear_has_s_parameter();
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoReq.s_parameter)
}

// -------------------------------------------------------------------

// GetInfoResp

// required string info_type = 1;
inline bool GetInfoResp::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInfoResp::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInfoResp::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInfoResp::clear_info_type() {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_->clear();
  }
  clear_has_info_type();
}
inline const ::std::string& GetInfoResp::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.info_type)
  return *info_type_;
}
inline void GetInfoResp::set_info_type(const ::std::string& value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.info_type)
}
inline void GetInfoResp::set_info_type(const char* value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoResp.info_type)
}
inline void GetInfoResp::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoResp.info_type)
}
inline ::std::string* GetInfoResp::mutable_info_type() {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.info_type)
  return info_type_;
}
inline ::std::string* GetInfoResp::release_info_type() {
  clear_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_type_;
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetInfoResp::set_allocated_info_type(::std::string* info_type) {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_type_;
  }
  if (info_type) {
    set_has_info_type();
    info_type_ = info_type;
  } else {
    clear_has_info_type();
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoResp.info_type)
}

// repeated .qihoo.protocol.messages.Info infos = 2;
inline int GetInfoResp::infos_size() const {
  return infos_.size();
}
inline void GetInfoResp::clear_infos() {
  infos_.Clear();
}
inline const ::qihoo::protocol::messages::Info& GetInfoResp::infos(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Get(index);
}
inline ::qihoo::protocol::messages::Info* GetInfoResp::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Mutable(index);
}
inline ::qihoo::protocol::messages::Info* GetInfoResp::add_infos() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
GetInfoResp::infos() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetInfoResp.infos)
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
GetInfoResp::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetInfoResp.infos)
  return &infos_;
}

// optional int64 last_info_id = 3;
inline bool GetInfoResp::has_last_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetInfoResp::set_has_last_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetInfoResp::clear_has_last_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetInfoResp::clear_last_info_id() {
  last_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_info_id();
}
inline ::google::protobuf::int64 GetInfoResp::last_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.last_info_id)
  return last_info_id_;
}
inline void GetInfoResp::set_last_info_id(::google::protobuf::int64 value) {
  set_has_last_info_id();
  last_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.last_info_id)
}

// optional bytes s_parameter = 4;
inline bool GetInfoResp::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetInfoResp::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetInfoResp::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetInfoResp::clear_s_parameter() {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_->clear();
  }
  clear_has_s_parameter();
}
inline const ::std::string& GetInfoResp::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetInfoResp.s_parameter)
  return *s_parameter_;
}
inline void GetInfoResp::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
inline void GetInfoResp::set_s_parameter(const char* value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
inline void GetInfoResp::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetInfoResp.s_parameter)
}
inline ::std::string* GetInfoResp::mutable_s_parameter() {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetInfoResp.s_parameter)
  return s_parameter_;
}
inline ::std::string* GetInfoResp::release_s_parameter() {
  clear_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_parameter_;
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetInfoResp::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_parameter_;
  }
  if (s_parameter) {
    set_has_s_parameter();
    s_parameter_ = s_parameter;
  } else {
    clear_has_s_parameter();
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetInfoResp.s_parameter)
}

// -------------------------------------------------------------------

// GetMultiInfosReq

// required string info_type = 1;
inline bool GetMultiInfosReq::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMultiInfosReq::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMultiInfosReq::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMultiInfosReq::clear_info_type() {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_->clear();
  }
  clear_has_info_type();
}
inline const ::std::string& GetMultiInfosReq::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.info_type)
  return *info_type_;
}
inline void GetMultiInfosReq::set_info_type(const ::std::string& value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
inline void GetMultiInfosReq::set_info_type(const char* value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
inline void GetMultiInfosReq::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}
inline ::std::string* GetMultiInfosReq::mutable_info_type() {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosReq.info_type)
  return info_type_;
}
inline ::std::string* GetMultiInfosReq::release_info_type() {
  clear_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_type_;
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMultiInfosReq::set_allocated_info_type(::std::string* info_type) {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_type_;
  }
  if (info_type) {
    set_has_info_type();
    info_type_ = info_type;
  } else {
    clear_has_info_type();
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosReq.info_type)
}

// repeated int64 get_info_ids = 2;
inline int GetMultiInfosReq::get_info_ids_size() const {
  return get_info_ids_.size();
}
inline void GetMultiInfosReq::clear_get_info_ids() {
  get_info_ids_.Clear();
}
inline ::google::protobuf::int64 GetMultiInfosReq::get_info_ids(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return get_info_ids_.Get(index);
}
inline void GetMultiInfosReq::set_get_info_ids(int index, ::google::protobuf::int64 value) {
  get_info_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
}
inline void GetMultiInfosReq::add_get_info_ids(::google::protobuf::int64 value) {
  get_info_ids_.Add(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetMultiInfosReq::get_info_ids() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return get_info_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetMultiInfosReq::mutable_get_info_ids() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetMultiInfosReq.get_info_ids)
  return &get_info_ids_;
}

// optional bytes s_parameter = 3;
inline bool GetMultiInfosReq::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMultiInfosReq::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMultiInfosReq::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMultiInfosReq::clear_s_parameter() {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_->clear();
  }
  clear_has_s_parameter();
}
inline const ::std::string& GetMultiInfosReq::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
  return *s_parameter_;
}
inline void GetMultiInfosReq::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
inline void GetMultiInfosReq::set_s_parameter(const char* value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
inline void GetMultiInfosReq::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}
inline ::std::string* GetMultiInfosReq::mutable_s_parameter() {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
  return s_parameter_;
}
inline ::std::string* GetMultiInfosReq::release_s_parameter() {
  clear_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_parameter_;
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMultiInfosReq::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_parameter_;
  }
  if (s_parameter) {
    set_has_s_parameter();
    s_parameter_ = s_parameter;
  } else {
    clear_has_s_parameter();
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosReq.s_parameter)
}

// -------------------------------------------------------------------

// GetMultiInfosResp

// required string info_type = 1;
inline bool GetMultiInfosResp::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMultiInfosResp::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMultiInfosResp::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMultiInfosResp::clear_info_type() {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_->clear();
  }
  clear_has_info_type();
}
inline const ::std::string& GetMultiInfosResp::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.info_type)
  return *info_type_;
}
inline void GetMultiInfosResp::set_info_type(const ::std::string& value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
inline void GetMultiInfosResp::set_info_type(const char* value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
inline void GetMultiInfosResp::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}
inline ::std::string* GetMultiInfosResp::mutable_info_type() {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.info_type)
  return info_type_;
}
inline ::std::string* GetMultiInfosResp::release_info_type() {
  clear_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_type_;
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMultiInfosResp::set_allocated_info_type(::std::string* info_type) {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_type_;
  }
  if (info_type) {
    set_has_info_type();
    info_type_ = info_type;
  } else {
    clear_has_info_type();
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosResp.info_type)
}

// repeated .qihoo.protocol.messages.Info infos = 2;
inline int GetMultiInfosResp::infos_size() const {
  return infos_.size();
}
inline void GetMultiInfosResp::clear_infos() {
  infos_.Clear();
}
inline const ::qihoo::protocol::messages::Info& GetMultiInfosResp::infos(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Get(index);
}
inline ::qihoo::protocol::messages::Info* GetMultiInfosResp::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Mutable(index);
}
inline ::qihoo::protocol::messages::Info* GetMultiInfosResp::add_infos() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >&
GetMultiInfosResp::infos() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::Info >*
GetMultiInfosResp::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.GetMultiInfosResp.infos)
  return &infos_;
}

// optional int64 last_info_id = 3;
inline bool GetMultiInfosResp::has_last_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMultiInfosResp::set_has_last_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMultiInfosResp::clear_has_last_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMultiInfosResp::clear_last_info_id() {
  last_info_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_info_id();
}
inline ::google::protobuf::int64 GetMultiInfosResp::last_info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.last_info_id)
  return last_info_id_;
}
inline void GetMultiInfosResp::set_last_info_id(::google::protobuf::int64 value) {
  set_has_last_info_id();
  last_info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.last_info_id)
}

// optional bytes s_parameter = 4;
inline bool GetMultiInfosResp::has_s_parameter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetMultiInfosResp::set_has_s_parameter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetMultiInfosResp::clear_has_s_parameter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetMultiInfosResp::clear_s_parameter() {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_->clear();
  }
  clear_has_s_parameter();
}
inline const ::std::string& GetMultiInfosResp::s_parameter() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
  return *s_parameter_;
}
inline void GetMultiInfosResp::set_s_parameter(const ::std::string& value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
inline void GetMultiInfosResp::set_s_parameter(const char* value) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
inline void GetMultiInfosResp::set_s_parameter(const void* value, size_t size) {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  s_parameter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}
inline ::std::string* GetMultiInfosResp::mutable_s_parameter() {
  set_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    s_parameter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
  return s_parameter_;
}
inline ::std::string* GetMultiInfosResp::release_s_parameter() {
  clear_has_s_parameter();
  if (s_parameter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = s_parameter_;
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetMultiInfosResp::set_allocated_s_parameter(::std::string* s_parameter) {
  if (s_parameter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete s_parameter_;
  }
  if (s_parameter) {
    set_has_s_parameter();
    s_parameter_ = s_parameter;
  } else {
    clear_has_s_parameter();
    s_parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.GetMultiInfosResp.s_parameter)
}

// -------------------------------------------------------------------

// LogoutReq

// optional string reason = 1;
inline bool LogoutReq::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutReq::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutReq::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutReq::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& LogoutReq::reason() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LogoutReq.reason)
  return *reason_;
}
inline void LogoutReq::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LogoutReq.reason)
}
inline void LogoutReq::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.LogoutReq.reason)
}
inline void LogoutReq::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.LogoutReq.reason)
}
inline ::std::string* LogoutReq::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.LogoutReq.reason)
  return reason_;
}
inline ::std::string* LogoutReq::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogoutReq::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.LogoutReq.reason)
}

// -------------------------------------------------------------------

// LogoutResp

// required uint32 result = 1;
inline bool LogoutResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResp::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 LogoutResp::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.LogoutResp.result)
  return result_;
}
inline void LogoutResp::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.LogoutResp.result)
}

// -------------------------------------------------------------------

// InitLoginReq

// required string client_ram = 1;
inline bool InitLoginReq::has_client_ram() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitLoginReq::set_has_client_ram() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitLoginReq::clear_has_client_ram() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitLoginReq::clear_client_ram() {
  if (client_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_->clear();
  }
  clear_has_client_ram();
}
inline const ::std::string& InitLoginReq::client_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginReq.client_ram)
  return *client_ram_;
}
inline void InitLoginReq::set_client_ram(const ::std::string& value) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginReq.client_ram)
}
inline void InitLoginReq::set_client_ram(const char* value) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginReq.client_ram)
}
inline void InitLoginReq::set_client_ram(const char* value, size_t size) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginReq.client_ram)
}
inline ::std::string* InitLoginReq::mutable_client_ram() {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginReq.client_ram)
  return client_ram_;
}
inline ::std::string* InitLoginReq::release_client_ram() {
  clear_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_ram_;
    client_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitLoginReq::set_allocated_client_ram(::std::string* client_ram) {
  if (client_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_ram_;
  }
  if (client_ram) {
    set_has_client_ram();
    client_ram_ = client_ram;
  } else {
    clear_has_client_ram();
    client_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginReq.client_ram)
}

// optional string sig = 2;
inline bool InitLoginReq::has_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitLoginReq::set_has_sig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitLoginReq::clear_has_sig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitLoginReq::clear_sig() {
  if (sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& InitLoginReq::sig() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginReq.sig)
  return *sig_;
}
inline void InitLoginReq::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginReq.sig)
}
inline void InitLoginReq::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginReq.sig)
}
inline void InitLoginReq::set_sig(const char* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginReq.sig)
}
inline ::std::string* InitLoginReq::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sig_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginReq.sig)
  return sig_;
}
inline ::std::string* InitLoginReq::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitLoginReq::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginReq.sig)
}

// -------------------------------------------------------------------

// InitLoginResp

// required string client_ram = 1;
inline bool InitLoginResp::has_client_ram() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitLoginResp::set_has_client_ram() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitLoginResp::clear_has_client_ram() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitLoginResp::clear_client_ram() {
  if (client_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_->clear();
  }
  clear_has_client_ram();
}
inline const ::std::string& InitLoginResp::client_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginResp.client_ram)
  return *client_ram_;
}
inline void InitLoginResp::set_client_ram(const ::std::string& value) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginResp.client_ram)
}
inline void InitLoginResp::set_client_ram(const char* value) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginResp.client_ram)
}
inline void InitLoginResp::set_client_ram(const char* value, size_t size) {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  client_ram_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginResp.client_ram)
}
inline ::std::string* InitLoginResp::mutable_client_ram() {
  set_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_ram_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginResp.client_ram)
  return client_ram_;
}
inline ::std::string* InitLoginResp::release_client_ram() {
  clear_has_client_ram();
  if (client_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_ram_;
    client_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitLoginResp::set_allocated_client_ram(::std::string* client_ram) {
  if (client_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_ram_;
  }
  if (client_ram) {
    set_has_client_ram();
    client_ram_ = client_ram;
  } else {
    clear_has_client_ram();
    client_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginResp.client_ram)
}

// required string server_ram = 2;
inline bool InitLoginResp::has_server_ram() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitLoginResp::set_has_server_ram() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitLoginResp::clear_has_server_ram() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitLoginResp::clear_server_ram() {
  if (server_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_->clear();
  }
  clear_has_server_ram();
}
inline const ::std::string& InitLoginResp::server_ram() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.InitLoginResp.server_ram)
  return *server_ram_;
}
inline void InitLoginResp::set_server_ram(const ::std::string& value) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.InitLoginResp.server_ram)
}
inline void InitLoginResp::set_server_ram(const char* value) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.InitLoginResp.server_ram)
}
inline void InitLoginResp::set_server_ram(const char* value, size_t size) {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  server_ram_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.InitLoginResp.server_ram)
}
inline ::std::string* InitLoginResp::mutable_server_ram() {
  set_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    server_ram_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.InitLoginResp.server_ram)
  return server_ram_;
}
inline ::std::string* InitLoginResp::release_server_ram() {
  clear_has_server_ram();
  if (server_ram_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = server_ram_;
    server_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InitLoginResp::set_allocated_server_ram(::std::string* server_ram) {
  if (server_ram_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete server_ram_;
  }
  if (server_ram) {
    set_has_server_ram();
    server_ram_ = server_ram;
  } else {
    clear_has_server_ram();
    server_ram_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.InitLoginResp.server_ram)
}

// -------------------------------------------------------------------

// Service_Req

// required uint32 service_id = 1;
inline bool Service_Req::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service_Req::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service_Req::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service_Req::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Service_Req::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Req.service_id)
  return service_id_;
}
inline void Service_Req::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Req.service_id)
}

// required bytes request = 2;
inline bool Service_Req::has_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service_Req::set_has_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service_Req::clear_has_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service_Req::clear_request() {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& Service_Req::request() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Req.request)
  return *request_;
}
inline void Service_Req::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Req.request)
}
inline void Service_Req::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Service_Req.request)
}
inline void Service_Req::set_request(const void* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Service_Req.request)
}
inline ::std::string* Service_Req::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    request_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Service_Req.request)
  return request_;
}
inline ::std::string* Service_Req::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Service_Req::set_allocated_request(::std::string* request) {
  if (request_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete request_;
  }
  if (request) {
    set_has_request();
    request_ = request;
  } else {
    clear_has_request();
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Service_Req.request)
}

// -------------------------------------------------------------------

// Service_Resp

// required uint32 service_id = 1;
inline bool Service_Resp::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service_Resp::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service_Resp::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service_Resp::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Service_Resp::service_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Resp.service_id)
  return service_id_;
}
inline void Service_Resp::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Resp.service_id)
}

// required bytes response = 2;
inline bool Service_Resp::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service_Resp::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service_Resp::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service_Resp::clear_response() {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_->clear();
  }
  clear_has_response();
}
inline const ::std::string& Service_Resp::response() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Service_Resp.response)
  return *response_;
}
inline void Service_Resp::set_response(const ::std::string& value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Service_Resp.response)
}
inline void Service_Resp::set_response(const char* value) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Service_Resp.response)
}
inline void Service_Resp::set_response(const void* value, size_t size) {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Service_Resp.response)
}
inline ::std::string* Service_Resp::mutable_response() {
  set_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    response_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Service_Resp.response)
  return response_;
}
inline ::std::string* Service_Resp::release_response() {
  clear_has_response();
  if (response_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = response_;
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Service_Resp::set_allocated_response(::std::string* response) {
  if (response_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete response_;
  }
  if (response) {
    set_has_response();
    response_ = response;
  } else {
    clear_has_response();
    response_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Service_Resp.response)
}

// -------------------------------------------------------------------

// ReqEQ1User

// required string userid = 1;
inline bool ReqEQ1User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEQ1User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEQ1User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEQ1User::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& ReqEQ1User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.userid)
  return *userid_;
}
inline void ReqEQ1User::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.userid)
}
inline void ReqEQ1User::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReqEQ1User.userid)
}
inline void ReqEQ1User::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReqEQ1User.userid)
}
inline ::std::string* ReqEQ1User::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReqEQ1User.userid)
  return userid_;
}
inline ::std::string* ReqEQ1User::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqEQ1User::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReqEQ1User.userid)
}

// required string user_type = 2;
inline bool ReqEQ1User::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEQ1User::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEQ1User::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEQ1User::clear_user_type() {
  if (user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_->clear();
  }
  clear_has_user_type();
}
inline const ::std::string& ReqEQ1User::user_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.user_type)
  return *user_type_;
}
inline void ReqEQ1User::set_user_type(const ::std::string& value) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.user_type)
}
inline void ReqEQ1User::set_user_type(const char* value) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReqEQ1User.user_type)
}
inline void ReqEQ1User::set_user_type(const char* value, size_t size) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReqEQ1User.user_type)
}
inline ::std::string* ReqEQ1User::mutable_user_type() {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReqEQ1User.user_type)
  return user_type_;
}
inline ::std::string* ReqEQ1User::release_user_type() {
  clear_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_type_;
    user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReqEQ1User::set_allocated_user_type(::std::string* user_type) {
  if (user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_type_;
  }
  if (user_type) {
    set_has_user_type();
    user_type_ = user_type;
  } else {
    clear_has_user_type();
    user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReqEQ1User.user_type)
}

// optional uint32 app_id = 3;
inline bool ReqEQ1User::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqEQ1User::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqEQ1User::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqEQ1User::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 ReqEQ1User::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReqEQ1User.app_id)
  return app_id_;
}
inline void ReqEQ1User::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReqEQ1User.app_id)
}

// -------------------------------------------------------------------

// RespEQ1User

// required string userid = 1;
inline bool RespEQ1User::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespEQ1User::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespEQ1User::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespEQ1User::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& RespEQ1User::userid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.userid)
  return *userid_;
}
inline void RespEQ1User::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.userid)
}
inline void RespEQ1User::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.userid)
}
inline void RespEQ1User::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.userid)
}
inline ::std::string* RespEQ1User::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.userid)
  return userid_;
}
inline ::std::string* RespEQ1User::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespEQ1User::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.userid)
}

// required string user_type = 2;
inline bool RespEQ1User::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespEQ1User::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespEQ1User::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespEQ1User::clear_user_type() {
  if (user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_->clear();
  }
  clear_has_user_type();
}
inline const ::std::string& RespEQ1User::user_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.user_type)
  return *user_type_;
}
inline void RespEQ1User::set_user_type(const ::std::string& value) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.user_type)
}
inline void RespEQ1User::set_user_type(const char* value) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.user_type)
}
inline void RespEQ1User::set_user_type(const char* value, size_t size) {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  user_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.user_type)
}
inline ::std::string* RespEQ1User::mutable_user_type() {
  set_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.user_type)
  return user_type_;
}
inline ::std::string* RespEQ1User::release_user_type() {
  clear_has_user_type();
  if (user_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_type_;
    user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespEQ1User::set_allocated_user_type(::std::string* user_type) {
  if (user_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_type_;
  }
  if (user_type) {
    set_has_user_type();
    user_type_ = user_type;
  } else {
    clear_has_user_type();
    user_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.user_type)
}

// required int32 status = 3;
inline bool RespEQ1User::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespEQ1User::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespEQ1User::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespEQ1User::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RespEQ1User::status() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.status)
  return status_;
}
inline void RespEQ1User::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.status)
}

// optional string jid = 4;
inline bool RespEQ1User::has_jid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RespEQ1User::set_has_jid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RespEQ1User::clear_has_jid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RespEQ1User::clear_jid() {
  if (jid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jid_->clear();
  }
  clear_has_jid();
}
inline const ::std::string& RespEQ1User::jid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.jid)
  return *jid_;
}
inline void RespEQ1User::set_jid(const ::std::string& value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.jid)
}
inline void RespEQ1User::set_jid(const char* value) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jid_ = new ::std::string;
  }
  jid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.jid)
}
inline void RespEQ1User::set_jid(const char* value, size_t size) {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jid_ = new ::std::string;
  }
  jid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.jid)
}
inline ::std::string* RespEQ1User::mutable_jid() {
  set_has_jid();
  if (jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    jid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.jid)
  return jid_;
}
inline ::std::string* RespEQ1User::release_jid() {
  clear_has_jid();
  if (jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = jid_;
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespEQ1User::set_allocated_jid(::std::string* jid) {
  if (jid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete jid_;
  }
  if (jid) {
    set_has_jid();
    jid_ = jid;
  } else {
    clear_has_jid();
    jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.jid)
}

// optional uint32 app_id = 5;
inline bool RespEQ1User::has_app_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RespEQ1User::set_has_app_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RespEQ1User::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RespEQ1User::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 RespEQ1User::app_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.app_id)
  return app_id_;
}
inline void RespEQ1User::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.app_id)
}

// optional string platform = 6;
inline bool RespEQ1User::has_platform() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RespEQ1User::set_has_platform() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RespEQ1User::clear_has_platform() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RespEQ1User::clear_platform() {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& RespEQ1User::platform() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.platform)
  return *platform_;
}
inline void RespEQ1User::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.platform)
}
inline void RespEQ1User::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.platform)
}
inline void RespEQ1User::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.platform)
}
inline ::std::string* RespEQ1User::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    platform_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.platform)
  return platform_;
}
inline ::std::string* RespEQ1User::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespEQ1User::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.platform)
}

// optional string mobile_type = 7;
inline bool RespEQ1User::has_mobile_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RespEQ1User::set_has_mobile_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RespEQ1User::clear_has_mobile_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RespEQ1User::clear_mobile_type() {
  if (mobile_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_->clear();
  }
  clear_has_mobile_type();
}
inline const ::std::string& RespEQ1User::mobile_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.mobile_type)
  return *mobile_type_;
}
inline void RespEQ1User::set_mobile_type(const ::std::string& value) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
inline void RespEQ1User::set_mobile_type(const char* value) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
inline void RespEQ1User::set_mobile_type(const char* value, size_t size) {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  mobile_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RespEQ1User.mobile_type)
}
inline ::std::string* RespEQ1User::mutable_mobile_type() {
  set_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mobile_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RespEQ1User.mobile_type)
  return mobile_type_;
}
inline ::std::string* RespEQ1User::release_mobile_type() {
  clear_has_mobile_type();
  if (mobile_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mobile_type_;
    mobile_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RespEQ1User::set_allocated_mobile_type(::std::string* mobile_type) {
  if (mobile_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mobile_type_;
  }
  if (mobile_type) {
    set_has_mobile_type();
    mobile_type_ = mobile_type;
  } else {
    clear_has_mobile_type();
    mobile_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RespEQ1User.mobile_type)
}

// optional uint32 client_ver = 8;
inline bool RespEQ1User::has_client_ver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RespEQ1User::set_has_client_ver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RespEQ1User::clear_has_client_ver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RespEQ1User::clear_client_ver() {
  client_ver_ = 0u;
  clear_has_client_ver();
}
inline ::google::protobuf::uint32 RespEQ1User::client_ver() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RespEQ1User.client_ver)
  return client_ver_;
}
inline void RespEQ1User::set_client_ver(::google::protobuf::uint32 value) {
  set_has_client_ver();
  client_ver_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RespEQ1User.client_ver)
}

// -------------------------------------------------------------------

// Ex1QueryUserStatusReq

// repeated .qihoo.protocol.messages.ReqEQ1User user_list = 1;
inline int Ex1QueryUserStatusReq::user_list_size() const {
  return user_list_.size();
}
inline void Ex1QueryUserStatusReq::clear_user_list() {
  user_list_.Clear();
}
inline const ::qihoo::protocol::messages::ReqEQ1User& Ex1QueryUserStatusReq::user_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Get(index);
}
inline ::qihoo::protocol::messages::ReqEQ1User* Ex1QueryUserStatusReq::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Mutable(index);
}
inline ::qihoo::protocol::messages::ReqEQ1User* Ex1QueryUserStatusReq::add_user_list() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >&
Ex1QueryUserStatusReq::user_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::ReqEQ1User >*
Ex1QueryUserStatusReq::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list)
  return &user_list_;
}

// -------------------------------------------------------------------

// Ex1QueryUserStatusResp

// repeated .qihoo.protocol.messages.RespEQ1User user_list = 1;
inline int Ex1QueryUserStatusResp::user_list_size() const {
  return user_list_.size();
}
inline void Ex1QueryUserStatusResp::clear_user_list() {
  user_list_.Clear();
}
inline const ::qihoo::protocol::messages::RespEQ1User& Ex1QueryUserStatusResp::user_list(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Get(index);
}
inline ::qihoo::protocol::messages::RespEQ1User* Ex1QueryUserStatusResp::mutable_user_list(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Mutable(index);
}
inline ::qihoo::protocol::messages::RespEQ1User* Ex1QueryUserStatusResp::add_user_list() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >&
Ex1QueryUserStatusResp::user_list() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RespEQ1User >*
Ex1QueryUserStatusResp::mutable_user_list() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list)
  return &user_list_;
}

// -------------------------------------------------------------------

// Request

// optional .qihoo.protocol.messages.LoginReq login = 2;
inline bool Request::has_login() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_login() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_login() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_login() {
  if (login_ != NULL) login_->::qihoo::protocol::messages::LoginReq::Clear();
  clear_has_login();
}
inline const ::qihoo::protocol::messages::LoginReq& Request::login() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.login)
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::qihoo::protocol::messages::LoginReq* Request::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::qihoo::protocol::messages::LoginReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.login)
  return login_;
}
inline ::qihoo::protocol::messages::LoginReq* Request::release_login() {
  clear_has_login();
  ::qihoo::protocol::messages::LoginReq* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Request::set_allocated_login(::qihoo::protocol::messages::LoginReq* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.login)
}

// optional .qihoo.protocol.messages.ChatReq chat = 3;
inline bool Request::has_chat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_chat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_chat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_chat() {
  if (chat_ != NULL) chat_->::qihoo::protocol::messages::ChatReq::Clear();
  clear_has_chat();
}
inline const ::qihoo::protocol::messages::ChatReq& Request::chat() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.chat)
  return chat_ != NULL ? *chat_ : *default_instance_->chat_;
}
inline ::qihoo::protocol::messages::ChatReq* Request::mutable_chat() {
  set_has_chat();
  if (chat_ == NULL) chat_ = new ::qihoo::protocol::messages::ChatReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.chat)
  return chat_;
}
inline ::qihoo::protocol::messages::ChatReq* Request::release_chat() {
  clear_has_chat();
  ::qihoo::protocol::messages::ChatReq* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void Request::set_allocated_chat(::qihoo::protocol::messages::ChatReq* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    set_has_chat();
  } else {
    clear_has_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.chat)
}

// optional .qihoo.protocol.messages.GetInfoReq get_info = 5;
inline bool Request::has_get_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_get_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_get_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_get_info() {
  if (get_info_ != NULL) get_info_->::qihoo::protocol::messages::GetInfoReq::Clear();
  clear_has_get_info();
}
inline const ::qihoo::protocol::messages::GetInfoReq& Request::get_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.get_info)
  return get_info_ != NULL ? *get_info_ : *default_instance_->get_info_;
}
inline ::qihoo::protocol::messages::GetInfoReq* Request::mutable_get_info() {
  set_has_get_info();
  if (get_info_ == NULL) get_info_ = new ::qihoo::protocol::messages::GetInfoReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.get_info)
  return get_info_;
}
inline ::qihoo::protocol::messages::GetInfoReq* Request::release_get_info() {
  clear_has_get_info();
  ::qihoo::protocol::messages::GetInfoReq* temp = get_info_;
  get_info_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_info(::qihoo::protocol::messages::GetInfoReq* get_info) {
  delete get_info_;
  get_info_ = get_info;
  if (get_info) {
    set_has_get_info();
  } else {
    clear_has_get_info();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.get_info)
}

// optional .qihoo.protocol.messages.LogoutReq logout = 6;
inline bool Request::has_logout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_logout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_logout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_logout() {
  if (logout_ != NULL) logout_->::qihoo::protocol::messages::LogoutReq::Clear();
  clear_has_logout();
}
inline const ::qihoo::protocol::messages::LogoutReq& Request::logout() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.logout)
  return logout_ != NULL ? *logout_ : *default_instance_->logout_;
}
inline ::qihoo::protocol::messages::LogoutReq* Request::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) logout_ = new ::qihoo::protocol::messages::LogoutReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.logout)
  return logout_;
}
inline ::qihoo::protocol::messages::LogoutReq* Request::release_logout() {
  clear_has_logout();
  ::qihoo::protocol::messages::LogoutReq* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void Request::set_allocated_logout(::qihoo::protocol::messages::LogoutReq* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.logout)
}

// optional .qihoo.protocol.messages.InitLoginReq init_login_req = 9;
inline bool Request::has_init_login_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_init_login_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_init_login_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_init_login_req() {
  if (init_login_req_ != NULL) init_login_req_->::qihoo::protocol::messages::InitLoginReq::Clear();
  clear_has_init_login_req();
}
inline const ::qihoo::protocol::messages::InitLoginReq& Request::init_login_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.init_login_req)
  return init_login_req_ != NULL ? *init_login_req_ : *default_instance_->init_login_req_;
}
inline ::qihoo::protocol::messages::InitLoginReq* Request::mutable_init_login_req() {
  set_has_init_login_req();
  if (init_login_req_ == NULL) init_login_req_ = new ::qihoo::protocol::messages::InitLoginReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.init_login_req)
  return init_login_req_;
}
inline ::qihoo::protocol::messages::InitLoginReq* Request::release_init_login_req() {
  clear_has_init_login_req();
  ::qihoo::protocol::messages::InitLoginReq* temp = init_login_req_;
  init_login_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_init_login_req(::qihoo::protocol::messages::InitLoginReq* init_login_req) {
  delete init_login_req_;
  init_login_req_ = init_login_req;
  if (init_login_req) {
    set_has_init_login_req();
  } else {
    clear_has_init_login_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.init_login_req)
}

// optional .qihoo.protocol.messages.Service_Req service_req = 11;
inline bool Request::has_service_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_service_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_service_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_service_req() {
  if (service_req_ != NULL) service_req_->::qihoo::protocol::messages::Service_Req::Clear();
  clear_has_service_req();
}
inline const ::qihoo::protocol::messages::Service_Req& Request::service_req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.service_req)
  return service_req_ != NULL ? *service_req_ : *default_instance_->service_req_;
}
inline ::qihoo::protocol::messages::Service_Req* Request::mutable_service_req() {
  set_has_service_req();
  if (service_req_ == NULL) service_req_ = new ::qihoo::protocol::messages::Service_Req;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.service_req)
  return service_req_;
}
inline ::qihoo::protocol::messages::Service_Req* Request::release_service_req() {
  clear_has_service_req();
  ::qihoo::protocol::messages::Service_Req* temp = service_req_;
  service_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_service_req(::qihoo::protocol::messages::Service_Req* service_req) {
  delete service_req_;
  service_req_ = service_req;
  if (service_req) {
    set_has_service_req();
  } else {
    clear_has_service_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.service_req)
}

// optional .qihoo.protocol.messages.Ex1QueryUserStatusReq e1_query_user = 12;
inline bool Request::has_e1_query_user() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_e1_query_user() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_e1_query_user() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_e1_query_user() {
  if (e1_query_user_ != NULL) e1_query_user_->::qihoo::protocol::messages::Ex1QueryUserStatusReq::Clear();
  clear_has_e1_query_user();
}
inline const ::qihoo::protocol::messages::Ex1QueryUserStatusReq& Request::e1_query_user() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.e1_query_user)
  return e1_query_user_ != NULL ? *e1_query_user_ : *default_instance_->e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* Request::mutable_e1_query_user() {
  set_has_e1_query_user();
  if (e1_query_user_ == NULL) e1_query_user_ = new ::qihoo::protocol::messages::Ex1QueryUserStatusReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.e1_query_user)
  return e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusReq* Request::release_e1_query_user() {
  clear_has_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusReq* temp = e1_query_user_;
  e1_query_user_ = NULL;
  return temp;
}
inline void Request::set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusReq* e1_query_user) {
  delete e1_query_user_;
  e1_query_user_ = e1_query_user;
  if (e1_query_user) {
    set_has_e1_query_user();
  } else {
    clear_has_e1_query_user();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.e1_query_user)
}

// optional .qihoo.protocol.messages.GetMultiInfosReq get_multi_infos = 100;
inline bool Request::has_get_multi_infos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_get_multi_infos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_get_multi_infos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_get_multi_infos() {
  if (get_multi_infos_ != NULL) get_multi_infos_->::qihoo::protocol::messages::GetMultiInfosReq::Clear();
  clear_has_get_multi_infos();
}
inline const ::qihoo::protocol::messages::GetMultiInfosReq& Request::get_multi_infos() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Request.get_multi_infos)
  return get_multi_infos_ != NULL ? *get_multi_infos_ : *default_instance_->get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosReq* Request::mutable_get_multi_infos() {
  set_has_get_multi_infos();
  if (get_multi_infos_ == NULL) get_multi_infos_ = new ::qihoo::protocol::messages::GetMultiInfosReq;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Request.get_multi_infos)
  return get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosReq* Request::release_get_multi_infos() {
  clear_has_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosReq* temp = get_multi_infos_;
  get_multi_infos_ = NULL;
  return temp;
}
inline void Request::set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosReq* get_multi_infos) {
  delete get_multi_infos_;
  get_multi_infos_ = get_multi_infos;
  if (get_multi_infos) {
    set_has_get_multi_infos();
  } else {
    clear_has_get_multi_infos();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Request.get_multi_infos)
}

// -------------------------------------------------------------------

// Response

// optional .qihoo.protocol.messages.Error error = 1;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_error() {
  if (error_ != NULL) error_->::qihoo::protocol::messages::Error::Clear();
  clear_has_error();
}
inline const ::qihoo::protocol::messages::Error& Response::error() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::qihoo::protocol::messages::Error* Response::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::qihoo::protocol::messages::Error;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.error)
  return error_;
}
inline ::qihoo::protocol::messages::Error* Response::release_error() {
  clear_has_error();
  ::qihoo::protocol::messages::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void Response::set_allocated_error(::qihoo::protocol::messages::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.error)
}

// optional .qihoo.protocol.messages.LoginResp login = 3;
inline bool Response::has_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_login() {
  if (login_ != NULL) login_->::qihoo::protocol::messages::LoginResp::Clear();
  clear_has_login();
}
inline const ::qihoo::protocol::messages::LoginResp& Response::login() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.login)
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::qihoo::protocol::messages::LoginResp* Response::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::qihoo::protocol::messages::LoginResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.login)
  return login_;
}
inline ::qihoo::protocol::messages::LoginResp* Response::release_login() {
  clear_has_login();
  ::qihoo::protocol::messages::LoginResp* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Response::set_allocated_login(::qihoo::protocol::messages::LoginResp* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.login)
}

// optional .qihoo.protocol.messages.ChatResp chat = 4;
inline bool Response::has_chat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_chat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_chat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_chat() {
  if (chat_ != NULL) chat_->::qihoo::protocol::messages::ChatResp::Clear();
  clear_has_chat();
}
inline const ::qihoo::protocol::messages::ChatResp& Response::chat() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.chat)
  return chat_ != NULL ? *chat_ : *default_instance_->chat_;
}
inline ::qihoo::protocol::messages::ChatResp* Response::mutable_chat() {
  set_has_chat();
  if (chat_ == NULL) chat_ = new ::qihoo::protocol::messages::ChatResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.chat)
  return chat_;
}
inline ::qihoo::protocol::messages::ChatResp* Response::release_chat() {
  clear_has_chat();
  ::qihoo::protocol::messages::ChatResp* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void Response::set_allocated_chat(::qihoo::protocol::messages::ChatResp* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    set_has_chat();
  } else {
    clear_has_chat();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.chat)
}

// optional .qihoo.protocol.messages.GetInfoResp get_info = 6;
inline bool Response::has_get_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_get_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_get_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_get_info() {
  if (get_info_ != NULL) get_info_->::qihoo::protocol::messages::GetInfoResp::Clear();
  clear_has_get_info();
}
inline const ::qihoo::protocol::messages::GetInfoResp& Response::get_info() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.get_info)
  return get_info_ != NULL ? *get_info_ : *default_instance_->get_info_;
}
inline ::qihoo::protocol::messages::GetInfoResp* Response::mutable_get_info() {
  set_has_get_info();
  if (get_info_ == NULL) get_info_ = new ::qihoo::protocol::messages::GetInfoResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.get_info)
  return get_info_;
}
inline ::qihoo::protocol::messages::GetInfoResp* Response::release_get_info() {
  clear_has_get_info();
  ::qihoo::protocol::messages::GetInfoResp* temp = get_info_;
  get_info_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_info(::qihoo::protocol::messages::GetInfoResp* get_info) {
  delete get_info_;
  get_info_ = get_info;
  if (get_info) {
    set_has_get_info();
  } else {
    clear_has_get_info();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.get_info)
}

// optional .qihoo.protocol.messages.LogoutResp logout = 7;
inline bool Response::has_logout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_logout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_logout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_logout() {
  if (logout_ != NULL) logout_->::qihoo::protocol::messages::LogoutResp::Clear();
  clear_has_logout();
}
inline const ::qihoo::protocol::messages::LogoutResp& Response::logout() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.logout)
  return logout_ != NULL ? *logout_ : *default_instance_->logout_;
}
inline ::qihoo::protocol::messages::LogoutResp* Response::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) logout_ = new ::qihoo::protocol::messages::LogoutResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.logout)
  return logout_;
}
inline ::qihoo::protocol::messages::LogoutResp* Response::release_logout() {
  clear_has_logout();
  ::qihoo::protocol::messages::LogoutResp* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void Response::set_allocated_logout(::qihoo::protocol::messages::LogoutResp* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.logout)
}

// optional .qihoo.protocol.messages.InitLoginResp init_login_resp = 10;
inline bool Response::has_init_login_resp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_init_login_resp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_init_login_resp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_init_login_resp() {
  if (init_login_resp_ != NULL) init_login_resp_->::qihoo::protocol::messages::InitLoginResp::Clear();
  clear_has_init_login_resp();
}
inline const ::qihoo::protocol::messages::InitLoginResp& Response::init_login_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.init_login_resp)
  return init_login_resp_ != NULL ? *init_login_resp_ : *default_instance_->init_login_resp_;
}
inline ::qihoo::protocol::messages::InitLoginResp* Response::mutable_init_login_resp() {
  set_has_init_login_resp();
  if (init_login_resp_ == NULL) init_login_resp_ = new ::qihoo::protocol::messages::InitLoginResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.init_login_resp)
  return init_login_resp_;
}
inline ::qihoo::protocol::messages::InitLoginResp* Response::release_init_login_resp() {
  clear_has_init_login_resp();
  ::qihoo::protocol::messages::InitLoginResp* temp = init_login_resp_;
  init_login_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_init_login_resp(::qihoo::protocol::messages::InitLoginResp* init_login_resp) {
  delete init_login_resp_;
  init_login_resp_ = init_login_resp;
  if (init_login_resp) {
    set_has_init_login_resp();
  } else {
    clear_has_init_login_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.init_login_resp)
}

// optional .qihoo.protocol.messages.Service_Resp service_resp = 12;
inline bool Response::has_service_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_service_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_service_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_service_resp() {
  if (service_resp_ != NULL) service_resp_->::qihoo::protocol::messages::Service_Resp::Clear();
  clear_has_service_resp();
}
inline const ::qihoo::protocol::messages::Service_Resp& Response::service_resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.service_resp)
  return service_resp_ != NULL ? *service_resp_ : *default_instance_->service_resp_;
}
inline ::qihoo::protocol::messages::Service_Resp* Response::mutable_service_resp() {
  set_has_service_resp();
  if (service_resp_ == NULL) service_resp_ = new ::qihoo::protocol::messages::Service_Resp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.service_resp)
  return service_resp_;
}
inline ::qihoo::protocol::messages::Service_Resp* Response::release_service_resp() {
  clear_has_service_resp();
  ::qihoo::protocol::messages::Service_Resp* temp = service_resp_;
  service_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_service_resp(::qihoo::protocol::messages::Service_Resp* service_resp) {
  delete service_resp_;
  service_resp_ = service_resp;
  if (service_resp) {
    set_has_service_resp();
  } else {
    clear_has_service_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.service_resp)
}

// optional .qihoo.protocol.messages.Ex1QueryUserStatusResp e1_query_user = 13;
inline bool Response::has_e1_query_user() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_e1_query_user() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_e1_query_user() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_e1_query_user() {
  if (e1_query_user_ != NULL) e1_query_user_->::qihoo::protocol::messages::Ex1QueryUserStatusResp::Clear();
  clear_has_e1_query_user();
}
inline const ::qihoo::protocol::messages::Ex1QueryUserStatusResp& Response::e1_query_user() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.e1_query_user)
  return e1_query_user_ != NULL ? *e1_query_user_ : *default_instance_->e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* Response::mutable_e1_query_user() {
  set_has_e1_query_user();
  if (e1_query_user_ == NULL) e1_query_user_ = new ::qihoo::protocol::messages::Ex1QueryUserStatusResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.e1_query_user)
  return e1_query_user_;
}
inline ::qihoo::protocol::messages::Ex1QueryUserStatusResp* Response::release_e1_query_user() {
  clear_has_e1_query_user();
  ::qihoo::protocol::messages::Ex1QueryUserStatusResp* temp = e1_query_user_;
  e1_query_user_ = NULL;
  return temp;
}
inline void Response::set_allocated_e1_query_user(::qihoo::protocol::messages::Ex1QueryUserStatusResp* e1_query_user) {
  delete e1_query_user_;
  e1_query_user_ = e1_query_user;
  if (e1_query_user) {
    set_has_e1_query_user();
  } else {
    clear_has_e1_query_user();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.e1_query_user)
}

// optional .qihoo.protocol.messages.GetMultiInfosResp get_multi_infos = 100;
inline bool Response::has_get_multi_infos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_get_multi_infos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_get_multi_infos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_get_multi_infos() {
  if (get_multi_infos_ != NULL) get_multi_infos_->::qihoo::protocol::messages::GetMultiInfosResp::Clear();
  clear_has_get_multi_infos();
}
inline const ::qihoo::protocol::messages::GetMultiInfosResp& Response::get_multi_infos() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Response.get_multi_infos)
  return get_multi_infos_ != NULL ? *get_multi_infos_ : *default_instance_->get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosResp* Response::mutable_get_multi_infos() {
  set_has_get_multi_infos();
  if (get_multi_infos_ == NULL) get_multi_infos_ = new ::qihoo::protocol::messages::GetMultiInfosResp;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Response.get_multi_infos)
  return get_multi_infos_;
}
inline ::qihoo::protocol::messages::GetMultiInfosResp* Response::release_get_multi_infos() {
  clear_has_get_multi_infos();
  ::qihoo::protocol::messages::GetMultiInfosResp* temp = get_multi_infos_;
  get_multi_infos_ = NULL;
  return temp;
}
inline void Response::set_allocated_get_multi_infos(::qihoo::protocol::messages::GetMultiInfosResp* get_multi_infos) {
  delete get_multi_infos_;
  get_multi_infos_ = get_multi_infos;
  if (get_multi_infos) {
    set_has_get_multi_infos();
  } else {
    clear_has_get_multi_infos();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Response.get_multi_infos)
}

// -------------------------------------------------------------------

// NewMessageNotify

// required string info_type = 1;
inline bool NewMessageNotify::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewMessageNotify::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewMessageNotify::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewMessageNotify::clear_info_type() {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_->clear();
  }
  clear_has_info_type();
}
inline const ::std::string& NewMessageNotify::info_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_type)
  return *info_type_;
}
inline void NewMessageNotify::set_info_type(const ::std::string& value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_type)
}
inline void NewMessageNotify::set_info_type(const char* value) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.NewMessageNotify.info_type)
}
inline void NewMessageNotify::set_info_type(const char* value, size_t size) {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  info_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.NewMessageNotify.info_type)
}
inline ::std::string* NewMessageNotify::mutable_info_type() {
  set_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.NewMessageNotify.info_type)
  return info_type_;
}
inline ::std::string* NewMessageNotify::release_info_type() {
  clear_has_info_type();
  if (info_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_type_;
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewMessageNotify::set_allocated_info_type(::std::string* info_type) {
  if (info_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_type_;
  }
  if (info_type) {
    set_has_info_type();
    info_type_ = info_type;
  } else {
    clear_has_info_type();
    info_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.NewMessageNotify.info_type)
}

// optional bytes info_content = 2;
inline bool NewMessageNotify::has_info_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewMessageNotify::set_has_info_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewMessageNotify::clear_has_info_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewMessageNotify::clear_info_content() {
  if (info_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_content_->clear();
  }
  clear_has_info_content();
}
inline const ::std::string& NewMessageNotify::info_content() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_content)
  return *info_content_;
}
inline void NewMessageNotify::set_info_content(const ::std::string& value) {
  set_has_info_content();
  if (info_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_content_ = new ::std::string;
  }
  info_content_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_content)
}
inline void NewMessageNotify::set_info_content(const char* value) {
  set_has_info_content();
  if (info_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_content_ = new ::std::string;
  }
  info_content_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.NewMessageNotify.info_content)
}
inline void NewMessageNotify::set_info_content(const void* value, size_t size) {
  set_has_info_content();
  if (info_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_content_ = new ::std::string;
  }
  info_content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.NewMessageNotify.info_content)
}
inline ::std::string* NewMessageNotify::mutable_info_content() {
  set_has_info_content();
  if (info_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.NewMessageNotify.info_content)
  return info_content_;
}
inline ::std::string* NewMessageNotify::release_info_content() {
  clear_has_info_content();
  if (info_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_content_;
    info_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NewMessageNotify::set_allocated_info_content(::std::string* info_content) {
  if (info_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_content_;
  }
  if (info_content) {
    set_has_info_content();
    info_content_ = info_content;
  } else {
    clear_has_info_content();
    info_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.NewMessageNotify.info_content)
}

// optional int64 info_id = 3;
inline bool NewMessageNotify::has_info_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewMessageNotify::set_has_info_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewMessageNotify::clear_has_info_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewMessageNotify::clear_info_id() {
  info_id_ = GOOGLE_LONGLONG(0);
  clear_has_info_id();
}
inline ::google::protobuf::int64 NewMessageNotify::info_id() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.info_id)
  return info_id_;
}
inline void NewMessageNotify::set_info_id(::google::protobuf::int64 value) {
  set_has_info_id();
  info_id_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.info_id)
}

// optional uint32 query_after_seconds = 4;
inline bool NewMessageNotify::has_query_after_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewMessageNotify::set_has_query_after_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewMessageNotify::clear_has_query_after_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewMessageNotify::clear_query_after_seconds() {
  query_after_seconds_ = 0u;
  clear_has_query_after_seconds();
}
inline ::google::protobuf::uint32 NewMessageNotify::query_after_seconds() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.NewMessageNotify.query_after_seconds)
  return query_after_seconds_;
}
inline void NewMessageNotify::set_query_after_seconds(::google::protobuf::uint32 value) {
  set_has_query_after_seconds();
  query_after_seconds_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.NewMessageNotify.query_after_seconds)
}

// -------------------------------------------------------------------

// ReLoginNotify

// optional string new_ip = 1;
inline bool ReLoginNotify::has_new_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReLoginNotify::set_has_new_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReLoginNotify::clear_has_new_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReLoginNotify::clear_new_ip() {
  if (new_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_ip_->clear();
  }
  clear_has_new_ip();
}
inline const ::std::string& ReLoginNotify::new_ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReLoginNotify.new_ip)
  return *new_ip_;
}
inline void ReLoginNotify::set_new_ip(const ::std::string& value) {
  set_has_new_ip();
  if (new_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_ip_ = new ::std::string;
  }
  new_ip_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
inline void ReLoginNotify::set_new_ip(const char* value) {
  set_has_new_ip();
  if (new_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_ip_ = new ::std::string;
  }
  new_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
inline void ReLoginNotify::set_new_ip(const char* value, size_t size) {
  set_has_new_ip();
  if (new_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_ip_ = new ::std::string;
  }
  new_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReLoginNotify.new_ip)
}
inline ::std::string* ReLoginNotify::mutable_new_ip() {
  set_has_new_ip();
  if (new_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReLoginNotify.new_ip)
  return new_ip_;
}
inline ::std::string* ReLoginNotify::release_new_ip() {
  clear_has_new_ip();
  if (new_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_ip_;
    new_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReLoginNotify::set_allocated_new_ip(::std::string* new_ip) {
  if (new_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_ip_;
  }
  if (new_ip) {
    set_has_new_ip();
    new_ip_ = new_ip;
  } else {
    clear_has_new_ip();
    new_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReLoginNotify.new_ip)
}

// -------------------------------------------------------------------

// ReConnectNotify

// optional string ip = 1;
inline bool ReConnectNotify::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReConnectNotify::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReConnectNotify::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReConnectNotify::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ReConnectNotify::ip() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.ip)
  return *ip_;
}
inline void ReConnectNotify::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.ip)
}
inline void ReConnectNotify::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReConnectNotify.ip)
}
inline void ReConnectNotify::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReConnectNotify.ip)
}
inline ::std::string* ReConnectNotify::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReConnectNotify.ip)
  return ip_;
}
inline ::std::string* ReConnectNotify::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ReConnectNotify::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.ReConnectNotify.ip)
}

// optional uint32 port = 2;
inline bool ReConnectNotify::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReConnectNotify::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReConnectNotify::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReConnectNotify::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ReConnectNotify::port() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.port)
  return port_;
}
inline void ReConnectNotify::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.port)
}

// repeated string more_ips = 3;
inline int ReConnectNotify::more_ips_size() const {
  return more_ips_.size();
}
inline void ReConnectNotify::clear_more_ips() {
  more_ips_.Clear();
}
inline const ::std::string& ReConnectNotify::more_ips(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_.Get(index);
}
inline ::std::string* ReConnectNotify::mutable_more_ips(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_.Mutable(index);
}
inline void ReConnectNotify::set_more_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.ReConnectNotify.more_ips)
  more_ips_.Mutable(index)->assign(value);
}
inline void ReConnectNotify::set_more_ips(int index, const char* value) {
  more_ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline void ReConnectNotify::set_more_ips(int index, const char* value, size_t size) {
  more_ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline ::std::string* ReConnectNotify::add_more_ips() {
  return more_ips_.Add();
}
inline void ReConnectNotify::add_more_ips(const ::std::string& value) {
  more_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline void ReConnectNotify::add_more_ips(const char* value) {
  more_ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline void ReConnectNotify::add_more_ips(const char* value, size_t size) {
  more_ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:qihoo.protocol.messages.ReConnectNotify.more_ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReConnectNotify::more_ips() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return more_ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReConnectNotify::mutable_more_ips() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.ReConnectNotify.more_ips)
  return &more_ips_;
}

// -------------------------------------------------------------------

// Notify

// optional .qihoo.protocol.messages.NewMessageNotify newinfo_ntf = 1;
inline bool Notify::has_newinfo_ntf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notify::set_has_newinfo_ntf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notify::clear_has_newinfo_ntf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notify::clear_newinfo_ntf() {
  if (newinfo_ntf_ != NULL) newinfo_ntf_->::qihoo::protocol::messages::NewMessageNotify::Clear();
  clear_has_newinfo_ntf();
}
inline const ::qihoo::protocol::messages::NewMessageNotify& Notify::newinfo_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.newinfo_ntf)
  return newinfo_ntf_ != NULL ? *newinfo_ntf_ : *default_instance_->newinfo_ntf_;
}
inline ::qihoo::protocol::messages::NewMessageNotify* Notify::mutable_newinfo_ntf() {
  set_has_newinfo_ntf();
  if (newinfo_ntf_ == NULL) newinfo_ntf_ = new ::qihoo::protocol::messages::NewMessageNotify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.newinfo_ntf)
  return newinfo_ntf_;
}
inline ::qihoo::protocol::messages::NewMessageNotify* Notify::release_newinfo_ntf() {
  clear_has_newinfo_ntf();
  ::qihoo::protocol::messages::NewMessageNotify* temp = newinfo_ntf_;
  newinfo_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_newinfo_ntf(::qihoo::protocol::messages::NewMessageNotify* newinfo_ntf) {
  delete newinfo_ntf_;
  newinfo_ntf_ = newinfo_ntf;
  if (newinfo_ntf) {
    set_has_newinfo_ntf();
  } else {
    clear_has_newinfo_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.newinfo_ntf)
}

// optional .qihoo.protocol.messages.ReLoginNotify relogin_ntf = 2;
inline bool Notify::has_relogin_ntf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notify::set_has_relogin_ntf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notify::clear_has_relogin_ntf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notify::clear_relogin_ntf() {
  if (relogin_ntf_ != NULL) relogin_ntf_->::qihoo::protocol::messages::ReLoginNotify::Clear();
  clear_has_relogin_ntf();
}
inline const ::qihoo::protocol::messages::ReLoginNotify& Notify::relogin_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.relogin_ntf)
  return relogin_ntf_ != NULL ? *relogin_ntf_ : *default_instance_->relogin_ntf_;
}
inline ::qihoo::protocol::messages::ReLoginNotify* Notify::mutable_relogin_ntf() {
  set_has_relogin_ntf();
  if (relogin_ntf_ == NULL) relogin_ntf_ = new ::qihoo::protocol::messages::ReLoginNotify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.relogin_ntf)
  return relogin_ntf_;
}
inline ::qihoo::protocol::messages::ReLoginNotify* Notify::release_relogin_ntf() {
  clear_has_relogin_ntf();
  ::qihoo::protocol::messages::ReLoginNotify* temp = relogin_ntf_;
  relogin_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_relogin_ntf(::qihoo::protocol::messages::ReLoginNotify* relogin_ntf) {
  delete relogin_ntf_;
  relogin_ntf_ = relogin_ntf;
  if (relogin_ntf) {
    set_has_relogin_ntf();
  } else {
    clear_has_relogin_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.relogin_ntf)
}

// optional .qihoo.protocol.messages.ReConnectNotify reconnect_ntf = 3;
inline bool Notify::has_reconnect_ntf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notify::set_has_reconnect_ntf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notify::clear_has_reconnect_ntf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notify::clear_reconnect_ntf() {
  if (reconnect_ntf_ != NULL) reconnect_ntf_->::qihoo::protocol::messages::ReConnectNotify::Clear();
  clear_has_reconnect_ntf();
}
inline const ::qihoo::protocol::messages::ReConnectNotify& Notify::reconnect_ntf() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Notify.reconnect_ntf)
  return reconnect_ntf_ != NULL ? *reconnect_ntf_ : *default_instance_->reconnect_ntf_;
}
inline ::qihoo::protocol::messages::ReConnectNotify* Notify::mutable_reconnect_ntf() {
  set_has_reconnect_ntf();
  if (reconnect_ntf_ == NULL) reconnect_ntf_ = new ::qihoo::protocol::messages::ReConnectNotify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Notify.reconnect_ntf)
  return reconnect_ntf_;
}
inline ::qihoo::protocol::messages::ReConnectNotify* Notify::release_reconnect_ntf() {
  clear_has_reconnect_ntf();
  ::qihoo::protocol::messages::ReConnectNotify* temp = reconnect_ntf_;
  reconnect_ntf_ = NULL;
  return temp;
}
inline void Notify::set_allocated_reconnect_ntf(::qihoo::protocol::messages::ReConnectNotify* reconnect_ntf) {
  delete reconnect_ntf_;
  reconnect_ntf_ = reconnect_ntf;
  if (reconnect_ntf) {
    set_has_reconnect_ntf();
  } else {
    clear_has_reconnect_ntf();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Notify.reconnect_ntf)
}

// -------------------------------------------------------------------

// Ack

// required uint32 result = 1;
inline bool Ack::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ack::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ack::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ack::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 Ack::result() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Ack.result)
  return result_;
}
inline void Ack::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Ack.result)
}

// -------------------------------------------------------------------

// RouteInfo

// required bytes username = 1;
inline bool RouteInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& RouteInfo::username() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.username)
  return *username_;
}
inline void RouteInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.username)
}
inline void RouteInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.username)
}
inline void RouteInfo::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.username)
}
inline ::std::string* RouteInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.username)
  return username_;
}
inline ::std::string* RouteInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RouteInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.username)
}

// required string msg_exchanger = 2;
inline bool RouteInfo::has_msg_exchanger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteInfo::set_has_msg_exchanger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteInfo::clear_has_msg_exchanger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteInfo::clear_msg_exchanger() {
  if (msg_exchanger_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_exchanger_->clear();
  }
  clear_has_msg_exchanger();
}
inline const ::std::string& RouteInfo::msg_exchanger() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.msg_exchanger)
  return *msg_exchanger_;
}
inline void RouteInfo::set_msg_exchanger(const ::std::string& value) {
  set_has_msg_exchanger();
  if (msg_exchanger_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_exchanger_ = new ::std::string;
  }
  msg_exchanger_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
inline void RouteInfo::set_msg_exchanger(const char* value) {
  set_has_msg_exchanger();
  if (msg_exchanger_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_exchanger_ = new ::std::string;
  }
  msg_exchanger_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
inline void RouteInfo::set_msg_exchanger(const char* value, size_t size) {
  set_has_msg_exchanger();
  if (msg_exchanger_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_exchanger_ = new ::std::string;
  }
  msg_exchanger_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}
inline ::std::string* RouteInfo::mutable_msg_exchanger() {
  set_has_msg_exchanger();
  if (msg_exchanger_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_exchanger_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.msg_exchanger)
  return msg_exchanger_;
}
inline ::std::string* RouteInfo::release_msg_exchanger() {
  clear_has_msg_exchanger();
  if (msg_exchanger_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_exchanger_;
    msg_exchanger_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RouteInfo::set_allocated_msg_exchanger(::std::string* msg_exchanger) {
  if (msg_exchanger_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_exchanger_;
  }
  if (msg_exchanger) {
    set_has_msg_exchanger();
    msg_exchanger_ = msg_exchanger;
  } else {
    clear_has_msg_exchanger();
    msg_exchanger_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.msg_exchanger)
}

// required string msg_router = 3;
inline bool RouteInfo::has_msg_router() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteInfo::set_has_msg_router() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteInfo::clear_has_msg_router() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteInfo::clear_msg_router() {
  if (msg_router_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_router_->clear();
  }
  clear_has_msg_router();
}
inline const ::std::string& RouteInfo::msg_router() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.RouteInfo.msg_router)
  return *msg_router_;
}
inline void RouteInfo::set_msg_router(const ::std::string& value) {
  set_has_msg_router();
  if (msg_router_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_router_ = new ::std::string;
  }
  msg_router_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.RouteInfo.msg_router)
}
inline void RouteInfo::set_msg_router(const char* value) {
  set_has_msg_router();
  if (msg_router_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_router_ = new ::std::string;
  }
  msg_router_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.RouteInfo.msg_router)
}
inline void RouteInfo::set_msg_router(const char* value, size_t size) {
  set_has_msg_router();
  if (msg_router_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_router_ = new ::std::string;
  }
  msg_router_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.RouteInfo.msg_router)
}
inline ::std::string* RouteInfo::mutable_msg_router() {
  set_has_msg_router();
  if (msg_router_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_router_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.RouteInfo.msg_router)
  return msg_router_;
}
inline ::std::string* RouteInfo::release_msg_router() {
  clear_has_msg_router();
  if (msg_router_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_router_;
    msg_router_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RouteInfo::set_allocated_msg_router(::std::string* msg_router) {
  if (msg_router_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_router_;
  }
  if (msg_router) {
    set_has_msg_router();
    msg_router_ = msg_router;
  } else {
    clear_has_msg_router();
    msg_router_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.RouteInfo.msg_router)
}

// -------------------------------------------------------------------

// Proxy

// required string sender = 1;
inline bool Proxy::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Proxy::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Proxy::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Proxy::clear_sender() {
  if (sender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Proxy::sender() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Proxy.sender)
  return *sender_;
}
inline void Proxy::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Proxy.sender)
}
inline void Proxy::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Proxy.sender)
}
inline void Proxy::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Proxy.sender)
}
inline ::std::string* Proxy::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Proxy.sender)
  return sender_;
}
inline ::std::string* Proxy::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Proxy::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Proxy.sender)
}

// repeated .qihoo.protocol.messages.RouteInfo receiver = 2;
inline int Proxy::receiver_size() const {
  return receiver_.size();
}
inline void Proxy::clear_receiver() {
  receiver_.Clear();
}
inline const ::qihoo::protocol::messages::RouteInfo& Proxy::receiver(int index) const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Get(index);
}
inline ::qihoo::protocol::messages::RouteInfo* Proxy::mutable_receiver(int index) {
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Mutable(index);
}
inline ::qihoo::protocol::messages::RouteInfo* Proxy::add_receiver() {
  // @@protoc_insertion_point(field_add:qihoo.protocol.messages.Proxy.receiver)
  return receiver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >&
Proxy::receiver() const {
  // @@protoc_insertion_point(field_list:qihoo.protocol.messages.Proxy.receiver)
  return receiver_;
}
inline ::google::protobuf::RepeatedPtrField< ::qihoo::protocol::messages::RouteInfo >*
Proxy::mutable_receiver() {
  // @@protoc_insertion_point(field_mutable_list:qihoo.protocol.messages.Proxy.receiver)
  return &receiver_;
}

// -------------------------------------------------------------------

// Message

// required uint32 msgid = 1;
inline bool Message::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msgid() {
  msgid_ = 0u;
  clear_has_msgid();
}
inline ::google::protobuf::uint32 Message::msgid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.msgid)
  return msgid_;
}
inline void Message::set_msgid(::google::protobuf::uint32 value) {
  set_has_msgid();
  msgid_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.msgid)
}

// required uint64 sn = 2;
inline bool Message::has_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sn() {
  sn_ = GOOGLE_ULONGLONG(0);
  clear_has_sn();
}
inline ::google::protobuf::uint64 Message::sn() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sn)
  return sn_;
}
inline void Message::set_sn(::google::protobuf::uint64 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sn)
}

// optional string sender = 3;
inline bool Message::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_sender() {
  if (sender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Message::sender() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender)
  return *sender_;
}
inline void Message::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender)
}
inline void Message::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender)
}
inline void Message::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender)
}
inline ::std::string* Message::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender)
  return sender_;
}
inline ::std::string* Message::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender)
}

// optional string receiver = 4;
inline bool Message::has_receiver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_receiver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& Message::receiver() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.receiver)
  return *receiver_;
}
inline void Message::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.receiver)
}
inline void Message::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.receiver)
}
inline void Message::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.receiver)
}
inline ::std::string* Message::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.receiver)
  return receiver_;
}
inline ::std::string* Message::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.receiver)
}

// optional string receiver_type = 5;
inline bool Message::has_receiver_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_receiver_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_receiver_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_receiver_type() {
  if (receiver_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_type_->clear();
  }
  clear_has_receiver_type();
}
inline const ::std::string& Message::receiver_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.receiver_type)
  return *receiver_type_;
}
inline void Message::set_receiver_type(const ::std::string& value) {
  set_has_receiver_type();
  if (receiver_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_type_ = new ::std::string;
  }
  receiver_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.receiver_type)
}
inline void Message::set_receiver_type(const char* value) {
  set_has_receiver_type();
  if (receiver_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_type_ = new ::std::string;
  }
  receiver_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.receiver_type)
}
inline void Message::set_receiver_type(const char* value, size_t size) {
  set_has_receiver_type();
  if (receiver_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_type_ = new ::std::string;
  }
  receiver_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.receiver_type)
}
inline ::std::string* Message::mutable_receiver_type() {
  set_has_receiver_type();
  if (receiver_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    receiver_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.receiver_type)
  return receiver_type_;
}
inline ::std::string* Message::release_receiver_type() {
  clear_has_receiver_type();
  if (receiver_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = receiver_type_;
    receiver_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_receiver_type(::std::string* receiver_type) {
  if (receiver_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete receiver_type_;
  }
  if (receiver_type) {
    set_has_receiver_type();
    receiver_type_ = receiver_type;
  } else {
    clear_has_receiver_type();
    receiver_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.receiver_type)
}

// optional .qihoo.protocol.messages.Request req = 6;
inline bool Message::has_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_req() {
  if (req_ != NULL) req_->::qihoo::protocol::messages::Request::Clear();
  clear_has_req();
}
inline const ::qihoo::protocol::messages::Request& Message::req() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.req)
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::qihoo::protocol::messages::Request* Message::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::qihoo::protocol::messages::Request;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.req)
  return req_;
}
inline ::qihoo::protocol::messages::Request* Message::release_req() {
  clear_has_req();
  ::qihoo::protocol::messages::Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Message::set_allocated_req(::qihoo::protocol::messages::Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.req)
}

// optional .qihoo.protocol.messages.Response resp = 7;
inline bool Message::has_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_resp() {
  if (resp_ != NULL) resp_->::qihoo::protocol::messages::Response::Clear();
  clear_has_resp();
}
inline const ::qihoo::protocol::messages::Response& Message::resp() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.resp)
  return resp_ != NULL ? *resp_ : *default_instance_->resp_;
}
inline ::qihoo::protocol::messages::Response* Message::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) resp_ = new ::qihoo::protocol::messages::Response;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.resp)
  return resp_;
}
inline ::qihoo::protocol::messages::Response* Message::release_resp() {
  clear_has_resp();
  ::qihoo::protocol::messages::Response* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline void Message::set_allocated_resp(::qihoo::protocol::messages::Response* resp) {
  delete resp_;
  resp_ = resp;
  if (resp) {
    set_has_resp();
  } else {
    clear_has_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.resp)
}

// optional .qihoo.protocol.messages.Notify notify = 8;
inline bool Message::has_notify() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_notify() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_notify() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_notify() {
  if (notify_ != NULL) notify_->::qihoo::protocol::messages::Notify::Clear();
  clear_has_notify();
}
inline const ::qihoo::protocol::messages::Notify& Message::notify() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.notify)
  return notify_ != NULL ? *notify_ : *default_instance_->notify_;
}
inline ::qihoo::protocol::messages::Notify* Message::mutable_notify() {
  set_has_notify();
  if (notify_ == NULL) notify_ = new ::qihoo::protocol::messages::Notify;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.notify)
  return notify_;
}
inline ::qihoo::protocol::messages::Notify* Message::release_notify() {
  clear_has_notify();
  ::qihoo::protocol::messages::Notify* temp = notify_;
  notify_ = NULL;
  return temp;
}
inline void Message::set_allocated_notify(::qihoo::protocol::messages::Notify* notify) {
  delete notify_;
  notify_ = notify;
  if (notify) {
    set_has_notify();
  } else {
    clear_has_notify();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.notify)
}

// optional .qihoo.protocol.messages.Ack ack = 9;
inline bool Message::has_ack() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_ack() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_ack() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_ack() {
  if (ack_ != NULL) ack_->::qihoo::protocol::messages::Ack::Clear();
  clear_has_ack();
}
inline const ::qihoo::protocol::messages::Ack& Message::ack() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.ack)
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::qihoo::protocol::messages::Ack* Message::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::qihoo::protocol::messages::Ack;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.ack)
  return ack_;
}
inline ::qihoo::protocol::messages::Ack* Message::release_ack() {
  clear_has_ack();
  ::qihoo::protocol::messages::Ack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void Message::set_allocated_ack(::qihoo::protocol::messages::Ack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.ack)
}

// optional .qihoo.protocol.messages.Proxy proxy_mesg = 10;
inline bool Message::has_proxy_mesg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_proxy_mesg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_proxy_mesg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_proxy_mesg() {
  if (proxy_mesg_ != NULL) proxy_mesg_->::qihoo::protocol::messages::Proxy::Clear();
  clear_has_proxy_mesg();
}
inline const ::qihoo::protocol::messages::Proxy& Message::proxy_mesg() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.proxy_mesg)
  return proxy_mesg_ != NULL ? *proxy_mesg_ : *default_instance_->proxy_mesg_;
}
inline ::qihoo::protocol::messages::Proxy* Message::mutable_proxy_mesg() {
  set_has_proxy_mesg();
  if (proxy_mesg_ == NULL) proxy_mesg_ = new ::qihoo::protocol::messages::Proxy;
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.proxy_mesg)
  return proxy_mesg_;
}
inline ::qihoo::protocol::messages::Proxy* Message::release_proxy_mesg() {
  clear_has_proxy_mesg();
  ::qihoo::protocol::messages::Proxy* temp = proxy_mesg_;
  proxy_mesg_ = NULL;
  return temp;
}
inline void Message::set_allocated_proxy_mesg(::qihoo::protocol::messages::Proxy* proxy_mesg) {
  delete proxy_mesg_;
  proxy_mesg_ = proxy_mesg;
  if (proxy_mesg) {
    set_has_proxy_mesg();
  } else {
    clear_has_proxy_mesg();
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.proxy_mesg)
}

// optional uint64 client_data = 11;
inline bool Message::has_client_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_client_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_client_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_client_data() {
  client_data_ = GOOGLE_ULONGLONG(0);
  clear_has_client_data();
}
inline ::google::protobuf::uint64 Message::client_data() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.client_data)
  return client_data_;
}
inline void Message::set_client_data(::google::protobuf::uint64 value) {
  set_has_client_data();
  client_data_ = value;
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.client_data)
}

// optional string sender_type = 12;
inline bool Message::has_sender_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_sender_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_sender_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_sender_type() {
  if (sender_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_type_->clear();
  }
  clear_has_sender_type();
}
inline const ::std::string& Message::sender_type() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender_type)
  return *sender_type_;
}
inline void Message::set_sender_type(const ::std::string& value) {
  set_has_sender_type();
  if (sender_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_type_ = new ::std::string;
  }
  sender_type_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender_type)
}
inline void Message::set_sender_type(const char* value) {
  set_has_sender_type();
  if (sender_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_type_ = new ::std::string;
  }
  sender_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender_type)
}
inline void Message::set_sender_type(const char* value, size_t size) {
  set_has_sender_type();
  if (sender_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_type_ = new ::std::string;
  }
  sender_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender_type)
}
inline ::std::string* Message::mutable_sender_type() {
  set_has_sender_type();
  if (sender_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender_type)
  return sender_type_;
}
inline ::std::string* Message::release_sender_type() {
  clear_has_sender_type();
  if (sender_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sender_type_;
    sender_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_sender_type(::std::string* sender_type) {
  if (sender_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sender_type_;
  }
  if (sender_type) {
    set_has_sender_type();
    sender_type_ = sender_type;
  } else {
    clear_has_sender_type();
    sender_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender_type)
}

// optional string sender_jid = 13;
inline bool Message::has_sender_jid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_sender_jid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_sender_jid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_sender_jid() {
  if (sender_jid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_jid_->clear();
  }
  clear_has_sender_jid();
}
inline const ::std::string& Message::sender_jid() const {
  // @@protoc_insertion_point(field_get:qihoo.protocol.messages.Message.sender_jid)
  return *sender_jid_;
}
inline void Message::set_sender_jid(const ::std::string& value) {
  set_has_sender_jid();
  if (sender_jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_jid_ = new ::std::string;
  }
  sender_jid_->assign(value);
  // @@protoc_insertion_point(field_set:qihoo.protocol.messages.Message.sender_jid)
}
inline void Message::set_sender_jid(const char* value) {
  set_has_sender_jid();
  if (sender_jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_jid_ = new ::std::string;
  }
  sender_jid_->assign(value);
  // @@protoc_insertion_point(field_set_char:qihoo.protocol.messages.Message.sender_jid)
}
inline void Message::set_sender_jid(const char* value, size_t size) {
  set_has_sender_jid();
  if (sender_jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_jid_ = new ::std::string;
  }
  sender_jid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:qihoo.protocol.messages.Message.sender_jid)
}
inline ::std::string* Message::mutable_sender_jid() {
  set_has_sender_jid();
  if (sender_jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sender_jid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:qihoo.protocol.messages.Message.sender_jid)
  return sender_jid_;
}
inline ::std::string* Message::release_sender_jid() {
  clear_has_sender_jid();
  if (sender_jid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sender_jid_;
    sender_jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_sender_jid(::std::string* sender_jid) {
  if (sender_jid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sender_jid_;
  }
  if (sender_jid) {
    set_has_sender_jid();
    sender_jid_ = sender_jid;
  } else {
    clear_has_sender_jid();
    sender_jid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:qihoo.protocol.messages.Message.sender_jid)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace protocol
}  // namespace qihoo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_address_5fbook_2eproto__INCLUDED
