/*eslint-disable*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const qihoo = $root.qihoo = (() => {

    /**
     * Namespace qihoo.
     * @exports qihoo
     * @namespace
     */
    const qihoo = {};

    qihoo.protocol = (function () {

        /**
         * Namespace protocol.
         * @memberof qihoo
         * @namespace
         */
        const protocol = {};

        protocol.chatroom = (function () {

            /**
             * Namespace chatroom.
             * @memberof qihoo.protocol
             * @namespace
             */
            const chatroom = {};

            chatroom.CRPair = (function () {

                /**
                 * Properties of a CRPair.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICRPair
                 * @property {string} key CRPair key
                 * @property {Uint8Array|null} [value] CRPair value
                 */

                /**
                 * Constructs a new CRPair.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CRPair.
                 * @implements ICRPair
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICRPair=} [properties] Properties to set
                 */
                function CRPair(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CRPair key.
                 * @member {string} key
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @instance
                 */
                CRPair.prototype.key = "";

                /**
                 * CRPair value.
                 * @member {Uint8Array} value
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @instance
                 */
                CRPair.prototype.value = $util.newBuffer([]);

                /**
                 * Creates a new CRPair instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRPair=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CRPair} CRPair instance
                 */
                CRPair.create = function create(properties) {
                    return new CRPair(properties);
                };

                /**
                 * Encodes the specified CRPair message. Does not implicitly {@link qihoo.protocol.chatroom.CRPair.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRPair} message CRPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CRPair.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if(message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified CRPair message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CRPair.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRPair} message CRPair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CRPair.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CRPair message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CRPair} CRPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CRPair.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CRPair();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.key = reader.string();
                                break;
                            case 2:
                                message.value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("key"))
                        throw $util.ProtocolError("missing required 'key'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a CRPair message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CRPair} CRPair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CRPair.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CRPair message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CRPair.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.key))
                        return "key: string expected";
                    if(message.value != null && message.hasOwnProperty("value"))
                        if(!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };

                /**
                 * Creates a CRPair message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CRPair} CRPair
                 */
                CRPair.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CRPair)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CRPair();
                    if(object.key != null)
                        message.key = String(object.key);
                    if(object.value != null)
                        if(typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if(object.value.length)
                            message.value = object.value;
                    return message;
                };

                /**
                 * Creates a plain object from a CRPair message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @static
                 * @param {qihoo.protocol.chatroom.CRPair} message CRPair
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CRPair.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.key = "";
                        if(options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if(options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if(message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if(message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };

                /**
                 * Converts this CRPair to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CRPair
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CRPair.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CRPair;
            })();

            chatroom.CRUser = (function () {

                /**
                 * Properties of a CRUser.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICRUser
                 * @property {Uint8Array|null} [userid] CRUser userid
                 * @property {string|null} [name] CRUser name
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [publicsetting] CRUser publicsetting
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [privatesetting] CRUser privatesetting
                 * @property {number|null} [status] CRUser status
                 * @property {Uint8Array|null} [userdata] CRUser userdata
                 */

                /**
                 * Constructs a new CRUser.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CRUser.
                 * @implements ICRUser
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICRUser=} [properties] Properties to set
                 */
                function CRUser(properties) {
                    this.publicsetting = [];
                    this.privatesetting = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CRUser userid.
                 * @member {Uint8Array} userid
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.userid = $util.newBuffer([]);

                /**
                 * CRUser name.
                 * @member {string} name
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.name = "";

                /**
                 * CRUser publicsetting.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} publicsetting
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.publicsetting = $util.emptyArray;

                /**
                 * CRUser privatesetting.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} privatesetting
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.privatesetting = $util.emptyArray;

                /**
                 * CRUser status.
                 * @member {number} status
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.status = 0;

                /**
                 * CRUser userdata.
                 * @member {Uint8Array} userdata
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 */
                CRUser.prototype.userdata = $util.newBuffer([]);

                /**
                 * Creates a new CRUser instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRUser=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CRUser} CRUser instance
                 */
                CRUser.create = function create(properties) {
                    return new CRUser(properties);
                };

                /**
                 * Encodes the specified CRUser message. Does not implicitly {@link qihoo.protocol.chatroom.CRUser.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRUser} message CRUser message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CRUser.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.userid);
                    if(message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if(message.publicsetting != null && message.publicsetting.length)
                        for(let i = 0; i < message.publicsetting.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.publicsetting[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.privatesetting != null && message.privatesetting.length)
                        for(let i = 0; i < message.privatesetting.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.privatesetting[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if(message.status != null && message.hasOwnProperty("status"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.status);
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.userdata);
                    return writer;
                };

                /**
                 * Encodes the specified CRUser message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CRUser.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {qihoo.protocol.chatroom.ICRUser} message CRUser message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CRUser.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CRUser message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CRUser} CRUser
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CRUser.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CRUser();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.userid = reader.bytes();
                                break;
                            case 2:
                                message.name = reader.string();
                                break;
                            case 3:
                                if(!(message.publicsetting && message.publicsetting.length))
                                    message.publicsetting = [];
                                message.publicsetting.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            case 4:
                                if(!(message.privatesetting && message.privatesetting.length))
                                    message.privatesetting = [];
                                message.privatesetting.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            case 5:
                                message.status = reader.int32();
                                break;
                            case 6:
                                message.userdata = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CRUser message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CRUser} CRUser
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CRUser.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CRUser message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CRUser.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        if(!(message.userid && typeof message.userid.length === "number" || $util.isString(message.userid)))
                            return "userid: buffer expected";
                    if(message.name != null && message.hasOwnProperty("name"))
                        if(!$util.isString(message.name))
                            return "name: string expected";
                    if(message.publicsetting != null && message.hasOwnProperty("publicsetting")) {
                        if(!Array.isArray(message.publicsetting))
                            return "publicsetting: array expected";
                        for(let i = 0; i < message.publicsetting.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.publicsetting[i]);
                            if(error)
                                return "publicsetting." + error;
                        }
                    }
                    if(message.privatesetting != null && message.hasOwnProperty("privatesetting")) {
                        if(!Array.isArray(message.privatesetting))
                            return "privatesetting: array expected";
                        for(let i = 0; i < message.privatesetting.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.privatesetting[i]);
                            if(error)
                                return "privatesetting." + error;
                        }
                    }
                    if(message.status != null && message.hasOwnProperty("status"))
                        if(!$util.isInteger(message.status))
                            return "status: integer expected";
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        if(!(message.userdata && typeof message.userdata.length === "number" || $util.isString(message.userdata)))
                            return "userdata: buffer expected";
                    return null;
                };

                /**
                 * Creates a CRUser message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CRUser} CRUser
                 */
                CRUser.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CRUser)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CRUser();
                    if(object.userid != null)
                        if(typeof object.userid === "string")
                            $util.base64.decode(object.userid, message.userid = $util.newBuffer($util.base64.length(object.userid)), 0);
                        else if(object.userid.length)
                            message.userid = object.userid;
                    if(object.name != null)
                        message.name = String(object.name);
                    if(object.publicsetting) {
                        if(!Array.isArray(object.publicsetting))
                            throw TypeError(".qihoo.protocol.chatroom.CRUser.publicsetting: array expected");
                        message.publicsetting = [];
                        for(let i = 0; i < object.publicsetting.length; ++i) {
                            if(typeof object.publicsetting[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CRUser.publicsetting: object expected");
                            message.publicsetting[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.publicsetting[i]);
                        }
                    }
                    if(object.privatesetting) {
                        if(!Array.isArray(object.privatesetting))
                            throw TypeError(".qihoo.protocol.chatroom.CRUser.privatesetting: array expected");
                        message.privatesetting = [];
                        for(let i = 0; i < object.privatesetting.length; ++i) {
                            if(typeof object.privatesetting[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CRUser.privatesetting: object expected");
                            message.privatesetting[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.privatesetting[i]);
                        }
                    }
                    if(object.status != null)
                        message.status = object.status | 0;
                    if(object.userdata != null)
                        if(typeof object.userdata === "string")
                            $util.base64.decode(object.userdata, message.userdata = $util.newBuffer($util.base64.length(object.userdata)), 0);
                        else if(object.userdata.length)
                            message.userdata = object.userdata;
                    return message;
                };

                /**
                 * Creates a plain object from a CRUser message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @static
                 * @param {qihoo.protocol.chatroom.CRUser} message CRUser
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CRUser.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults) {
                        object.publicsetting = [];
                        object.privatesetting = [];
                    }
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.userid = "";
                        else {
                            object.userid = [];
                            if(options.bytes !== Array)
                                object.userid = $util.newBuffer(object.userid);
                        }
                        object.name = "";
                        object.status = 0;
                        if(options.bytes === String)
                            object.userdata = "";
                        else {
                            object.userdata = [];
                            if(options.bytes !== Array)
                                object.userdata = $util.newBuffer(object.userdata);
                        }
                    }
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        object.userid = options.bytes === String ? $util.base64.encode(message.userid, 0, message.userid.length) : options.bytes === Array ? Array.prototype.slice.call(message.userid) : message.userid;
                    if(message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if(message.publicsetting && message.publicsetting.length) {
                        object.publicsetting = [];
                        for(let j = 0; j < message.publicsetting.length; ++j)
                            object.publicsetting[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.publicsetting[j], options);
                    }
                    if(message.privatesetting && message.privatesetting.length) {
                        object.privatesetting = [];
                        for(let j = 0; j < message.privatesetting.length; ++j)
                            object.privatesetting[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.privatesetting[j], options);
                    }
                    if(message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        object.userdata = options.bytes === String ? $util.base64.encode(message.userdata, 0, message.userdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.userdata) : message.userdata;
                    return object;
                };

                /**
                 * Converts this CRUser to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CRUser
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CRUser.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CRUser;
            })();

            chatroom.ChatRoom = (function () {

                /**
                 * Properties of a ChatRoom.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoom
                 * @property {Uint8Array} roomid ChatRoom roomid
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [creater] ChatRoom creater
                 * @property {string|null} [name] ChatRoom name
                 * @property {number|Long|null} [version] ChatRoom version
                 * @property {number|Long|null} [maxmsgid] ChatRoom maxmsgid
                 * @property {number|Long|null} [memcountlimit] ChatRoom memcountlimit
                 * @property {string|null} [roomtype] ChatRoom roomtype
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [properties] ChatRoom properties
                 * @property {Array.<qihoo.protocol.chatroom.ICRUser>|null} [members] ChatRoom members
                 * @property {Array.<Uint8Array>|null} [blacklist] ChatRoom blacklist
                 * @property {string|null} [gameid] ChatRoom gameid
                 * @property {Array.<qihoo.protocol.chatroom.ICRUser>|null} [tempmembers] ChatRoom tempmembers
                 * @property {Uint8Array|null} [partnerdata] ChatRoom partnerdata
                 */

                /**
                 * Constructs a new ChatRoom.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoom.
                 * @implements IChatRoom
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoom=} [properties] Properties to set
                 */
                function ChatRoom(properties) {
                    this.properties = [];
                    this.members = [];
                    this.blacklist = [];
                    this.tempmembers = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoom roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.roomid = $util.newBuffer([]);

                /**
                 * ChatRoom creater.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} creater
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.creater = null;

                /**
                 * ChatRoom name.
                 * @member {string} name
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.name = "";

                /**
                 * ChatRoom version.
                 * @member {number|Long} version
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * ChatRoom maxmsgid.
                 * @member {number|Long} maxmsgid
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.maxmsgid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * ChatRoom memcountlimit.
                 * @member {number|Long} memcountlimit
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.memcountlimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * ChatRoom roomtype.
                 * @member {string} roomtype
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.roomtype = "";

                /**
                 * ChatRoom properties.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} properties
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.properties = $util.emptyArray;

                /**
                 * ChatRoom members.
                 * @member {Array.<qihoo.protocol.chatroom.ICRUser>} members
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.members = $util.emptyArray;

                /**
                 * ChatRoom blacklist.
                 * @member {Array.<Uint8Array>} blacklist
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.blacklist = $util.emptyArray;

                /**
                 * ChatRoom gameid.
                 * @member {string} gameid
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.gameid = "";

                /**
                 * ChatRoom tempmembers.
                 * @member {Array.<qihoo.protocol.chatroom.ICRUser>} tempmembers
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.tempmembers = $util.emptyArray;

                /**
                 * ChatRoom partnerdata.
                 * @member {Uint8Array} partnerdata
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 */
                ChatRoom.prototype.partnerdata = $util.newBuffer([]);

                /**
                 * Creates a new ChatRoom instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoom=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoom} ChatRoom instance
                 */
                ChatRoom.create = function create(properties) {
                    return new ChatRoom(properties);
                };

                /**
                 * Encodes the specified ChatRoom message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoom.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoom} message ChatRoom message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoom.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.creater, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if(message.version != null && message.hasOwnProperty("version"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.version);
                    if(message.maxmsgid != null && message.hasOwnProperty("maxmsgid"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxmsgid);
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.memcountlimit);
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.roomtype);
                    if(message.properties != null && message.properties.length)
                        for(let i = 0; i < message.properties.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.properties[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if(message.members != null && message.members.length)
                        for(let i = 0; i < message.members.length; ++i)
                            $root.qihoo.protocol.chatroom.CRUser.encode(message.members[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.blacklist != null && message.blacklist.length)
                        for(let i = 0; i < message.blacklist.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.blacklist[i]);
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.gameid);
                    if(message.tempmembers != null && message.tempmembers.length)
                        for(let i = 0; i < message.tempmembers.length; ++i)
                            $root.qihoo.protocol.chatroom.CRUser.encode(message.tempmembers[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if(message.partnerdata != null && message.hasOwnProperty("partnerdata"))
                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.partnerdata);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoom message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoom.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoom} message ChatRoom message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoom.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoom message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoom} ChatRoom
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoom.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoom();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.creater = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.name = reader.string();
                                break;
                            case 4:
                                message.version = reader.uint64();
                                break;
                            case 5:
                                message.maxmsgid = reader.uint64();
                                break;
                            case 6:
                                message.memcountlimit = reader.uint64();
                                break;
                            case 7:
                                message.roomtype = reader.string();
                                break;
                            case 8:
                                if(!(message.properties && message.properties.length))
                                    message.properties = [];
                                message.properties.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            case 9:
                                if(!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32()));
                                break;
                            case 10:
                                if(!(message.blacklist && message.blacklist.length))
                                    message.blacklist = [];
                                message.blacklist.push(reader.bytes());
                                break;
                            case 11:
                                message.gameid = reader.string();
                                break;
                            case 12:
                                if(!(message.tempmembers && message.tempmembers.length))
                                    message.tempmembers = [];
                                message.tempmembers.push($root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32()));
                                break;
                            case 13:
                                message.partnerdata = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoom message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoom} ChatRoom
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoom.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoom message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoom.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.creater != null && message.hasOwnProperty("creater")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.creater);
                        if(error)
                            return "creater." + error;
                    }
                    if(message.name != null && message.hasOwnProperty("name"))
                        if(!$util.isString(message.name))
                            return "name: string expected";
                    if(message.version != null && message.hasOwnProperty("version"))
                        if(!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                            return "version: integer|Long expected";
                    if(message.maxmsgid != null && message.hasOwnProperty("maxmsgid"))
                        if(!$util.isInteger(message.maxmsgid) && !(message.maxmsgid && $util.isInteger(message.maxmsgid.low) && $util.isInteger(message.maxmsgid.high)))
                            return "maxmsgid: integer|Long expected";
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        if(!$util.isInteger(message.memcountlimit) && !(message.memcountlimit && $util.isInteger(message.memcountlimit.low) && $util.isInteger(message.memcountlimit.high)))
                            return "memcountlimit: integer|Long expected";
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        if(!$util.isString(message.roomtype))
                            return "roomtype: string expected";
                    if(message.properties != null && message.hasOwnProperty("properties")) {
                        if(!Array.isArray(message.properties))
                            return "properties: array expected";
                        for(let i = 0; i < message.properties.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.properties[i]);
                            if(error)
                                return "properties." + error;
                        }
                    }
                    if(message.members != null && message.hasOwnProperty("members")) {
                        if(!Array.isArray(message.members))
                            return "members: array expected";
                        for(let i = 0; i < message.members.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.members[i]);
                            if(error)
                                return "members." + error;
                        }
                    }
                    if(message.blacklist != null && message.hasOwnProperty("blacklist")) {
                        if(!Array.isArray(message.blacklist))
                            return "blacklist: array expected";
                        for(let i = 0; i < message.blacklist.length; ++i)
                            if(!(message.blacklist[i] && typeof message.blacklist[i].length === "number" || $util.isString(message.blacklist[i])))
                                return "blacklist: buffer[] expected";
                    }
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        if(!$util.isString(message.gameid))
                            return "gameid: string expected";
                    if(message.tempmembers != null && message.hasOwnProperty("tempmembers")) {
                        if(!Array.isArray(message.tempmembers))
                            return "tempmembers: array expected";
                        for(let i = 0; i < message.tempmembers.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.tempmembers[i]);
                            if(error)
                                return "tempmembers." + error;
                        }
                    }
                    if(message.partnerdata != null && message.hasOwnProperty("partnerdata"))
                        if(!(message.partnerdata && typeof message.partnerdata.length === "number" || $util.isString(message.partnerdata)))
                            return "partnerdata: buffer expected";
                    return null;
                };

                /**
                 * Creates a ChatRoom message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoom} ChatRoom
                 */
                ChatRoom.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoom)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoom();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.creater != null) {
                        if(typeof object.creater !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoom.creater: object expected");
                        message.creater = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.creater);
                    }
                    if(object.name != null)
                        message.name = String(object.name);
                    if(object.version != null)
                        if($util.Long)
                            (message.version = $util.Long.fromValue(object.version)).unsigned = true;
                        else if(typeof object.version === "string")
                            message.version = parseInt(object.version, 10);
                        else if(typeof object.version === "number")
                            message.version = object.version;
                        else if(typeof object.version === "object")
                            message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
                    if(object.maxmsgid != null)
                        if($util.Long)
                            (message.maxmsgid = $util.Long.fromValue(object.maxmsgid)).unsigned = true;
                        else if(typeof object.maxmsgid === "string")
                            message.maxmsgid = parseInt(object.maxmsgid, 10);
                        else if(typeof object.maxmsgid === "number")
                            message.maxmsgid = object.maxmsgid;
                        else if(typeof object.maxmsgid === "object")
                            message.maxmsgid = new $util.LongBits(object.maxmsgid.low >>> 0, object.maxmsgid.high >>> 0).toNumber(true);
                    if(object.memcountlimit != null)
                        if($util.Long)
                            (message.memcountlimit = $util.Long.fromValue(object.memcountlimit)).unsigned = true;
                        else if(typeof object.memcountlimit === "string")
                            message.memcountlimit = parseInt(object.memcountlimit, 10);
                        else if(typeof object.memcountlimit === "number")
                            message.memcountlimit = object.memcountlimit;
                        else if(typeof object.memcountlimit === "object")
                            message.memcountlimit = new $util.LongBits(object.memcountlimit.low >>> 0, object.memcountlimit.high >>> 0).toNumber(true);
                    if(object.roomtype != null)
                        message.roomtype = String(object.roomtype);
                    if(object.properties) {
                        if(!Array.isArray(object.properties))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoom.properties: array expected");
                        message.properties = [];
                        for(let i = 0; i < object.properties.length; ++i) {
                            if(typeof object.properties[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.ChatRoom.properties: object expected");
                            message.properties[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.properties[i]);
                        }
                    }
                    if(object.members) {
                        if(!Array.isArray(object.members))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoom.members: array expected");
                        message.members = [];
                        for(let i = 0; i < object.members.length; ++i) {
                            if(typeof object.members[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.ChatRoom.members: object expected");
                            message.members[i] = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.members[i]);
                        }
                    }
                    if(object.blacklist) {
                        if(!Array.isArray(object.blacklist))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoom.blacklist: array expected");
                        message.blacklist = [];
                        for(let i = 0; i < object.blacklist.length; ++i)
                            if(typeof object.blacklist[i] === "string")
                                $util.base64.decode(object.blacklist[i], message.blacklist[i] = $util.newBuffer($util.base64.length(object.blacklist[i])), 0);
                            else if(object.blacklist[i].length)
                                message.blacklist[i] = object.blacklist[i];
                    }
                    if(object.gameid != null)
                        message.gameid = String(object.gameid);
                    if(object.tempmembers) {
                        if(!Array.isArray(object.tempmembers))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoom.tempmembers: array expected");
                        message.tempmembers = [];
                        for(let i = 0; i < object.tempmembers.length; ++i) {
                            if(typeof object.tempmembers[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.ChatRoom.tempmembers: object expected");
                            message.tempmembers[i] = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.tempmembers[i]);
                        }
                    }
                    if(object.partnerdata != null)
                        if(typeof object.partnerdata === "string")
                            $util.base64.decode(object.partnerdata, message.partnerdata = $util.newBuffer($util.base64.length(object.partnerdata)), 0);
                        else if(object.partnerdata.length)
                            message.partnerdata = object.partnerdata;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoom message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoom} message ChatRoom
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoom.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults) {
                        object.properties = [];
                        object.members = [];
                        object.blacklist = [];
                        object.tempmembers = [];
                    }
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.creater = null;
                        object.name = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.version = options.longs === String ? "0" : 0;
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.maxmsgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxmsgid = options.longs === String ? "0" : 0;
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.memcountlimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.memcountlimit = options.longs === String ? "0" : 0;
                        object.roomtype = "";
                        object.gameid = "";
                        if(options.bytes === String)
                            object.partnerdata = "";
                        else {
                            object.partnerdata = [];
                            if(options.bytes !== Array)
                                object.partnerdata = $util.newBuffer(object.partnerdata);
                        }
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        object.creater = $root.qihoo.protocol.chatroom.CRUser.toObject(message.creater, options);
                    if(message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if(message.version != null && message.hasOwnProperty("version"))
                        if(typeof message.version === "number")
                            object.version = options.longs === String ? String(message.version) : message.version;
                        else
                            object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
                    if(message.maxmsgid != null && message.hasOwnProperty("maxmsgid"))
                        if(typeof message.maxmsgid === "number")
                            object.maxmsgid = options.longs === String ? String(message.maxmsgid) : message.maxmsgid;
                        else
                            object.maxmsgid = options.longs === String ? $util.Long.prototype.toString.call(message.maxmsgid) : options.longs === Number ? new $util.LongBits(message.maxmsgid.low >>> 0, message.maxmsgid.high >>> 0).toNumber(true) : message.maxmsgid;
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        if(typeof message.memcountlimit === "number")
                            object.memcountlimit = options.longs === String ? String(message.memcountlimit) : message.memcountlimit;
                        else
                            object.memcountlimit = options.longs === String ? $util.Long.prototype.toString.call(message.memcountlimit) : options.longs === Number ? new $util.LongBits(message.memcountlimit.low >>> 0, message.memcountlimit.high >>> 0).toNumber(true) : message.memcountlimit;
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        object.roomtype = message.roomtype;
                    if(message.properties && message.properties.length) {
                        object.properties = [];
                        for(let j = 0; j < message.properties.length; ++j)
                            object.properties[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.properties[j], options);
                    }
                    if(message.members && message.members.length) {
                        object.members = [];
                        for(let j = 0; j < message.members.length; ++j)
                            object.members[j] = $root.qihoo.protocol.chatroom.CRUser.toObject(message.members[j], options);
                    }
                    if(message.blacklist && message.blacklist.length) {
                        object.blacklist = [];
                        for(let j = 0; j < message.blacklist.length; ++j)
                            object.blacklist[j] = options.bytes === String ? $util.base64.encode(message.blacklist[j], 0, message.blacklist[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.blacklist[j]) : message.blacklist[j];
                    }
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        object.gameid = message.gameid;
                    if(message.tempmembers && message.tempmembers.length) {
                        object.tempmembers = [];
                        for(let j = 0; j < message.tempmembers.length; ++j)
                            object.tempmembers[j] = $root.qihoo.protocol.chatroom.CRUser.toObject(message.tempmembers[j], options);
                    }
                    if(message.partnerdata != null && message.hasOwnProperty("partnerdata"))
                        object.partnerdata = options.bytes === String ? $util.base64.encode(message.partnerdata, 0, message.partnerdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.partnerdata) : message.partnerdata;
                    return object;
                };

                /**
                 * Converts this ChatRoom to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoom
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoom.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoom;
            })();

            chatroom.CreateChatRoomRequest = (function () {

                /**
                 * Properties of a CreateChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICreateChatRoomRequest
                 * @property {string|null} [gameid] CreateChatRoomRequest gameid
                 * @property {string|null} [roomname] CreateChatRoomRequest roomname
                 * @property {number|Long|null} [memcountlimit] CreateChatRoomRequest memcountlimit
                 * @property {string|null} [roomtype] CreateChatRoomRequest roomtype
                 * @property {Array.<qihoo.protocol.chatroom.ICRUser>|null} [members] CreateChatRoomRequest members
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [creater] CreateChatRoomRequest creater
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [properties] CreateChatRoomRequest properties
                 */

                /**
                 * Constructs a new CreateChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CreateChatRoomRequest.
                 * @implements ICreateChatRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomRequest=} [properties] Properties to set
                 */
                function CreateChatRoomRequest(properties) {
                    this.members = [];
                    this.properties = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateChatRoomRequest gameid.
                 * @member {string} gameid
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.gameid = "";

                /**
                 * CreateChatRoomRequest roomname.
                 * @member {string} roomname
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.roomname = "";

                /**
                 * CreateChatRoomRequest memcountlimit.
                 * @member {number|Long} memcountlimit
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.memcountlimit = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * CreateChatRoomRequest roomtype.
                 * @member {string} roomtype
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.roomtype = "";

                /**
                 * CreateChatRoomRequest members.
                 * @member {Array.<qihoo.protocol.chatroom.ICRUser>} members
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.members = $util.emptyArray;

                /**
                 * CreateChatRoomRequest creater.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} creater
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.creater = null;

                /**
                 * CreateChatRoomRequest properties.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} properties
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 */
                CreateChatRoomRequest.prototype.properties = $util.emptyArray;

                /**
                 * Creates a new CreateChatRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomRequest} CreateChatRoomRequest instance
                 */
                CreateChatRoomRequest.create = function create(properties) {
                    return new CreateChatRoomRequest(properties);
                };

                /**
                 * Encodes the specified CreateChatRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomRequest} message CreateChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameid);
                    if(message.roomname != null && message.hasOwnProperty("roomname"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomname);
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.memcountlimit);
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.roomtype);
                    if(message.members != null && message.members.length)
                        for(let i = 0; i < message.members.length; ++i)
                            $root.qihoo.protocol.chatroom.CRUser.encode(message.members[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.creater, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.properties != null && message.properties.length)
                        for(let i = 0; i < message.properties.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.properties[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateChatRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomRequest} message CreateChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateChatRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomRequest} CreateChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CreateChatRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.gameid = reader.string();
                                break;
                            case 2:
                                message.roomname = reader.string();
                                break;
                            case 3:
                                message.memcountlimit = reader.uint64();
                                break;
                            case 4:
                                message.roomtype = reader.string();
                                break;
                            case 5:
                                if(!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32()));
                                break;
                            case 6:
                                message.creater = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            case 7:
                                if(!(message.properties && message.properties.length))
                                    message.properties = [];
                                message.properties.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateChatRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomRequest} CreateChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateChatRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateChatRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        if(!$util.isString(message.gameid))
                            return "gameid: string expected";
                    if(message.roomname != null && message.hasOwnProperty("roomname"))
                        if(!$util.isString(message.roomname))
                            return "roomname: string expected";
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        if(!$util.isInteger(message.memcountlimit) && !(message.memcountlimit && $util.isInteger(message.memcountlimit.low) && $util.isInteger(message.memcountlimit.high)))
                            return "memcountlimit: integer|Long expected";
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        if(!$util.isString(message.roomtype))
                            return "roomtype: string expected";
                    if(message.members != null && message.hasOwnProperty("members")) {
                        if(!Array.isArray(message.members))
                            return "members: array expected";
                        for(let i = 0; i < message.members.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.members[i]);
                            if(error)
                                return "members." + error;
                        }
                    }
                    if(message.creater != null && message.hasOwnProperty("creater")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.creater);
                        if(error)
                            return "creater." + error;
                    }
                    if(message.properties != null && message.hasOwnProperty("properties")) {
                        if(!Array.isArray(message.properties))
                            return "properties: array expected";
                        for(let i = 0; i < message.properties.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.properties[i]);
                            if(error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateChatRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomRequest} CreateChatRoomRequest
                 */
                CreateChatRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CreateChatRoomRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CreateChatRoomRequest();
                    if(object.gameid != null)
                        message.gameid = String(object.gameid);
                    if(object.roomname != null)
                        message.roomname = String(object.roomname);
                    if(object.memcountlimit != null)
                        if($util.Long)
                            (message.memcountlimit = $util.Long.fromValue(object.memcountlimit)).unsigned = true;
                        else if(typeof object.memcountlimit === "string")
                            message.memcountlimit = parseInt(object.memcountlimit, 10);
                        else if(typeof object.memcountlimit === "number")
                            message.memcountlimit = object.memcountlimit;
                        else if(typeof object.memcountlimit === "object")
                            message.memcountlimit = new $util.LongBits(object.memcountlimit.low >>> 0, object.memcountlimit.high >>> 0).toNumber(true);
                    if(object.roomtype != null)
                        message.roomtype = String(object.roomtype);
                    if(object.members) {
                        if(!Array.isArray(object.members))
                            throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomRequest.members: array expected");
                        message.members = [];
                        for(let i = 0; i < object.members.length; ++i) {
                            if(typeof object.members[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomRequest.members: object expected");
                            message.members[i] = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.members[i]);
                        }
                    }
                    if(object.creater != null) {
                        if(typeof object.creater !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomRequest.creater: object expected");
                        message.creater = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.creater);
                    }
                    if(object.properties) {
                        if(!Array.isArray(object.properties))
                            throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomRequest.properties: array expected");
                        message.properties = [];
                        for(let i = 0; i < object.properties.length; ++i) {
                            if(typeof object.properties[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomRequest.properties: object expected");
                            message.properties[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.properties[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateChatRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.CreateChatRoomRequest} message CreateChatRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateChatRoomRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults) {
                        object.members = [];
                        object.properties = [];
                    }
                    if(options.defaults) {
                        object.gameid = "";
                        object.roomname = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.memcountlimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.memcountlimit = options.longs === String ? "0" : 0;
                        object.roomtype = "";
                        object.creater = null;
                    }
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        object.gameid = message.gameid;
                    if(message.roomname != null && message.hasOwnProperty("roomname"))
                        object.roomname = message.roomname;
                    if(message.memcountlimit != null && message.hasOwnProperty("memcountlimit"))
                        if(typeof message.memcountlimit === "number")
                            object.memcountlimit = options.longs === String ? String(message.memcountlimit) : message.memcountlimit;
                        else
                            object.memcountlimit = options.longs === String ? $util.Long.prototype.toString.call(message.memcountlimit) : options.longs === Number ? new $util.LongBits(message.memcountlimit.low >>> 0, message.memcountlimit.high >>> 0).toNumber(true) : message.memcountlimit;
                    if(message.roomtype != null && message.hasOwnProperty("roomtype"))
                        object.roomtype = message.roomtype;
                    if(message.members && message.members.length) {
                        object.members = [];
                        for(let j = 0; j < message.members.length; ++j)
                            object.members[j] = $root.qihoo.protocol.chatroom.CRUser.toObject(message.members[j], options);
                    }
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        object.creater = $root.qihoo.protocol.chatroom.CRUser.toObject(message.creater, options);
                    if(message.properties && message.properties.length) {
                        object.properties = [];
                        for(let j = 0; j < message.properties.length; ++j)
                            object.properties[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.properties[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CreateChatRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateChatRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateChatRoomRequest;
            })();

            chatroom.CreateChatRoomResponse = (function () {

                /**
                 * Properties of a CreateChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICreateChatRoomResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] CreateChatRoomResponse room
                 */

                /**
                 * Constructs a new CreateChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CreateChatRoomResponse.
                 * @implements ICreateChatRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomResponse=} [properties] Properties to set
                 */
                function CreateChatRoomResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateChatRoomResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @instance
                 */
                CreateChatRoomResponse.prototype.room = null;

                /**
                 * Creates a new CreateChatRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomResponse} CreateChatRoomResponse instance
                 */
                CreateChatRoomResponse.create = function create(properties) {
                    return new CreateChatRoomResponse(properties);
                };

                /**
                 * Encodes the specified CreateChatRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomResponse} message CreateChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateChatRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomResponse} message CreateChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateChatRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomResponse} CreateChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CreateChatRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateChatRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomResponse} CreateChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateChatRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateChatRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateChatRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomResponse} CreateChatRoomResponse
                 */
                CreateChatRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CreateChatRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CreateChatRoomResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateChatRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.CreateChatRoomResponse} message CreateChatRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateChatRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this CreateChatRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateChatRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateChatRoomResponse;
            })();

            chatroom.CreateMultiChatRoomRequest = (function () {

                /**
                 * Properties of a CreateMultiChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICreateMultiChatRoomRequest
                 * @property {Array.<qihoo.protocol.chatroom.ICreateChatRoomRequest>|null} [rooms] CreateMultiChatRoomRequest rooms
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [creater] CreateMultiChatRoomRequest creater
                 */

                /**
                 * Constructs a new CreateMultiChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CreateMultiChatRoomRequest.
                 * @implements ICreateMultiChatRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest=} [properties] Properties to set
                 */
                function CreateMultiChatRoomRequest(properties) {
                    this.rooms = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateMultiChatRoomRequest rooms.
                 * @member {Array.<qihoo.protocol.chatroom.ICreateChatRoomRequest>} rooms
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @instance
                 */
                CreateMultiChatRoomRequest.prototype.rooms = $util.emptyArray;

                /**
                 * CreateMultiChatRoomRequest creater.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} creater
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @instance
                 */
                CreateMultiChatRoomRequest.prototype.creater = null;

                /**
                 * Creates a new CreateMultiChatRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomRequest} CreateMultiChatRoomRequest instance
                 */
                CreateMultiChatRoomRequest.create = function create(properties) {
                    return new CreateMultiChatRoomRequest(properties);
                };

                /**
                 * Encodes the specified CreateMultiChatRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.CreateMultiChatRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest} message CreateMultiChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateMultiChatRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.rooms != null && message.rooms.length)
                        for(let i = 0; i < message.rooms.length; ++i)
                            $root.qihoo.protocol.chatroom.CreateChatRoomRequest.encode(message.rooms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.creater, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateMultiChatRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CreateMultiChatRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest} message CreateMultiChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateMultiChatRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateMultiChatRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomRequest} CreateMultiChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateMultiChatRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.rooms && message.rooms.length))
                                    message.rooms = [];
                                message.rooms.push($root.qihoo.protocol.chatroom.CreateChatRoomRequest.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.creater = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateMultiChatRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomRequest} CreateMultiChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateMultiChatRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateMultiChatRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateMultiChatRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.rooms != null && message.hasOwnProperty("rooms")) {
                        if(!Array.isArray(message.rooms))
                            return "rooms: array expected";
                        for(let i = 0; i < message.rooms.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.verify(message.rooms[i]);
                            if(error)
                                return "rooms." + error;
                        }
                    }
                    if(message.creater != null && message.hasOwnProperty("creater")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.creater);
                        if(error)
                            return "creater." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateMultiChatRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomRequest} CreateMultiChatRoomRequest
                 */
                CreateMultiChatRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest();
                    if(object.rooms) {
                        if(!Array.isArray(object.rooms))
                            throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomRequest.rooms: array expected");
                        message.rooms = [];
                        for(let i = 0; i < object.rooms.length; ++i) {
                            if(typeof object.rooms[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomRequest.rooms: object expected");
                            message.rooms[i] = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.fromObject(object.rooms[i]);
                        }
                    }
                    if(object.creater != null) {
                        if(typeof object.creater !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomRequest.creater: object expected");
                        message.creater = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.creater);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateMultiChatRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.CreateMultiChatRoomRequest} message CreateMultiChatRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateMultiChatRoomRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.rooms = [];
                    if(options.defaults)
                        object.creater = null;
                    if(message.rooms && message.rooms.length) {
                        object.rooms = [];
                        for(let j = 0; j < message.rooms.length; ++j)
                            object.rooms[j] = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.toObject(message.rooms[j], options);
                    }
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        object.creater = $root.qihoo.protocol.chatroom.CRUser.toObject(message.creater, options);
                    return object;
                };

                /**
                 * Converts this CreateMultiChatRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateMultiChatRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateMultiChatRoomRequest;
            })();

            chatroom.CreateMultiChatRoomResponse = (function () {

                /**
                 * Properties of a CreateMultiChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICreateMultiChatRoomResponse
                 * @property {Array.<qihoo.protocol.chatroom.IChatRoom>|null} [rooms] CreateMultiChatRoomResponse rooms
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [creater] CreateMultiChatRoomResponse creater
                 */

                /**
                 * Constructs a new CreateMultiChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CreateMultiChatRoomResponse.
                 * @implements ICreateMultiChatRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse=} [properties] Properties to set
                 */
                function CreateMultiChatRoomResponse(properties) {
                    this.rooms = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateMultiChatRoomResponse rooms.
                 * @member {Array.<qihoo.protocol.chatroom.IChatRoom>} rooms
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @instance
                 */
                CreateMultiChatRoomResponse.prototype.rooms = $util.emptyArray;

                /**
                 * CreateMultiChatRoomResponse creater.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} creater
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @instance
                 */
                CreateMultiChatRoomResponse.prototype.creater = null;

                /**
                 * Creates a new CreateMultiChatRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomResponse} CreateMultiChatRoomResponse instance
                 */
                CreateMultiChatRoomResponse.create = function create(properties) {
                    return new CreateMultiChatRoomResponse(properties);
                };

                /**
                 * Encodes the specified CreateMultiChatRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.CreateMultiChatRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse} message CreateMultiChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateMultiChatRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.rooms != null && message.rooms.length)
                        for(let i = 0; i < message.rooms.length; ++i)
                            $root.qihoo.protocol.chatroom.ChatRoom.encode(message.rooms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.creater, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateMultiChatRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CreateMultiChatRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse} message CreateMultiChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateMultiChatRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateMultiChatRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomResponse} CreateMultiChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateMultiChatRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.rooms && message.rooms.length))
                                    message.rooms = [];
                                message.rooms.push($root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.creater = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateMultiChatRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomResponse} CreateMultiChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateMultiChatRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateMultiChatRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateMultiChatRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.rooms != null && message.hasOwnProperty("rooms")) {
                        if(!Array.isArray(message.rooms))
                            return "rooms: array expected";
                        for(let i = 0; i < message.rooms.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.rooms[i]);
                            if(error)
                                return "rooms." + error;
                        }
                    }
                    if(message.creater != null && message.hasOwnProperty("creater")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.creater);
                        if(error)
                            return "creater." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateMultiChatRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CreateMultiChatRoomResponse} CreateMultiChatRoomResponse
                 */
                CreateMultiChatRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse();
                    if(object.rooms) {
                        if(!Array.isArray(object.rooms))
                            throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomResponse.rooms: array expected");
                        message.rooms = [];
                        for(let i = 0; i < object.rooms.length; ++i) {
                            if(typeof object.rooms[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomResponse.rooms: object expected");
                            message.rooms[i] = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.rooms[i]);
                        }
                    }
                    if(object.creater != null) {
                        if(typeof object.creater !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.CreateMultiChatRoomResponse.creater: object expected");
                        message.creater = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.creater);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateMultiChatRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.CreateMultiChatRoomResponse} message CreateMultiChatRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateMultiChatRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.rooms = [];
                    if(options.defaults)
                        object.creater = null;
                    if(message.rooms && message.rooms.length) {
                        object.rooms = [];
                        for(let j = 0; j < message.rooms.length; ++j)
                            object.rooms[j] = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.rooms[j], options);
                    }
                    if(message.creater != null && message.hasOwnProperty("creater"))
                        object.creater = $root.qihoo.protocol.chatroom.CRUser.toObject(message.creater, options);
                    return object;
                };

                /**
                 * Converts this CreateMultiChatRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CreateMultiChatRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateMultiChatRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateMultiChatRoomResponse;
            })();

            chatroom.GetChatRoomDetailRequest = (function () {

                /**
                 * Properties of a GetChatRoomDetailRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IGetChatRoomDetailRequest
                 * @property {Uint8Array} roomid GetChatRoomDetailRequest roomid
                 * @property {number|null} [index] GetChatRoomDetailRequest index
                 * @property {number|null} [offset] GetChatRoomDetailRequest offset
                 */

                /**
                 * Constructs a new GetChatRoomDetailRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a GetChatRoomDetailRequest.
                 * @implements IGetChatRoomDetailRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailRequest=} [properties] Properties to set
                 */
                function GetChatRoomDetailRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetChatRoomDetailRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @instance
                 */
                GetChatRoomDetailRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * GetChatRoomDetailRequest index.
                 * @member {number} index
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @instance
                 */
                GetChatRoomDetailRequest.prototype.index = 0;

                /**
                 * GetChatRoomDetailRequest offset.
                 * @member {number} offset
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @instance
                 */
                GetChatRoomDetailRequest.prototype.offset = 0;

                /**
                 * Creates a new GetChatRoomDetailRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailRequest} GetChatRoomDetailRequest instance
                 */
                GetChatRoomDetailRequest.create = function create(properties) {
                    return new GetChatRoomDetailRequest(properties);
                };

                /**
                 * Encodes the specified GetChatRoomDetailRequest message. Does not implicitly {@link qihoo.protocol.chatroom.GetChatRoomDetailRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailRequest} message GetChatRoomDetailRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetChatRoomDetailRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
                    if(message.offset != null && message.hasOwnProperty("offset"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.offset);
                    return writer;
                };

                /**
                 * Encodes the specified GetChatRoomDetailRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.GetChatRoomDetailRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailRequest} message GetChatRoomDetailRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetChatRoomDetailRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetChatRoomDetailRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailRequest} GetChatRoomDetailRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetChatRoomDetailRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.index = reader.int32();
                                break;
                            case 3:
                                message.offset = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a GetChatRoomDetailRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailRequest} GetChatRoomDetailRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetChatRoomDetailRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetChatRoomDetailRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetChatRoomDetailRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.index != null && message.hasOwnProperty("index"))
                        if(!$util.isInteger(message.index))
                            return "index: integer expected";
                    if(message.offset != null && message.hasOwnProperty("offset"))
                        if(!$util.isInteger(message.offset))
                            return "offset: integer expected";
                    return null;
                };

                /**
                 * Creates a GetChatRoomDetailRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailRequest} GetChatRoomDetailRequest
                 */
                GetChatRoomDetailRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.index != null)
                        message.index = object.index | 0;
                    if(object.offset != null)
                        message.offset = object.offset | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a GetChatRoomDetailRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.GetChatRoomDetailRequest} message GetChatRoomDetailRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetChatRoomDetailRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.index = 0;
                        object.offset = 0;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if(message.offset != null && message.hasOwnProperty("offset"))
                        object.offset = message.offset;
                    return object;
                };

                /**
                 * Converts this GetChatRoomDetailRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetChatRoomDetailRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetChatRoomDetailRequest;
            })();

            chatroom.GetChatRoomDetailResponse = (function () {

                /**
                 * Properties of a GetChatRoomDetailResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IGetChatRoomDetailResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] GetChatRoomDetailResponse room
                 */

                /**
                 * Constructs a new GetChatRoomDetailResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a GetChatRoomDetailResponse.
                 * @implements IGetChatRoomDetailResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailResponse=} [properties] Properties to set
                 */
                function GetChatRoomDetailResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetChatRoomDetailResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @instance
                 */
                GetChatRoomDetailResponse.prototype.room = null;

                /**
                 * Creates a new GetChatRoomDetailResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailResponse} GetChatRoomDetailResponse instance
                 */
                GetChatRoomDetailResponse.create = function create(properties) {
                    return new GetChatRoomDetailResponse(properties);
                };

                /**
                 * Encodes the specified GetChatRoomDetailResponse message. Does not implicitly {@link qihoo.protocol.chatroom.GetChatRoomDetailResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailResponse} message GetChatRoomDetailResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetChatRoomDetailResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified GetChatRoomDetailResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.GetChatRoomDetailResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IGetChatRoomDetailResponse} message GetChatRoomDetailResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetChatRoomDetailResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetChatRoomDetailResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailResponse} GetChatRoomDetailResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetChatRoomDetailResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetChatRoomDetailResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailResponse} GetChatRoomDetailResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetChatRoomDetailResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetChatRoomDetailResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetChatRoomDetailResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a GetChatRoomDetailResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.GetChatRoomDetailResponse} GetChatRoomDetailResponse
                 */
                GetChatRoomDetailResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.GetChatRoomDetailResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetChatRoomDetailResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.GetChatRoomDetailResponse} message GetChatRoomDetailResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetChatRoomDetailResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this GetChatRoomDetailResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.GetChatRoomDetailResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetChatRoomDetailResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetChatRoomDetailResponse;
            })();

            chatroom.ApplyJoinChatRoomRequest = (function () {

                /**
                 * Properties of an ApplyJoinChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IApplyJoinChatRoomRequest
                 * @property {Uint8Array} roomid ApplyJoinChatRoomRequest roomid
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] ApplyJoinChatRoomRequest room
                 * @property {number|null} [userid_type] ApplyJoinChatRoomRequest userid_type
                 * @property {Uint8Array|null} [userdata] ApplyJoinChatRoomRequest userdata
                 * @property {boolean|null} [no_userlist] ApplyJoinChatRoomRequest no_userlist
                 */

                /**
                 * Constructs a new ApplyJoinChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an ApplyJoinChatRoomRequest.
                 * @implements IApplyJoinChatRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest=} [properties] Properties to set
                 */
                function ApplyJoinChatRoomRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ApplyJoinChatRoomRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 */
                ApplyJoinChatRoomRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * ApplyJoinChatRoomRequest room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 */
                ApplyJoinChatRoomRequest.prototype.room = null;

                /**
                 * ApplyJoinChatRoomRequest userid_type.
                 * @member {number} userid_type
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 */
                ApplyJoinChatRoomRequest.prototype.userid_type = 0;

                /**
                 * ApplyJoinChatRoomRequest userdata.
                 * @member {Uint8Array} userdata
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 */
                ApplyJoinChatRoomRequest.prototype.userdata = $util.newBuffer([]);

                /**
                 * ApplyJoinChatRoomRequest no_userlist.
                 * @member {boolean} no_userlist
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 */
                ApplyJoinChatRoomRequest.prototype.no_userlist = false;

                /**
                 * Creates a new ApplyJoinChatRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomRequest} ApplyJoinChatRoomRequest instance
                 */
                ApplyJoinChatRoomRequest.create = function create(properties) {
                    return new ApplyJoinChatRoomRequest(properties);
                };

                /**
                 * Encodes the specified ApplyJoinChatRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest} message ApplyJoinChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApplyJoinChatRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.userid_type != null && message.hasOwnProperty("userid_type"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userid_type);
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.userdata);
                    if(message.no_userlist != null && message.hasOwnProperty("no_userlist"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.no_userlist);
                    return writer;
                };

                /**
                 * Encodes the specified ApplyJoinChatRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest} message ApplyJoinChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApplyJoinChatRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ApplyJoinChatRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomRequest} ApplyJoinChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApplyJoinChatRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.userid_type = reader.int32();
                                break;
                            case 4:
                                message.userdata = reader.bytes();
                                break;
                            case 5:
                                message.no_userlist = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an ApplyJoinChatRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomRequest} ApplyJoinChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApplyJoinChatRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ApplyJoinChatRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ApplyJoinChatRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    if(message.userid_type != null && message.hasOwnProperty("userid_type"))
                        if(!$util.isInteger(message.userid_type))
                            return "userid_type: integer expected";
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        if(!(message.userdata && typeof message.userdata.length === "number" || $util.isString(message.userdata)))
                            return "userdata: buffer expected";
                    if(message.no_userlist != null && message.hasOwnProperty("no_userlist"))
                        if(typeof message.no_userlist !== "boolean")
                            return "no_userlist: boolean expected";
                    return null;
                };

                /**
                 * Creates an ApplyJoinChatRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomRequest} ApplyJoinChatRoomRequest
                 */
                ApplyJoinChatRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    if(object.userid_type != null)
                        message.userid_type = object.userid_type | 0;
                    if(object.userdata != null)
                        if(typeof object.userdata === "string")
                            $util.base64.decode(object.userdata, message.userdata = $util.newBuffer($util.base64.length(object.userdata)), 0);
                        else if(object.userdata.length)
                            message.userdata = object.userdata;
                    if(object.no_userlist != null)
                        message.no_userlist = Boolean(object.no_userlist);
                    return message;
                };

                /**
                 * Creates a plain object from an ApplyJoinChatRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ApplyJoinChatRoomRequest} message ApplyJoinChatRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ApplyJoinChatRoomRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.room = null;
                        object.userid_type = 0;
                        if(options.bytes === String)
                            object.userdata = "";
                        else {
                            object.userdata = [];
                            if(options.bytes !== Array)
                                object.userdata = $util.newBuffer(object.userdata);
                        }
                        object.no_userlist = false;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    if(message.userid_type != null && message.hasOwnProperty("userid_type"))
                        object.userid_type = message.userid_type;
                    if(message.userdata != null && message.hasOwnProperty("userdata"))
                        object.userdata = options.bytes === String ? $util.base64.encode(message.userdata, 0, message.userdata.length) : options.bytes === Array ? Array.prototype.slice.call(message.userdata) : message.userdata;
                    if(message.no_userlist != null && message.hasOwnProperty("no_userlist"))
                        object.no_userlist = message.no_userlist;
                    return object;
                };

                /**
                 * Converts this ApplyJoinChatRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ApplyJoinChatRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ApplyJoinChatRoomRequest;
            })();

            chatroom.ApplyJoinChatRoomResponse = (function () {

                /**
                 * Properties of an ApplyJoinChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IApplyJoinChatRoomResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] ApplyJoinChatRoomResponse room
                 * @property {boolean|null} [pull_lost] ApplyJoinChatRoomResponse pull_lost
                 */

                /**
                 * Constructs a new ApplyJoinChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an ApplyJoinChatRoomResponse.
                 * @implements IApplyJoinChatRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse=} [properties] Properties to set
                 */
                function ApplyJoinChatRoomResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ApplyJoinChatRoomResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @instance
                 */
                ApplyJoinChatRoomResponse.prototype.room = null;

                /**
                 * ApplyJoinChatRoomResponse pull_lost.
                 * @member {boolean} pull_lost
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @instance
                 */
                ApplyJoinChatRoomResponse.prototype.pull_lost = true;

                /**
                 * Creates a new ApplyJoinChatRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomResponse} ApplyJoinChatRoomResponse instance
                 */
                ApplyJoinChatRoomResponse.create = function create(properties) {
                    return new ApplyJoinChatRoomResponse(properties);
                };

                /**
                 * Encodes the specified ApplyJoinChatRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse} message ApplyJoinChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApplyJoinChatRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.pull_lost != null && message.hasOwnProperty("pull_lost"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.pull_lost);
                    return writer;
                };

                /**
                 * Encodes the specified ApplyJoinChatRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse} message ApplyJoinChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ApplyJoinChatRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ApplyJoinChatRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomResponse} ApplyJoinChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApplyJoinChatRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.pull_lost = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ApplyJoinChatRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomResponse} ApplyJoinChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ApplyJoinChatRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ApplyJoinChatRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ApplyJoinChatRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    if(message.pull_lost != null && message.hasOwnProperty("pull_lost"))
                        if(typeof message.pull_lost !== "boolean")
                            return "pull_lost: boolean expected";
                    return null;
                };

                /**
                 * Creates an ApplyJoinChatRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ApplyJoinChatRoomResponse} ApplyJoinChatRoomResponse
                 */
                ApplyJoinChatRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    if(object.pull_lost != null)
                        message.pull_lost = Boolean(object.pull_lost);
                    return message;
                };

                /**
                 * Creates a plain object from an ApplyJoinChatRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ApplyJoinChatRoomResponse} message ApplyJoinChatRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ApplyJoinChatRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.room = null;
                        object.pull_lost = true;
                    }
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    if(message.pull_lost != null && message.hasOwnProperty("pull_lost"))
                        object.pull_lost = message.pull_lost;
                    return object;
                };

                /**
                 * Converts this ApplyJoinChatRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ApplyJoinChatRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ApplyJoinChatRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ApplyJoinChatRoomResponse;
            })();

            chatroom.QuitChatRoomRequest = (function () {

                /**
                 * Properties of a QuitChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQuitChatRoomRequest
                 * @property {Uint8Array} roomid QuitChatRoomRequest roomid
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] QuitChatRoomRequest room
                 */

                /**
                 * Constructs a new QuitChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QuitChatRoomRequest.
                 * @implements IQuitChatRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomRequest=} [properties] Properties to set
                 */
                function QuitChatRoomRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QuitChatRoomRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @instance
                 */
                QuitChatRoomRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * QuitChatRoomRequest room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @instance
                 */
                QuitChatRoomRequest.prototype.room = null;

                /**
                 * Creates a new QuitChatRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomRequest} QuitChatRoomRequest instance
                 */
                QuitChatRoomRequest.create = function create(properties) {
                    return new QuitChatRoomRequest(properties);
                };

                /**
                 * Encodes the specified QuitChatRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.QuitChatRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomRequest} message QuitChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuitChatRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified QuitChatRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QuitChatRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomRequest} message QuitChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuitChatRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QuitChatRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomRequest} QuitChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuitChatRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QuitChatRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a QuitChatRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomRequest} QuitChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuitChatRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QuitChatRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QuitChatRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a QuitChatRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomRequest} QuitChatRoomRequest
                 */
                QuitChatRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QuitChatRoomRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.QuitChatRoomRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.QuitChatRoomRequest.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QuitChatRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.QuitChatRoomRequest} message QuitChatRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuitChatRoomRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.room = null;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this QuitChatRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuitChatRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QuitChatRoomRequest;
            })();

            chatroom.QuitChatRoomResponse = (function () {

                /**
                 * Properties of a QuitChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQuitChatRoomResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] QuitChatRoomResponse room
                 */

                /**
                 * Constructs a new QuitChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QuitChatRoomResponse.
                 * @implements IQuitChatRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomResponse=} [properties] Properties to set
                 */
                function QuitChatRoomResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QuitChatRoomResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @instance
                 */
                QuitChatRoomResponse.prototype.room = null;

                /**
                 * Creates a new QuitChatRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomResponse} QuitChatRoomResponse instance
                 */
                QuitChatRoomResponse.create = function create(properties) {
                    return new QuitChatRoomResponse(properties);
                };

                /**
                 * Encodes the specified QuitChatRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.QuitChatRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomResponse} message QuitChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuitChatRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified QuitChatRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QuitChatRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQuitChatRoomResponse} message QuitChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuitChatRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QuitChatRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomResponse} QuitChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuitChatRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QuitChatRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QuitChatRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomResponse} QuitChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuitChatRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QuitChatRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QuitChatRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a QuitChatRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QuitChatRoomResponse} QuitChatRoomResponse
                 */
                QuitChatRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QuitChatRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.QuitChatRoomResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.QuitChatRoomResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QuitChatRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.QuitChatRoomResponse} message QuitChatRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuitChatRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this QuitChatRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QuitChatRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuitChatRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QuitChatRoomResponse;
            })();

            chatroom.QueryAllGameRoomRequest = (function () {

                /**
                 * Properties of a QueryAllGameRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQueryAllGameRoomRequest
                 */

                /**
                 * Constructs a new QueryAllGameRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QueryAllGameRoomRequest.
                 * @implements IQueryAllGameRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomRequest=} [properties] Properties to set
                 */
                function QueryAllGameRoomRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new QueryAllGameRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomRequest} QueryAllGameRoomRequest instance
                 */
                QueryAllGameRoomRequest.create = function create(properties) {
                    return new QueryAllGameRoomRequest(properties);
                };

                /**
                 * Encodes the specified QueryAllGameRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.QueryAllGameRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomRequest} message QueryAllGameRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllGameRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified QueryAllGameRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QueryAllGameRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomRequest} message QueryAllGameRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllGameRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QueryAllGameRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomRequest} QueryAllGameRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllGameRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QueryAllGameRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomRequest} QueryAllGameRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllGameRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QueryAllGameRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllGameRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a QueryAllGameRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomRequest} QueryAllGameRoomRequest
                 */
                QueryAllGameRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest)
                        return object;
                    return new $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest();
                };

                /**
                 * Creates a plain object from a QueryAllGameRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.QueryAllGameRoomRequest} message QueryAllGameRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllGameRoomRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this QueryAllGameRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllGameRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryAllGameRoomRequest;
            })();

            chatroom.QueryAllGameRoomResponse = (function () {

                /**
                 * Properties of a QueryAllGameRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQueryAllGameRoomResponse
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [maplist] QueryAllGameRoomResponse maplist
                 */

                /**
                 * Constructs a new QueryAllGameRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QueryAllGameRoomResponse.
                 * @implements IQueryAllGameRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomResponse=} [properties] Properties to set
                 */
                function QueryAllGameRoomResponse(properties) {
                    this.maplist = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QueryAllGameRoomResponse maplist.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} maplist
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @instance
                 */
                QueryAllGameRoomResponse.prototype.maplist = $util.emptyArray;

                /**
                 * Creates a new QueryAllGameRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomResponse} QueryAllGameRoomResponse instance
                 */
                QueryAllGameRoomResponse.create = function create(properties) {
                    return new QueryAllGameRoomResponse(properties);
                };

                /**
                 * Encodes the specified QueryAllGameRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.QueryAllGameRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomResponse} message QueryAllGameRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllGameRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.maplist != null && message.maplist.length)
                        for(let i = 0; i < message.maplist.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.maplist[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified QueryAllGameRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QueryAllGameRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryAllGameRoomResponse} message QueryAllGameRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryAllGameRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QueryAllGameRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomResponse} QueryAllGameRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllGameRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.maplist && message.maplist.length))
                                    message.maplist = [];
                                message.maplist.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QueryAllGameRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomResponse} QueryAllGameRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryAllGameRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QueryAllGameRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryAllGameRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.maplist != null && message.hasOwnProperty("maplist")) {
                        if(!Array.isArray(message.maplist))
                            return "maplist: array expected";
                        for(let i = 0; i < message.maplist.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.maplist[i]);
                            if(error)
                                return "maplist." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a QueryAllGameRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QueryAllGameRoomResponse} QueryAllGameRoomResponse
                 */
                QueryAllGameRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse();
                    if(object.maplist) {
                        if(!Array.isArray(object.maplist))
                            throw TypeError(".qihoo.protocol.chatroom.QueryAllGameRoomResponse.maplist: array expected");
                        message.maplist = [];
                        for(let i = 0; i < object.maplist.length; ++i) {
                            if(typeof object.maplist[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.QueryAllGameRoomResponse.maplist: object expected");
                            message.maplist[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.maplist[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QueryAllGameRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.QueryAllGameRoomResponse} message QueryAllGameRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryAllGameRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.maplist = [];
                    if(message.maplist && message.maplist.length) {
                        object.maplist = [];
                        for(let j = 0; j < message.maplist.length; ++j)
                            object.maplist[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.maplist[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this QueryAllGameRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QueryAllGameRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryAllGameRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryAllGameRoomResponse;
            })();

            chatroom.QueryChatRoomIDRequest = (function () {

                /**
                 * Properties of a QueryChatRoomIDRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQueryChatRoomIDRequest
                 * @property {string} gameid QueryChatRoomIDRequest gameid
                 */

                /**
                 * Constructs a new QueryChatRoomIDRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QueryChatRoomIDRequest.
                 * @implements IQueryChatRoomIDRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDRequest=} [properties] Properties to set
                 */
                function QueryChatRoomIDRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QueryChatRoomIDRequest gameid.
                 * @member {string} gameid
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @instance
                 */
                QueryChatRoomIDRequest.prototype.gameid = "";

                /**
                 * Creates a new QueryChatRoomIDRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDRequest} QueryChatRoomIDRequest instance
                 */
                QueryChatRoomIDRequest.create = function create(properties) {
                    return new QueryChatRoomIDRequest(properties);
                };

                /**
                 * Encodes the specified QueryChatRoomIDRequest message. Does not implicitly {@link qihoo.protocol.chatroom.QueryChatRoomIDRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDRequest} message QueryChatRoomIDRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryChatRoomIDRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameid);
                    return writer;
                };

                /**
                 * Encodes the specified QueryChatRoomIDRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QueryChatRoomIDRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDRequest} message QueryChatRoomIDRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryChatRoomIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QueryChatRoomIDRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDRequest} QueryChatRoomIDRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryChatRoomIDRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.gameid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("gameid"))
                        throw $util.ProtocolError("missing required 'gameid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a QueryChatRoomIDRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDRequest} QueryChatRoomIDRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryChatRoomIDRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QueryChatRoomIDRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryChatRoomIDRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.gameid))
                        return "gameid: string expected";
                    return null;
                };

                /**
                 * Creates a QueryChatRoomIDRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDRequest} QueryChatRoomIDRequest
                 */
                QueryChatRoomIDRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest();
                    if(object.gameid != null)
                        message.gameid = String(object.gameid);
                    return message;
                };

                /**
                 * Creates a plain object from a QueryChatRoomIDRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.QueryChatRoomIDRequest} message QueryChatRoomIDRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryChatRoomIDRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.gameid = "";
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        object.gameid = message.gameid;
                    return object;
                };

                /**
                 * Converts this QueryChatRoomIDRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryChatRoomIDRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryChatRoomIDRequest;
            })();

            chatroom.QueryChatRoomIDResponse = (function () {

                /**
                 * Properties of a QueryChatRoomIDResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IQueryChatRoomIDResponse
                 * @property {Uint8Array|null} [roomid] QueryChatRoomIDResponse roomid
                 * @property {string|null} [gameid] QueryChatRoomIDResponse gameid
                 */

                /**
                 * Constructs a new QueryChatRoomIDResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a QueryChatRoomIDResponse.
                 * @implements IQueryChatRoomIDResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDResponse=} [properties] Properties to set
                 */
                function QueryChatRoomIDResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QueryChatRoomIDResponse roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @instance
                 */
                QueryChatRoomIDResponse.prototype.roomid = $util.newBuffer([]);

                /**
                 * QueryChatRoomIDResponse gameid.
                 * @member {string} gameid
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @instance
                 */
                QueryChatRoomIDResponse.prototype.gameid = "";

                /**
                 * Creates a new QueryChatRoomIDResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDResponse} QueryChatRoomIDResponse instance
                 */
                QueryChatRoomIDResponse.create = function create(properties) {
                    return new QueryChatRoomIDResponse(properties);
                };

                /**
                 * Encodes the specified QueryChatRoomIDResponse message. Does not implicitly {@link qihoo.protocol.chatroom.QueryChatRoomIDResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDResponse} message QueryChatRoomIDResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryChatRoomIDResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameid);
                    return writer;
                };

                /**
                 * Encodes the specified QueryChatRoomIDResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.QueryChatRoomIDResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IQueryChatRoomIDResponse} message QueryChatRoomIDResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QueryChatRoomIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a QueryChatRoomIDResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDResponse} QueryChatRoomIDResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryChatRoomIDResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.gameid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a QueryChatRoomIDResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDResponse} QueryChatRoomIDResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QueryChatRoomIDResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a QueryChatRoomIDResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryChatRoomIDResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                            return "roomid: buffer expected";
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        if(!$util.isString(message.gameid))
                            return "gameid: string expected";
                    return null;
                };

                /**
                 * Creates a QueryChatRoomIDResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.QueryChatRoomIDResponse} QueryChatRoomIDResponse
                 */
                QueryChatRoomIDResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.gameid != null)
                        message.gameid = String(object.gameid);
                    return message;
                };

                /**
                 * Creates a plain object from a QueryChatRoomIDResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.QueryChatRoomIDResponse} message QueryChatRoomIDResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryChatRoomIDResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.gameid = "";
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        object.gameid = message.gameid;
                    return object;
                };

                /**
                 * Converts this QueryChatRoomIDResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.QueryChatRoomIDResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryChatRoomIDResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryChatRoomIDResponse;
            })();

            chatroom.UpdateRoomIDRequest = (function () {

                /**
                 * Properties of an UpdateRoomIDRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IUpdateRoomIDRequest
                 * @property {string} gameid UpdateRoomIDRequest gameid
                 * @property {Uint8Array} roomid UpdateRoomIDRequest roomid
                 */

                /**
                 * Constructs a new UpdateRoomIDRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an UpdateRoomIDRequest.
                 * @implements IUpdateRoomIDRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDRequest=} [properties] Properties to set
                 */
                function UpdateRoomIDRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateRoomIDRequest gameid.
                 * @member {string} gameid
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @instance
                 */
                UpdateRoomIDRequest.prototype.gameid = "";

                /**
                 * UpdateRoomIDRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @instance
                 */
                UpdateRoomIDRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * Creates a new UpdateRoomIDRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDRequest} UpdateRoomIDRequest instance
                 */
                UpdateRoomIDRequest.create = function create(properties) {
                    return new UpdateRoomIDRequest(properties);
                };

                /**
                 * Encodes the specified UpdateRoomIDRequest message. Does not implicitly {@link qihoo.protocol.chatroom.UpdateRoomIDRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDRequest} message UpdateRoomIDRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateRoomIDRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameid);
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.roomid);
                    return writer;
                };

                /**
                 * Encodes the specified UpdateRoomIDRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.UpdateRoomIDRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDRequest} message UpdateRoomIDRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateRoomIDRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateRoomIDRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDRequest} UpdateRoomIDRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateRoomIDRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.UpdateRoomIDRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.gameid = reader.string();
                                break;
                            case 2:
                                message.roomid = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("gameid"))
                        throw $util.ProtocolError("missing required 'gameid'", { instance: message });
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an UpdateRoomIDRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDRequest} UpdateRoomIDRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateRoomIDRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateRoomIDRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateRoomIDRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.gameid))
                        return "gameid: string expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    return null;
                };

                /**
                 * Creates an UpdateRoomIDRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDRequest} UpdateRoomIDRequest
                 */
                UpdateRoomIDRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.UpdateRoomIDRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.UpdateRoomIDRequest();
                    if(object.gameid != null)
                        message.gameid = String(object.gameid);
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateRoomIDRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.UpdateRoomIDRequest} message UpdateRoomIDRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateRoomIDRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.gameid = "";
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                    }
                    if(message.gameid != null && message.hasOwnProperty("gameid"))
                        object.gameid = message.gameid;
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    return object;
                };

                /**
                 * Converts this UpdateRoomIDRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateRoomIDRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateRoomIDRequest;
            })();

            chatroom.UpdateRoomIDResponse = (function () {

                /**
                 * Properties of an UpdateRoomIDResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IUpdateRoomIDResponse
                 */

                /**
                 * Constructs a new UpdateRoomIDResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an UpdateRoomIDResponse.
                 * @implements IUpdateRoomIDResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDResponse=} [properties] Properties to set
                 */
                function UpdateRoomIDResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new UpdateRoomIDResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDResponse} UpdateRoomIDResponse instance
                 */
                UpdateRoomIDResponse.create = function create(properties) {
                    return new UpdateRoomIDResponse(properties);
                };

                /**
                 * Encodes the specified UpdateRoomIDResponse message. Does not implicitly {@link qihoo.protocol.chatroom.UpdateRoomIDResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDResponse} message UpdateRoomIDResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateRoomIDResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateRoomIDResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.UpdateRoomIDResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateRoomIDResponse} message UpdateRoomIDResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateRoomIDResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateRoomIDResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDResponse} UpdateRoomIDResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateRoomIDResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.UpdateRoomIDResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateRoomIDResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDResponse} UpdateRoomIDResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateRoomIDResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateRoomIDResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateRoomIDResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdateRoomIDResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.UpdateRoomIDResponse} UpdateRoomIDResponse
                 */
                UpdateRoomIDResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.UpdateRoomIDResponse)
                        return object;
                    return new $root.qihoo.protocol.chatroom.UpdateRoomIDResponse();
                };

                /**
                 * Creates a plain object from an UpdateRoomIDResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.UpdateRoomIDResponse} message UpdateRoomIDResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateRoomIDResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdateRoomIDResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.UpdateRoomIDResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateRoomIDResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateRoomIDResponse;
            })();

            chatroom.UpdateChatRoomRequest = (function () {

                /**
                 * Properties of an UpdateChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IUpdateChatRoomRequest
                 * @property {Uint8Array} roomid UpdateChatRoomRequest roomid
                 * @property {qihoo.protocol.chatroom.IChatRoom} room UpdateChatRoomRequest room
                 */

                /**
                 * Constructs a new UpdateChatRoomRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an UpdateChatRoomRequest.
                 * @implements IUpdateChatRoomRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomRequest=} [properties] Properties to set
                 */
                function UpdateChatRoomRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateChatRoomRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @instance
                 */
                UpdateChatRoomRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * UpdateChatRoomRequest room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @instance
                 */
                UpdateChatRoomRequest.prototype.room = null;

                /**
                 * Creates a new UpdateChatRoomRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomRequest} UpdateChatRoomRequest instance
                 */
                UpdateChatRoomRequest.create = function create(properties) {
                    return new UpdateChatRoomRequest(properties);
                };

                /**
                 * Encodes the specified UpdateChatRoomRequest message. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomRequest} message UpdateChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateChatRoomRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomRequest} message UpdateChatRoomRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateChatRoomRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomRequest} UpdateChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.UpdateChatRoomRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an UpdateChatRoomRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomRequest} UpdateChatRoomRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateChatRoomRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateChatRoomRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateChatRoomRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomRequest} UpdateChatRoomRequest
                 */
                UpdateChatRoomRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.UpdateChatRoomRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.UpdateChatRoomRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.UpdateChatRoomRequest.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateChatRoomRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.UpdateChatRoomRequest} message UpdateChatRoomRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateChatRoomRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.room = null;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this UpdateChatRoomRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateChatRoomRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateChatRoomRequest;
            })();

            chatroom.UpdateChatRoomResponse = (function () {

                /**
                 * Properties of an UpdateChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IUpdateChatRoomResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] UpdateChatRoomResponse room
                 */

                /**
                 * Constructs a new UpdateChatRoomResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an UpdateChatRoomResponse.
                 * @implements IUpdateChatRoomResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomResponse=} [properties] Properties to set
                 */
                function UpdateChatRoomResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateChatRoomResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @instance
                 */
                UpdateChatRoomResponse.prototype.room = null;

                /**
                 * Creates a new UpdateChatRoomResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomResponse} UpdateChatRoomResponse instance
                 */
                UpdateChatRoomResponse.create = function create(properties) {
                    return new UpdateChatRoomResponse(properties);
                };

                /**
                 * Encodes the specified UpdateChatRoomResponse message. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomResponse} message UpdateChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateChatRoomResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomResponse} message UpdateChatRoomResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateChatRoomResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomResponse} UpdateChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.UpdateChatRoomResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateChatRoomResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomResponse} UpdateChatRoomResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateChatRoomResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateChatRoomResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateChatRoomResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomResponse} UpdateChatRoomResponse
                 */
                UpdateChatRoomResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.UpdateChatRoomResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.UpdateChatRoomResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.UpdateChatRoomResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateChatRoomResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.UpdateChatRoomResponse} message UpdateChatRoomResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateChatRoomResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this UpdateChatRoomResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateChatRoomResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateChatRoomResponse;
            })();

            chatroom.KickChatRoomMemberRequest = (function () {

                /**
                 * Properties of a KickChatRoomMemberRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IKickChatRoomMemberRequest
                 * @property {Uint8Array} roomid KickChatRoomMemberRequest roomid
                 * @property {Array.<qihoo.protocol.chatroom.ICRUser>|null} [members] KickChatRoomMemberRequest members
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] KickChatRoomMemberRequest room
                 */

                /**
                 * Constructs a new KickChatRoomMemberRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a KickChatRoomMemberRequest.
                 * @implements IKickChatRoomMemberRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberRequest=} [properties] Properties to set
                 */
                function KickChatRoomMemberRequest(properties) {
                    this.members = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KickChatRoomMemberRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @instance
                 */
                KickChatRoomMemberRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * KickChatRoomMemberRequest members.
                 * @member {Array.<qihoo.protocol.chatroom.ICRUser>} members
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @instance
                 */
                KickChatRoomMemberRequest.prototype.members = $util.emptyArray;

                /**
                 * KickChatRoomMemberRequest room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @instance
                 */
                KickChatRoomMemberRequest.prototype.room = null;

                /**
                 * Creates a new KickChatRoomMemberRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberRequest} KickChatRoomMemberRequest instance
                 */
                KickChatRoomMemberRequest.create = function create(properties) {
                    return new KickChatRoomMemberRequest(properties);
                };

                /**
                 * Encodes the specified KickChatRoomMemberRequest message. Does not implicitly {@link qihoo.protocol.chatroom.KickChatRoomMemberRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberRequest} message KickChatRoomMemberRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickChatRoomMemberRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.members != null && message.members.length)
                        for(let i = 0; i < message.members.length; ++i)
                            $root.qihoo.protocol.chatroom.CRUser.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified KickChatRoomMemberRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.KickChatRoomMemberRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberRequest} message KickChatRoomMemberRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickChatRoomMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KickChatRoomMemberRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberRequest} KickChatRoomMemberRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickChatRoomMemberRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                if(!(message.members && message.members.length))
                                    message.members = [];
                                message.members.push($root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a KickChatRoomMemberRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberRequest} KickChatRoomMemberRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickChatRoomMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KickChatRoomMemberRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KickChatRoomMemberRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.members != null && message.hasOwnProperty("members")) {
                        if(!Array.isArray(message.members))
                            return "members: array expected";
                        for(let i = 0; i < message.members.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.members[i]);
                            if(error)
                                return "members." + error;
                        }
                    }
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a KickChatRoomMemberRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberRequest} KickChatRoomMemberRequest
                 */
                KickChatRoomMemberRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.members) {
                        if(!Array.isArray(object.members))
                            throw TypeError(".qihoo.protocol.chatroom.KickChatRoomMemberRequest.members: array expected");
                        message.members = [];
                        for(let i = 0; i < object.members.length; ++i) {
                            if(typeof object.members[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.KickChatRoomMemberRequest.members: object expected");
                            message.members[i] = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.members[i]);
                        }
                    }
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.KickChatRoomMemberRequest.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a KickChatRoomMemberRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.KickChatRoomMemberRequest} message KickChatRoomMemberRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KickChatRoomMemberRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.members = [];
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.room = null;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.members && message.members.length) {
                        object.members = [];
                        for(let j = 0; j < message.members.length; ++j)
                            object.members[j] = $root.qihoo.protocol.chatroom.CRUser.toObject(message.members[j], options);
                    }
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this KickChatRoomMemberRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KickChatRoomMemberRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KickChatRoomMemberRequest;
            })();

            chatroom.KickChatRoomMemberResponse = (function () {

                /**
                 * Properties of a KickChatRoomMemberResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IKickChatRoomMemberResponse
                 * @property {qihoo.protocol.chatroom.IChatRoom|null} [room] KickChatRoomMemberResponse room
                 */

                /**
                 * Constructs a new KickChatRoomMemberResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a KickChatRoomMemberResponse.
                 * @implements IKickChatRoomMemberResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberResponse=} [properties] Properties to set
                 */
                function KickChatRoomMemberResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KickChatRoomMemberResponse room.
                 * @member {qihoo.protocol.chatroom.IChatRoom|null|undefined} room
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @instance
                 */
                KickChatRoomMemberResponse.prototype.room = null;

                /**
                 * Creates a new KickChatRoomMemberResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberResponse} KickChatRoomMemberResponse instance
                 */
                KickChatRoomMemberResponse.create = function create(properties) {
                    return new KickChatRoomMemberResponse(properties);
                };

                /**
                 * Encodes the specified KickChatRoomMemberResponse message. Does not implicitly {@link qihoo.protocol.chatroom.KickChatRoomMemberResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberResponse} message KickChatRoomMemberResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickChatRoomMemberResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.room != null && message.hasOwnProperty("room"))
                        $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified KickChatRoomMemberResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.KickChatRoomMemberResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickChatRoomMemberResponse} message KickChatRoomMemberResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickChatRoomMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KickChatRoomMemberResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberResponse} KickChatRoomMemberResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickChatRoomMemberResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KickChatRoomMemberResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberResponse} KickChatRoomMemberResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickChatRoomMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KickChatRoomMemberResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KickChatRoomMemberResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.room != null && message.hasOwnProperty("room")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a KickChatRoomMemberResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.KickChatRoomMemberResponse} KickChatRoomMemberResponse
                 */
                KickChatRoomMemberResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.KickChatRoomMemberResponse.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a KickChatRoomMemberResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.KickChatRoomMemberResponse} message KickChatRoomMemberResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KickChatRoomMemberResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this KickChatRoomMemberResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.KickChatRoomMemberResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KickChatRoomMemberResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KickChatRoomMemberResponse;
            })();

            chatroom.SyncRoomToDBRequest = (function () {

                /**
                 * Properties of a SyncRoomToDBRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ISyncRoomToDBRequest
                 * @property {Uint8Array} roomid SyncRoomToDBRequest roomid
                 */

                /**
                 * Constructs a new SyncRoomToDBRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a SyncRoomToDBRequest.
                 * @implements ISyncRoomToDBRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ISyncRoomToDBRequest=} [properties] Properties to set
                 */
                function SyncRoomToDBRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SyncRoomToDBRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @instance
                 */
                SyncRoomToDBRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * Creates a new SyncRoomToDBRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISyncRoomToDBRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.SyncRoomToDBRequest} SyncRoomToDBRequest instance
                 */
                SyncRoomToDBRequest.create = function create(properties) {
                    return new SyncRoomToDBRequest(properties);
                };

                /**
                 * Encodes the specified SyncRoomToDBRequest message. Does not implicitly {@link qihoo.protocol.chatroom.SyncRoomToDBRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISyncRoomToDBRequest} message SyncRoomToDBRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyncRoomToDBRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    return writer;
                };

                /**
                 * Encodes the specified SyncRoomToDBRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.SyncRoomToDBRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISyncRoomToDBRequest} message SyncRoomToDBRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SyncRoomToDBRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SyncRoomToDBRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.SyncRoomToDBRequest} SyncRoomToDBRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyncRoomToDBRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.SyncRoomToDBRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SyncRoomToDBRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.SyncRoomToDBRequest} SyncRoomToDBRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SyncRoomToDBRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SyncRoomToDBRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SyncRoomToDBRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    return null;
                };

                /**
                 * Creates a SyncRoomToDBRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.SyncRoomToDBRequest} SyncRoomToDBRequest
                 */
                SyncRoomToDBRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.SyncRoomToDBRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.SyncRoomToDBRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    return message;
                };

                /**
                 * Creates a plain object from a SyncRoomToDBRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.SyncRoomToDBRequest} message SyncRoomToDBRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SyncRoomToDBRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    return object;
                };

                /**
                 * Converts this SyncRoomToDBRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.SyncRoomToDBRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SyncRoomToDBRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SyncRoomToDBRequest;
            })();

            chatroom.CreateChatRoomNotify = (function () {

                /**
                 * Properties of a CreateChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ICreateChatRoomNotify
                 * @property {qihoo.protocol.chatroom.IChatRoom} room CreateChatRoomNotify room
                 */

                /**
                 * Constructs a new CreateChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a CreateChatRoomNotify.
                 * @implements ICreateChatRoomNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomNotify=} [properties] Properties to set
                 */
                function CreateChatRoomNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateChatRoomNotify room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @instance
                 */
                CreateChatRoomNotify.prototype.room = null;

                /**
                 * Creates a new CreateChatRoomNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomNotify} CreateChatRoomNotify instance
                 */
                CreateChatRoomNotify.create = function create(properties) {
                    return new CreateChatRoomNotify(properties);
                };

                /**
                 * Encodes the specified CreateChatRoomNotify message. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomNotify} message CreateChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateChatRoomNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.CreateChatRoomNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.ICreateChatRoomNotify} message CreateChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateChatRoomNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateChatRoomNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomNotify} CreateChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.CreateChatRoomNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a CreateChatRoomNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomNotify} CreateChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateChatRoomNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateChatRoomNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateChatRoomNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateChatRoomNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.CreateChatRoomNotify} CreateChatRoomNotify
                 */
                CreateChatRoomNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.CreateChatRoomNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.CreateChatRoomNotify();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.CreateChatRoomNotify.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateChatRoomNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.CreateChatRoomNotify} message CreateChatRoomNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateChatRoomNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this CreateChatRoomNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.CreateChatRoomNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateChatRoomNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateChatRoomNotify;
            })();

            chatroom.MemberJoinChatRoomNotify = (function () {

                /**
                 * Properties of a MemberJoinChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IMemberJoinChatRoomNotify
                 * @property {qihoo.protocol.chatroom.IChatRoom} room MemberJoinChatRoomNotify room
                 */

                /**
                 * Constructs a new MemberJoinChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a MemberJoinChatRoomNotify.
                 * @implements IMemberJoinChatRoomNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify=} [properties] Properties to set
                 */
                function MemberJoinChatRoomNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MemberJoinChatRoomNotify room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @instance
                 */
                MemberJoinChatRoomNotify.prototype.room = null;

                /**
                 * Creates a new MemberJoinChatRoomNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.MemberJoinChatRoomNotify} MemberJoinChatRoomNotify instance
                 */
                MemberJoinChatRoomNotify.create = function create(properties) {
                    return new MemberJoinChatRoomNotify(properties);
                };

                /**
                 * Encodes the specified MemberJoinChatRoomNotify message. Does not implicitly {@link qihoo.protocol.chatroom.MemberJoinChatRoomNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify} message MemberJoinChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemberJoinChatRoomNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MemberJoinChatRoomNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.MemberJoinChatRoomNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify} message MemberJoinChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemberJoinChatRoomNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MemberJoinChatRoomNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.MemberJoinChatRoomNotify} MemberJoinChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemberJoinChatRoomNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MemberJoinChatRoomNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.MemberJoinChatRoomNotify} MemberJoinChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemberJoinChatRoomNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MemberJoinChatRoomNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MemberJoinChatRoomNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MemberJoinChatRoomNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.MemberJoinChatRoomNotify} MemberJoinChatRoomNotify
                 */
                MemberJoinChatRoomNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.MemberJoinChatRoomNotify.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MemberJoinChatRoomNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.MemberJoinChatRoomNotify} message MemberJoinChatRoomNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MemberJoinChatRoomNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this MemberJoinChatRoomNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.MemberJoinChatRoomNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MemberJoinChatRoomNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MemberJoinChatRoomNotify;
            })();

            chatroom.MemberQuitChatRoomNotify = (function () {

                /**
                 * Properties of a MemberQuitChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IMemberQuitChatRoomNotify
                 * @property {qihoo.protocol.chatroom.IChatRoom} room MemberQuitChatRoomNotify room
                 */

                /**
                 * Constructs a new MemberQuitChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a MemberQuitChatRoomNotify.
                 * @implements IMemberQuitChatRoomNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify=} [properties] Properties to set
                 */
                function MemberQuitChatRoomNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MemberQuitChatRoomNotify room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @instance
                 */
                MemberQuitChatRoomNotify.prototype.room = null;

                /**
                 * Creates a new MemberQuitChatRoomNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.MemberQuitChatRoomNotify} MemberQuitChatRoomNotify instance
                 */
                MemberQuitChatRoomNotify.create = function create(properties) {
                    return new MemberQuitChatRoomNotify(properties);
                };

                /**
                 * Encodes the specified MemberQuitChatRoomNotify message. Does not implicitly {@link qihoo.protocol.chatroom.MemberQuitChatRoomNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify} message MemberQuitChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemberQuitChatRoomNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified MemberQuitChatRoomNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.MemberQuitChatRoomNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify} message MemberQuitChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemberQuitChatRoomNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MemberQuitChatRoomNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.MemberQuitChatRoomNotify} MemberQuitChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemberQuitChatRoomNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a MemberQuitChatRoomNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.MemberQuitChatRoomNotify} MemberQuitChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemberQuitChatRoomNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MemberQuitChatRoomNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MemberQuitChatRoomNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    return null;
                };

                /**
                 * Creates a MemberQuitChatRoomNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.MemberQuitChatRoomNotify} MemberQuitChatRoomNotify
                 */
                MemberQuitChatRoomNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.MemberQuitChatRoomNotify.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MemberQuitChatRoomNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.MemberQuitChatRoomNotify} message MemberQuitChatRoomNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MemberQuitChatRoomNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.room = null;
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    return object;
                };

                /**
                 * Converts this MemberQuitChatRoomNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.MemberQuitChatRoomNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MemberQuitChatRoomNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MemberQuitChatRoomNotify;
            })();

            chatroom.KickMemberNotify = (function () {

                /**
                 * Properties of a KickMemberNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IKickMemberNotify
                 * @property {qihoo.protocol.chatroom.IChatRoom} room KickMemberNotify room
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [user] KickMemberNotify user
                 */

                /**
                 * Constructs a new KickMemberNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a KickMemberNotify.
                 * @implements IKickMemberNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IKickMemberNotify=} [properties] Properties to set
                 */
                function KickMemberNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KickMemberNotify room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @instance
                 */
                KickMemberNotify.prototype.room = null;

                /**
                 * KickMemberNotify user.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} user
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @instance
                 */
                KickMemberNotify.prototype.user = null;

                /**
                 * Creates a new KickMemberNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickMemberNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.KickMemberNotify} KickMemberNotify instance
                 */
                KickMemberNotify.create = function create(properties) {
                    return new KickMemberNotify(properties);
                };

                /**
                 * Encodes the specified KickMemberNotify message. Does not implicitly {@link qihoo.protocol.chatroom.KickMemberNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickMemberNotify} message KickMemberNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickMemberNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.user != null && message.hasOwnProperty("user"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified KickMemberNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.KickMemberNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IKickMemberNotify} message KickMemberNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KickMemberNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KickMemberNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.KickMemberNotify} KickMemberNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickMemberNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.KickMemberNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.user = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a KickMemberNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.KickMemberNotify} KickMemberNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KickMemberNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KickMemberNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                KickMemberNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    if(message.user != null && message.hasOwnProperty("user")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.user);
                        if(error)
                            return "user." + error;
                    }
                    return null;
                };

                /**
                 * Creates a KickMemberNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.KickMemberNotify} KickMemberNotify
                 */
                KickMemberNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.KickMemberNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.KickMemberNotify();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.KickMemberNotify.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    if(object.user != null) {
                        if(typeof object.user !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.KickMemberNotify.user: object expected");
                        message.user = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.user);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a KickMemberNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.KickMemberNotify} message KickMemberNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KickMemberNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.room = null;
                        object.user = null;
                    }
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    if(message.user != null && message.hasOwnProperty("user"))
                        object.user = $root.qihoo.protocol.chatroom.CRUser.toObject(message.user, options);
                    return object;
                };

                /**
                 * Converts this KickMemberNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.KickMemberNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                KickMemberNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KickMemberNotify;
            })();

            chatroom.UpdateChatRoomNotify = (function () {

                /**
                 * Properties of an UpdateChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IUpdateChatRoomNotify
                 * @property {qihoo.protocol.chatroom.IChatRoom} room UpdateChatRoomNotify room
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [user] UpdateChatRoomNotify user
                 */

                /**
                 * Constructs a new UpdateChatRoomNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents an UpdateChatRoomNotify.
                 * @implements IUpdateChatRoomNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomNotify=} [properties] Properties to set
                 */
                function UpdateChatRoomNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateChatRoomNotify room.
                 * @member {qihoo.protocol.chatroom.IChatRoom} room
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @instance
                 */
                UpdateChatRoomNotify.prototype.room = null;

                /**
                 * UpdateChatRoomNotify user.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} user
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @instance
                 */
                UpdateChatRoomNotify.prototype.user = null;

                /**
                 * Creates a new UpdateChatRoomNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomNotify} UpdateChatRoomNotify instance
                 */
                UpdateChatRoomNotify.create = function create(properties) {
                    return new UpdateChatRoomNotify(properties);
                };

                /**
                 * Encodes the specified UpdateChatRoomNotify message. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomNotify} message UpdateChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    $root.qihoo.protocol.chatroom.ChatRoom.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.user != null && message.hasOwnProperty("user"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.user, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UpdateChatRoomNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.UpdateChatRoomNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IUpdateChatRoomNotify} message UpdateChatRoomNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateChatRoomNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateChatRoomNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomNotify} UpdateChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.UpdateChatRoomNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.room = $root.qihoo.protocol.chatroom.ChatRoom.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.user = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("room"))
                        throw $util.ProtocolError("missing required 'room'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an UpdateChatRoomNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomNotify} UpdateChatRoomNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateChatRoomNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateChatRoomNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateChatRoomNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.qihoo.protocol.chatroom.ChatRoom.verify(message.room);
                        if(error)
                            return "room." + error;
                    }
                    if(message.user != null && message.hasOwnProperty("user")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.user);
                        if(error)
                            return "user." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateChatRoomNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.UpdateChatRoomNotify} UpdateChatRoomNotify
                 */
                UpdateChatRoomNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.UpdateChatRoomNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.UpdateChatRoomNotify();
                    if(object.room != null) {
                        if(typeof object.room !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.UpdateChatRoomNotify.room: object expected");
                        message.room = $root.qihoo.protocol.chatroom.ChatRoom.fromObject(object.room);
                    }
                    if(object.user != null) {
                        if(typeof object.user !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.UpdateChatRoomNotify.user: object expected");
                        message.user = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.user);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateChatRoomNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.UpdateChatRoomNotify} message UpdateChatRoomNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateChatRoomNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.room = null;
                        object.user = null;
                    }
                    if(message.room != null && message.hasOwnProperty("room"))
                        object.room = $root.qihoo.protocol.chatroom.ChatRoom.toObject(message.room, options);
                    if(message.user != null && message.hasOwnProperty("user"))
                        object.user = $root.qihoo.protocol.chatroom.CRUser.toObject(message.user, options);
                    return object;
                };

                /**
                 * Converts this UpdateChatRoomNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.UpdateChatRoomNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateChatRoomNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateChatRoomNotify;
            })();

            chatroom.ChatRoomMessageRequest = (function () {

                /**
                 * Properties of a ChatRoomMessageRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomMessageRequest
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [sender] ChatRoomMessageRequest sender
                 * @property {Uint8Array} roomid ChatRoomMessageRequest roomid
                 * @property {number} msgtype ChatRoomMessageRequest msgtype
                 * @property {Uint8Array|null} [msgcontent] ChatRoomMessageRequest msgcontent
                 * @property {Uint8Array|null} [clientparameter] ChatRoomMessageRequest clientparameter
                 * @property {Uint8Array|null} [clientcache] ChatRoomMessageRequest clientcache
                 * @property {qihoo.protocol.chatroom.ICreateChatRoomNotify|null} [createnotify] ChatRoomMessageRequest createnotify
                 * @property {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify|null} [joinnotify] ChatRoomMessageRequest joinnotify
                 * @property {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify|null} [quitnotify] ChatRoomMessageRequest quitnotify
                 * @property {qihoo.protocol.chatroom.IKickMemberNotify|null} [kicknotify] ChatRoomMessageRequest kicknotify
                 * @property {qihoo.protocol.chatroom.IUpdateChatRoomNotify|null} [updatenotify] ChatRoomMessageRequest updatenotify
                 * @property {Array.<qihoo.protocol.chatroom.ICRPair>|null} [propertylist] ChatRoomMessageRequest propertylist
                 */

                /**
                 * Constructs a new ChatRoomMessageRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomMessageRequest.
                 * @implements IChatRoomMessageRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageRequest=} [properties] Properties to set
                 */
                function ChatRoomMessageRequest(properties) {
                    this.propertylist = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomMessageRequest sender.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} sender
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.sender = null;

                /**
                 * ChatRoomMessageRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * ChatRoomMessageRequest msgtype.
                 * @member {number} msgtype
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.msgtype = 0;

                /**
                 * ChatRoomMessageRequest msgcontent.
                 * @member {Uint8Array} msgcontent
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.msgcontent = $util.newBuffer([]);

                /**
                 * ChatRoomMessageRequest clientparameter.
                 * @member {Uint8Array} clientparameter
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.clientparameter = $util.newBuffer([]);

                /**
                 * ChatRoomMessageRequest clientcache.
                 * @member {Uint8Array} clientcache
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.clientcache = $util.newBuffer([]);

                /**
                 * ChatRoomMessageRequest createnotify.
                 * @member {qihoo.protocol.chatroom.ICreateChatRoomNotify|null|undefined} createnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.createnotify = null;

                /**
                 * ChatRoomMessageRequest joinnotify.
                 * @member {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify|null|undefined} joinnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.joinnotify = null;

                /**
                 * ChatRoomMessageRequest quitnotify.
                 * @member {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify|null|undefined} quitnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.quitnotify = null;

                /**
                 * ChatRoomMessageRequest kicknotify.
                 * @member {qihoo.protocol.chatroom.IKickMemberNotify|null|undefined} kicknotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.kicknotify = null;

                /**
                 * ChatRoomMessageRequest updatenotify.
                 * @member {qihoo.protocol.chatroom.IUpdateChatRoomNotify|null|undefined} updatenotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.updatenotify = null;

                /**
                 * ChatRoomMessageRequest propertylist.
                 * @member {Array.<qihoo.protocol.chatroom.ICRPair>} propertylist
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 */
                ChatRoomMessageRequest.prototype.propertylist = $util.emptyArray;

                /**
                 * Creates a new ChatRoomMessageRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageRequest} ChatRoomMessageRequest instance
                 */
                ChatRoomMessageRequest.create = function create(properties) {
                    return new ChatRoomMessageRequest(properties);
                };

                /**
                 * Encodes the specified ChatRoomMessageRequest message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMessageRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageRequest} message ChatRoomMessageRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMessageRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.sender, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.roomid);
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgtype);
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msgcontent);
                    if(message.clientparameter != null && message.hasOwnProperty("clientparameter"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.clientparameter);
                    if(message.clientcache != null && message.hasOwnProperty("clientcache"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.clientcache);
                    if(message.createnotify != null && message.hasOwnProperty("createnotify"))
                        $root.qihoo.protocol.chatroom.CreateChatRoomNotify.encode(message.createnotify, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if(message.joinnotify != null && message.hasOwnProperty("joinnotify"))
                        $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.encode(message.joinnotify, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if(message.quitnotify != null && message.hasOwnProperty("quitnotify"))
                        $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.encode(message.quitnotify, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.kicknotify != null && message.hasOwnProperty("kicknotify"))
                        $root.qihoo.protocol.chatroom.KickMemberNotify.encode(message.kicknotify, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if(message.updatenotify != null && message.hasOwnProperty("updatenotify"))
                        $root.qihoo.protocol.chatroom.UpdateChatRoomNotify.encode(message.updatenotify, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if(message.propertylist != null && message.propertylist.length)
                        for(let i = 0; i < message.propertylist.length; ++i)
                            $root.qihoo.protocol.chatroom.CRPair.encode(message.propertylist[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomMessageRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMessageRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageRequest} message ChatRoomMessageRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomMessageRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageRequest} ChatRoomMessageRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMessageRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomMessageRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.sender = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.roomid = reader.bytes();
                                break;
                            case 3:
                                message.msgtype = reader.int32();
                                break;
                            case 4:
                                message.msgcontent = reader.bytes();
                                break;
                            case 5:
                                message.clientparameter = reader.bytes();
                                break;
                            case 6:
                                message.clientcache = reader.bytes();
                                break;
                            case 7:
                                message.createnotify = $root.qihoo.protocol.chatroom.CreateChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.joinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.quitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.kicknotify = $root.qihoo.protocol.chatroom.KickMemberNotify.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.updatenotify = $root.qihoo.protocol.chatroom.UpdateChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 12:
                                if(!(message.propertylist && message.propertylist.length))
                                    message.propertylist = [];
                                message.propertylist.push($root.qihoo.protocol.chatroom.CRPair.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    if(!message.hasOwnProperty("msgtype"))
                        throw $util.ProtocolError("missing required 'msgtype'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomMessageRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageRequest} ChatRoomMessageRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomMessageRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomMessageRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.sender != null && message.hasOwnProperty("sender")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.sender);
                        if(error)
                            return "sender." + error;
                    }
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(!$util.isInteger(message.msgtype))
                        return "msgtype: integer expected";
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        if(!(message.msgcontent && typeof message.msgcontent.length === "number" || $util.isString(message.msgcontent)))
                            return "msgcontent: buffer expected";
                    if(message.clientparameter != null && message.hasOwnProperty("clientparameter"))
                        if(!(message.clientparameter && typeof message.clientparameter.length === "number" || $util.isString(message.clientparameter)))
                            return "clientparameter: buffer expected";
                    if(message.clientcache != null && message.hasOwnProperty("clientcache"))
                        if(!(message.clientcache && typeof message.clientcache.length === "number" || $util.isString(message.clientcache)))
                            return "clientcache: buffer expected";
                    if(message.createnotify != null && message.hasOwnProperty("createnotify")) {
                        let error = $root.qihoo.protocol.chatroom.CreateChatRoomNotify.verify(message.createnotify);
                        if(error)
                            return "createnotify." + error;
                    }
                    if(message.joinnotify != null && message.hasOwnProperty("joinnotify")) {
                        let error = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.verify(message.joinnotify);
                        if(error)
                            return "joinnotify." + error;
                    }
                    if(message.quitnotify != null && message.hasOwnProperty("quitnotify")) {
                        let error = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.verify(message.quitnotify);
                        if(error)
                            return "quitnotify." + error;
                    }
                    if(message.kicknotify != null && message.hasOwnProperty("kicknotify")) {
                        let error = $root.qihoo.protocol.chatroom.KickMemberNotify.verify(message.kicknotify);
                        if(error)
                            return "kicknotify." + error;
                    }
                    if(message.updatenotify != null && message.hasOwnProperty("updatenotify")) {
                        let error = $root.qihoo.protocol.chatroom.UpdateChatRoomNotify.verify(message.updatenotify);
                        if(error)
                            return "updatenotify." + error;
                    }
                    if(message.propertylist != null && message.hasOwnProperty("propertylist")) {
                        if(!Array.isArray(message.propertylist))
                            return "propertylist: array expected";
                        for(let i = 0; i < message.propertylist.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.CRPair.verify(message.propertylist[i]);
                            if(error)
                                return "propertylist." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ChatRoomMessageRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageRequest} ChatRoomMessageRequest
                 */
                ChatRoomMessageRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomMessageRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomMessageRequest();
                    if(object.sender != null) {
                        if(typeof object.sender !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.sender: object expected");
                        message.sender = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.sender);
                    }
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.msgtype != null)
                        message.msgtype = object.msgtype | 0;
                    if(object.msgcontent != null)
                        if(typeof object.msgcontent === "string")
                            $util.base64.decode(object.msgcontent, message.msgcontent = $util.newBuffer($util.base64.length(object.msgcontent)), 0);
                        else if(object.msgcontent.length)
                            message.msgcontent = object.msgcontent;
                    if(object.clientparameter != null)
                        if(typeof object.clientparameter === "string")
                            $util.base64.decode(object.clientparameter, message.clientparameter = $util.newBuffer($util.base64.length(object.clientparameter)), 0);
                        else if(object.clientparameter.length)
                            message.clientparameter = object.clientparameter;
                    if(object.clientcache != null)
                        if(typeof object.clientcache === "string")
                            $util.base64.decode(object.clientcache, message.clientcache = $util.newBuffer($util.base64.length(object.clientcache)), 0);
                        else if(object.clientcache.length)
                            message.clientcache = object.clientcache;
                    if(object.createnotify != null) {
                        if(typeof object.createnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.createnotify: object expected");
                        message.createnotify = $root.qihoo.protocol.chatroom.CreateChatRoomNotify.fromObject(object.createnotify);
                    }
                    if(object.joinnotify != null) {
                        if(typeof object.joinnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.joinnotify: object expected");
                        message.joinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.fromObject(object.joinnotify);
                    }
                    if(object.quitnotify != null) {
                        if(typeof object.quitnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.quitnotify: object expected");
                        message.quitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.fromObject(object.quitnotify);
                    }
                    if(object.kicknotify != null) {
                        if(typeof object.kicknotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.kicknotify: object expected");
                        message.kicknotify = $root.qihoo.protocol.chatroom.KickMemberNotify.fromObject(object.kicknotify);
                    }
                    if(object.updatenotify != null) {
                        if(typeof object.updatenotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.updatenotify: object expected");
                        message.updatenotify = $root.qihoo.protocol.chatroom.UpdateChatRoomNotify.fromObject(object.updatenotify);
                    }
                    if(object.propertylist) {
                        if(!Array.isArray(object.propertylist))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.propertylist: array expected");
                        message.propertylist = [];
                        for(let i = 0; i < object.propertylist.length; ++i) {
                            if(typeof object.propertylist[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.ChatRoomMessageRequest.propertylist: object expected");
                            message.propertylist[i] = $root.qihoo.protocol.chatroom.CRPair.fromObject(object.propertylist[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomMessageRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomMessageRequest} message ChatRoomMessageRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomMessageRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.propertylist = [];
                    if(options.defaults) {
                        object.sender = null;
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.msgtype = 0;
                        if(options.bytes === String)
                            object.msgcontent = "";
                        else {
                            object.msgcontent = [];
                            if(options.bytes !== Array)
                                object.msgcontent = $util.newBuffer(object.msgcontent);
                        }
                        if(options.bytes === String)
                            object.clientparameter = "";
                        else {
                            object.clientparameter = [];
                            if(options.bytes !== Array)
                                object.clientparameter = $util.newBuffer(object.clientparameter);
                        }
                        if(options.bytes === String)
                            object.clientcache = "";
                        else {
                            object.clientcache = [];
                            if(options.bytes !== Array)
                                object.clientcache = $util.newBuffer(object.clientcache);
                        }
                        object.createnotify = null;
                        object.joinnotify = null;
                        object.quitnotify = null;
                        object.kicknotify = null;
                        object.updatenotify = null;
                    }
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = $root.qihoo.protocol.chatroom.CRUser.toObject(message.sender, options);
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.msgtype != null && message.hasOwnProperty("msgtype"))
                        object.msgtype = message.msgtype;
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        object.msgcontent = options.bytes === String ? $util.base64.encode(message.msgcontent, 0, message.msgcontent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgcontent) : message.msgcontent;
                    if(message.clientparameter != null && message.hasOwnProperty("clientparameter"))
                        object.clientparameter = options.bytes === String ? $util.base64.encode(message.clientparameter, 0, message.clientparameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientparameter) : message.clientparameter;
                    if(message.clientcache != null && message.hasOwnProperty("clientcache"))
                        object.clientcache = options.bytes === String ? $util.base64.encode(message.clientcache, 0, message.clientcache.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientcache) : message.clientcache;
                    if(message.createnotify != null && message.hasOwnProperty("createnotify"))
                        object.createnotify = $root.qihoo.protocol.chatroom.CreateChatRoomNotify.toObject(message.createnotify, options);
                    if(message.joinnotify != null && message.hasOwnProperty("joinnotify"))
                        object.joinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.toObject(message.joinnotify, options);
                    if(message.quitnotify != null && message.hasOwnProperty("quitnotify"))
                        object.quitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.toObject(message.quitnotify, options);
                    if(message.kicknotify != null && message.hasOwnProperty("kicknotify"))
                        object.kicknotify = $root.qihoo.protocol.chatroom.KickMemberNotify.toObject(message.kicknotify, options);
                    if(message.updatenotify != null && message.hasOwnProperty("updatenotify"))
                        object.updatenotify = $root.qihoo.protocol.chatroom.UpdateChatRoomNotify.toObject(message.updatenotify, options);
                    if(message.propertylist && message.propertylist.length) {
                        object.propertylist = [];
                        for(let j = 0; j < message.propertylist.length; ++j)
                            object.propertylist[j] = $root.qihoo.protocol.chatroom.CRPair.toObject(message.propertylist[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ChatRoomMessageRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomMessageRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomMessageRequest;
            })();

            chatroom.ChatRoomMessageResponse = (function () {

                /**
                 * Properties of a ChatRoomMessageResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomMessageResponse
                 * @property {number|Long|null} [msgid] ChatRoomMessageResponse msgid
                 */

                /**
                 * Constructs a new ChatRoomMessageResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomMessageResponse.
                 * @implements IChatRoomMessageResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageResponse=} [properties] Properties to set
                 */
                function ChatRoomMessageResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomMessageResponse msgid.
                 * @member {number|Long} msgid
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @instance
                 */
                ChatRoomMessageResponse.prototype.msgid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * Creates a new ChatRoomMessageResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageResponse} ChatRoomMessageResponse instance
                 */
                ChatRoomMessageResponse.create = function create(properties) {
                    return new ChatRoomMessageResponse(properties);
                };

                /**
                 * Encodes the specified ChatRoomMessageResponse message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMessageResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageResponse} message ChatRoomMessageResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMessageResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.msgid);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomMessageResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMessageResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMessageResponse} message ChatRoomMessageResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomMessageResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageResponse} ChatRoomMessageResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMessageResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomMessageResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.msgid = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChatRoomMessageResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageResponse} ChatRoomMessageResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomMessageResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomMessageResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        if(!$util.isInteger(message.msgid) && !(message.msgid && $util.isInteger(message.msgid.low) && $util.isInteger(message.msgid.high)))
                            return "msgid: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ChatRoomMessageResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomMessageResponse} ChatRoomMessageResponse
                 */
                ChatRoomMessageResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomMessageResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomMessageResponse();
                    if(object.msgid != null)
                        if($util.Long)
                            (message.msgid = $util.Long.fromValue(object.msgid)).unsigned = true;
                        else if(typeof object.msgid === "string")
                            message.msgid = parseInt(object.msgid, 10);
                        else if(typeof object.msgid === "number")
                            message.msgid = object.msgid;
                        else if(typeof object.msgid === "object")
                            message.msgid = new $util.LongBits(object.msgid.low >>> 0, object.msgid.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomMessageResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomMessageResponse} message ChatRoomMessageResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomMessageResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.msgid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.msgid = options.longs === String ? "0" : 0;
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        if(typeof message.msgid === "number")
                            object.msgid = options.longs === String ? String(message.msgid) : message.msgid;
                        else
                            object.msgid = options.longs === String ? $util.Long.prototype.toString.call(message.msgid) : options.longs === Number ? new $util.LongBits(message.msgid.low >>> 0, message.msgid.high >>> 0).toNumber(true) : message.msgid;
                    return object;
                };

                /**
                 * Converts this ChatRoomMessageResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomMessageResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomMessageResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomMessageResponse;
            })();

            chatroom.ChatRoomNewMsg = (function () {

                /**
                 * Properties of a ChatRoomNewMsg.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomNewMsg
                 * @property {Uint8Array} roomid ChatRoomNewMsg roomid
                 * @property {qihoo.protocol.chatroom.ICRUser|null} [sender] ChatRoomNewMsg sender
                 * @property {number|null} [msgtype] ChatRoomNewMsg msgtype
                 * @property {Uint8Array|null} [msgcontent] ChatRoomNewMsg msgcontent
                 * @property {number|null} [regmemcount] ChatRoomNewMsg regmemcount
                 * @property {number|null} [memcount] ChatRoomNewMsg memcount
                 * @property {number|null} [msgid] ChatRoomNewMsg msgid
                 * @property {number|null} [maxid] ChatRoomNewMsg maxid
                 * @property {number|Long|null} [timestamp] ChatRoomNewMsg timestamp
                 */

                /**
                 * Constructs a new ChatRoomNewMsg.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomNewMsg.
                 * @implements IChatRoomNewMsg
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomNewMsg=} [properties] Properties to set
                 */
                function ChatRoomNewMsg(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomNewMsg roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.roomid = $util.newBuffer([]);

                /**
                 * ChatRoomNewMsg sender.
                 * @member {qihoo.protocol.chatroom.ICRUser|null|undefined} sender
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.sender = null;

                /**
                 * ChatRoomNewMsg msgtype.
                 * @member {number} msgtype
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.msgtype = 0;

                /**
                 * ChatRoomNewMsg msgcontent.
                 * @member {Uint8Array} msgcontent
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.msgcontent = $util.newBuffer([]);

                /**
                 * ChatRoomNewMsg regmemcount.
                 * @member {number} regmemcount
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.regmemcount = 0;

                /**
                 * ChatRoomNewMsg memcount.
                 * @member {number} memcount
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.memcount = 0;

                /**
                 * ChatRoomNewMsg msgid.
                 * @member {number} msgid
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.msgid = 0;

                /**
                 * ChatRoomNewMsg maxid.
                 * @member {number} maxid
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.maxid = 0;

                /**
                 * ChatRoomNewMsg timestamp.
                 * @member {number|Long} timestamp
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 */
                ChatRoomNewMsg.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * Creates a new ChatRoomNewMsg instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomNewMsg=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomNewMsg} ChatRoomNewMsg instance
                 */
                ChatRoomNewMsg.create = function create(properties) {
                    return new ChatRoomNewMsg(properties);
                };

                /**
                 * Encodes the specified ChatRoomNewMsg message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomNewMsg.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomNewMsg} message ChatRoomNewMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomNewMsg.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        $root.qihoo.protocol.chatroom.CRUser.encode(message.sender, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.msgtype != null && message.hasOwnProperty("msgtype"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.msgtype);
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msgcontent);
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.regmemcount);
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.memcount);
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.msgid);
                    if(message.maxid != null && message.hasOwnProperty("maxid"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.maxid);
                    if(message.timestamp != null && message.hasOwnProperty("timestamp"))
                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.timestamp);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomNewMsg message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomNewMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomNewMsg} message ChatRoomNewMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomNewMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomNewMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomNewMsg} ChatRoomNewMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomNewMsg.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomNewMsg();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.sender = $root.qihoo.protocol.chatroom.CRUser.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.msgtype = reader.int32();
                                break;
                            case 4:
                                message.msgcontent = reader.bytes();
                                break;
                            case 5:
                                message.regmemcount = reader.int32();
                                break;
                            case 6:
                                message.memcount = reader.int32();
                                break;
                            case 7:
                                message.msgid = reader.uint32();
                                break;
                            case 8:
                                message.maxid = reader.uint32();
                                break;
                            case 9:
                                message.timestamp = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomNewMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomNewMsg} ChatRoomNewMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomNewMsg.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomNewMsg message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomNewMsg.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.sender != null && message.hasOwnProperty("sender")) {
                        let error = $root.qihoo.protocol.chatroom.CRUser.verify(message.sender);
                        if(error)
                            return "sender." + error;
                    }
                    if(message.msgtype != null && message.hasOwnProperty("msgtype"))
                        if(!$util.isInteger(message.msgtype))
                            return "msgtype: integer expected";
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        if(!(message.msgcontent && typeof message.msgcontent.length === "number" || $util.isString(message.msgcontent)))
                            return "msgcontent: buffer expected";
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        if(!$util.isInteger(message.regmemcount))
                            return "regmemcount: integer expected";
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        if(!$util.isInteger(message.memcount))
                            return "memcount: integer expected";
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        if(!$util.isInteger(message.msgid))
                            return "msgid: integer expected";
                    if(message.maxid != null && message.hasOwnProperty("maxid"))
                        if(!$util.isInteger(message.maxid))
                            return "maxid: integer expected";
                    if(message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if(!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ChatRoomNewMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomNewMsg} ChatRoomNewMsg
                 */
                ChatRoomNewMsg.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomNewMsg)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomNewMsg();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.sender != null) {
                        if(typeof object.sender !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomNewMsg.sender: object expected");
                        message.sender = $root.qihoo.protocol.chatroom.CRUser.fromObject(object.sender);
                    }
                    if(object.msgtype != null)
                        message.msgtype = object.msgtype | 0;
                    if(object.msgcontent != null)
                        if(typeof object.msgcontent === "string")
                            $util.base64.decode(object.msgcontent, message.msgcontent = $util.newBuffer($util.base64.length(object.msgcontent)), 0);
                        else if(object.msgcontent.length)
                            message.msgcontent = object.msgcontent;
                    if(object.regmemcount != null)
                        message.regmemcount = object.regmemcount | 0;
                    if(object.memcount != null)
                        message.memcount = object.memcount | 0;
                    if(object.msgid != null)
                        message.msgid = object.msgid >>> 0;
                    if(object.maxid != null)
                        message.maxid = object.maxid >>> 0;
                    if(object.timestamp != null)
                        if($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                        else if(typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if(typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if(typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomNewMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomNewMsg} message ChatRoomNewMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomNewMsg.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.sender = null;
                        object.msgtype = 0;
                        if(options.bytes === String)
                            object.msgcontent = "";
                        else {
                            object.msgcontent = [];
                            if(options.bytes !== Array)
                                object.msgcontent = $util.newBuffer(object.msgcontent);
                        }
                        object.regmemcount = 0;
                        object.memcount = 0;
                        object.msgid = 0;
                        object.maxid = 0;
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = $root.qihoo.protocol.chatroom.CRUser.toObject(message.sender, options);
                    if(message.msgtype != null && message.hasOwnProperty("msgtype"))
                        object.msgtype = message.msgtype;
                    if(message.msgcontent != null && message.hasOwnProperty("msgcontent"))
                        object.msgcontent = options.bytes === String ? $util.base64.encode(message.msgcontent, 0, message.msgcontent.length) : options.bytes === Array ? Array.prototype.slice.call(message.msgcontent) : message.msgcontent;
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        object.regmemcount = message.regmemcount;
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        object.memcount = message.memcount;
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        object.msgid = message.msgid;
                    if(message.maxid != null && message.hasOwnProperty("maxid"))
                        object.maxid = message.maxid;
                    if(message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if(typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                    return object;
                };

                /**
                 * Converts this ChatRoomNewMsg to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomNewMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomNewMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomNewMsg;
            })();

            chatroom.ChatRoomErrorMsg = (function () {

                /**
                 * Properties of a ChatRoomErrorMsg.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomErrorMsg
                 * @property {Uint8Array} roomid ChatRoomErrorMsg roomid
                 * @property {number|Long} clientsn ChatRoomErrorMsg clientsn
                 * @property {number|null} [errorcode] ChatRoomErrorMsg errorcode
                 */

                /**
                 * Constructs a new ChatRoomErrorMsg.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomErrorMsg.
                 * @implements IChatRoomErrorMsg
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomErrorMsg=} [properties] Properties to set
                 */
                function ChatRoomErrorMsg(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomErrorMsg roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @instance
                 */
                ChatRoomErrorMsg.prototype.roomid = $util.newBuffer([]);

                /**
                 * ChatRoomErrorMsg clientsn.
                 * @member {number|Long} clientsn
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @instance
                 */
                ChatRoomErrorMsg.prototype.clientsn = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * ChatRoomErrorMsg errorcode.
                 * @member {number} errorcode
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @instance
                 */
                ChatRoomErrorMsg.prototype.errorcode = 0;

                /**
                 * Creates a new ChatRoomErrorMsg instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomErrorMsg=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomErrorMsg} ChatRoomErrorMsg instance
                 */
                ChatRoomErrorMsg.create = function create(properties) {
                    return new ChatRoomErrorMsg(properties);
                };

                /**
                 * Encodes the specified ChatRoomErrorMsg message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomErrorMsg.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomErrorMsg} message ChatRoomErrorMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomErrorMsg.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clientsn);
                    if(message.errorcode != null && message.hasOwnProperty("errorcode"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.errorcode);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomErrorMsg message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomErrorMsg.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomErrorMsg} message ChatRoomErrorMsg message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomErrorMsg.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomErrorMsg message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomErrorMsg} ChatRoomErrorMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomErrorMsg.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomErrorMsg();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.clientsn = reader.uint64();
                                break;
                            case 3:
                                message.errorcode = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    if(!message.hasOwnProperty("clientsn"))
                        throw $util.ProtocolError("missing required 'clientsn'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomErrorMsg message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomErrorMsg} ChatRoomErrorMsg
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomErrorMsg.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomErrorMsg message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomErrorMsg.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(!$util.isInteger(message.clientsn) && !(message.clientsn && $util.isInteger(message.clientsn.low) && $util.isInteger(message.clientsn.high)))
                        return "clientsn: integer|Long expected";
                    if(message.errorcode != null && message.hasOwnProperty("errorcode"))
                        if(!$util.isInteger(message.errorcode))
                            return "errorcode: integer expected";
                    return null;
                };

                /**
                 * Creates a ChatRoomErrorMsg message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomErrorMsg} ChatRoomErrorMsg
                 */
                ChatRoomErrorMsg.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomErrorMsg)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomErrorMsg();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.clientsn != null)
                        if($util.Long)
                            (message.clientsn = $util.Long.fromValue(object.clientsn)).unsigned = true;
                        else if(typeof object.clientsn === "string")
                            message.clientsn = parseInt(object.clientsn, 10);
                        else if(typeof object.clientsn === "number")
                            message.clientsn = object.clientsn;
                        else if(typeof object.clientsn === "object")
                            message.clientsn = new $util.LongBits(object.clientsn.low >>> 0, object.clientsn.high >>> 0).toNumber(true);
                    if(object.errorcode != null)
                        message.errorcode = object.errorcode | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomErrorMsg message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomErrorMsg} message ChatRoomErrorMsg
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomErrorMsg.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.clientsn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.clientsn = options.longs === String ? "0" : 0;
                        object.errorcode = 0;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.clientsn != null && message.hasOwnProperty("clientsn"))
                        if(typeof message.clientsn === "number")
                            object.clientsn = options.longs === String ? String(message.clientsn) : message.clientsn;
                        else
                            object.clientsn = options.longs === String ? $util.Long.prototype.toString.call(message.clientsn) : options.longs === Number ? new $util.LongBits(message.clientsn.low >>> 0, message.clientsn.high >>> 0).toNumber(true) : message.clientsn;
                    if(message.errorcode != null && message.hasOwnProperty("errorcode"))
                        object.errorcode = message.errorcode;
                    return object;
                };

                /**
                 * Converts this ChatRoomErrorMsg to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomErrorMsg
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomErrorMsg.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomErrorMsg;
            })();

            chatroom.ChatRoomMNotify = (function () {

                /**
                 * Properties of a ChatRoomMNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomMNotify
                 * @property {number} type ChatRoomMNotify type
                 * @property {Uint8Array} data ChatRoomMNotify data
                 * @property {number|null} [regmemcount] ChatRoomMNotify regmemcount
                 * @property {number|null} [memcount] ChatRoomMNotify memcount
                 */

                /**
                 * Constructs a new ChatRoomMNotify.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomMNotify.
                 * @implements IChatRoomMNotify
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomMNotify=} [properties] Properties to set
                 */
                function ChatRoomMNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomMNotify type.
                 * @member {number} type
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @instance
                 */
                ChatRoomMNotify.prototype.type = 0;

                /**
                 * ChatRoomMNotify data.
                 * @member {Uint8Array} data
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @instance
                 */
                ChatRoomMNotify.prototype.data = $util.newBuffer([]);

                /**
                 * ChatRoomMNotify regmemcount.
                 * @member {number} regmemcount
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @instance
                 */
                ChatRoomMNotify.prototype.regmemcount = 0;

                /**
                 * ChatRoomMNotify memcount.
                 * @member {number} memcount
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @instance
                 */
                ChatRoomMNotify.prototype.memcount = 0;

                /**
                 * Creates a new ChatRoomMNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomMNotify} ChatRoomMNotify instance
                 */
                ChatRoomMNotify.create = function create(properties) {
                    return new ChatRoomMNotify(properties);
                };

                /**
                 * Encodes the specified ChatRoomMNotify message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMNotify} message ChatRoomMNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.regmemcount);
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.memcount);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomMNotify message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomMNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomMNotify} message ChatRoomMNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomMNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomMNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomMNotify} ChatRoomMNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomMNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.type = reader.int32();
                                break;
                            case 2:
                                message.data = reader.bytes();
                                break;
                            case 3:
                                message.regmemcount = reader.int32();
                                break;
                            case 4:
                                message.memcount = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("type"))
                        throw $util.ProtocolError("missing required 'type'", { instance: message });
                    if(!message.hasOwnProperty("data"))
                        throw $util.ProtocolError("missing required 'data'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomMNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomMNotify} ChatRoomMNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomMNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomMNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomMNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.type))
                        return "type: integer expected";
                    if(!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        if(!$util.isInteger(message.regmemcount))
                            return "regmemcount: integer expected";
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        if(!$util.isInteger(message.memcount))
                            return "memcount: integer expected";
                    return null;
                };

                /**
                 * Creates a ChatRoomMNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomMNotify} ChatRoomMNotify
                 */
                ChatRoomMNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomMNotify)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomMNotify();
                    if(object.type != null)
                        message.type = object.type | 0;
                    if(object.data != null)
                        if(typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if(object.data.length)
                            message.data = object.data;
                    if(object.regmemcount != null)
                        message.regmemcount = object.regmemcount | 0;
                    if(object.memcount != null)
                        message.memcount = object.memcount | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomMNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomMNotify} message ChatRoomMNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomMNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.type = 0;
                        if(options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if(options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                        object.regmemcount = 0;
                        object.memcount = 0;
                    }
                    if(message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if(message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    if(message.regmemcount != null && message.hasOwnProperty("regmemcount"))
                        object.regmemcount = message.regmemcount;
                    if(message.memcount != null && message.hasOwnProperty("memcount"))
                        object.memcount = message.memcount;
                    return object;
                };

                /**
                 * Converts this ChatRoomMNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomMNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomMNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomMNotify;
            })();

            chatroom.SubscribeRequest = (function () {

                /**
                 * Properties of a SubscribeRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ISubscribeRequest
                 * @property {Uint8Array} roomid SubscribeRequest roomid
                 * @property {boolean|null} [sub] SubscribeRequest sub
                 */

                /**
                 * Constructs a new SubscribeRequest.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a SubscribeRequest.
                 * @implements ISubscribeRequest
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ISubscribeRequest=} [properties] Properties to set
                 */
                function SubscribeRequest(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SubscribeRequest roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @instance
                 */
                SubscribeRequest.prototype.roomid = $util.newBuffer([]);

                /**
                 * SubscribeRequest sub.
                 * @member {boolean} sub
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @instance
                 */
                SubscribeRequest.prototype.sub = false;

                /**
                 * Creates a new SubscribeRequest instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.SubscribeRequest} SubscribeRequest instance
                 */
                SubscribeRequest.create = function create(properties) {
                    return new SubscribeRequest(properties);
                };

                /**
                 * Encodes the specified SubscribeRequest message. Does not implicitly {@link qihoo.protocol.chatroom.SubscribeRequest.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeRequest} message SubscribeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeRequest.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.sub);
                    return writer;
                };

                /**
                 * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.SubscribeRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeRequest} message SubscribeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SubscribeRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.SubscribeRequest} SubscribeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeRequest.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.SubscribeRequest();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.sub = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.SubscribeRequest} SubscribeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeRequest.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SubscribeRequest message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SubscribeRequest.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        if(typeof message.sub !== "boolean")
                            return "sub: boolean expected";
                    return null;
                };

                /**
                 * Creates a SubscribeRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.SubscribeRequest} SubscribeRequest
                 */
                SubscribeRequest.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.SubscribeRequest)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.SubscribeRequest();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.sub != null)
                        message.sub = Boolean(object.sub);
                    return message;
                };

                /**
                 * Creates a plain object from a SubscribeRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @static
                 * @param {qihoo.protocol.chatroom.SubscribeRequest} message SubscribeRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SubscribeRequest.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.sub = false;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        object.sub = message.sub;
                    return object;
                };

                /**
                 * Converts this SubscribeRequest to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.SubscribeRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SubscribeRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SubscribeRequest;
            })();

            chatroom.SubscribeResponse = (function () {

                /**
                 * Properties of a SubscribeResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @interface ISubscribeResponse
                 * @property {Uint8Array} roomid SubscribeResponse roomid
                 * @property {boolean|null} [sub] SubscribeResponse sub
                 */

                /**
                 * Constructs a new SubscribeResponse.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a SubscribeResponse.
                 * @implements ISubscribeResponse
                 * @constructor
                 * @param {qihoo.protocol.chatroom.ISubscribeResponse=} [properties] Properties to set
                 */
                function SubscribeResponse(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SubscribeResponse roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @instance
                 */
                SubscribeResponse.prototype.roomid = $util.newBuffer([]);

                /**
                 * SubscribeResponse sub.
                 * @member {boolean} sub
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @instance
                 */
                SubscribeResponse.prototype.sub = false;

                /**
                 * Creates a new SubscribeResponse instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.SubscribeResponse} SubscribeResponse instance
                 */
                SubscribeResponse.create = function create(properties) {
                    return new SubscribeResponse(properties);
                };

                /**
                 * Encodes the specified SubscribeResponse message. Does not implicitly {@link qihoo.protocol.chatroom.SubscribeResponse.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeResponse} message SubscribeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeResponse.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.sub);
                    return writer;
                };

                /**
                 * Encodes the specified SubscribeResponse message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.SubscribeResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.ISubscribeResponse} message SubscribeResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SubscribeResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SubscribeResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.SubscribeResponse} SubscribeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeResponse.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.SubscribeResponse();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.sub = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SubscribeResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.SubscribeResponse} SubscribeResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SubscribeResponse.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SubscribeResponse message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SubscribeResponse.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        if(typeof message.sub !== "boolean")
                            return "sub: boolean expected";
                    return null;
                };

                /**
                 * Creates a SubscribeResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.SubscribeResponse} SubscribeResponse
                 */
                SubscribeResponse.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.SubscribeResponse)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.SubscribeResponse();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.sub != null)
                        message.sub = Boolean(object.sub);
                    return message;
                };

                /**
                 * Creates a plain object from a SubscribeResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @static
                 * @param {qihoo.protocol.chatroom.SubscribeResponse} message SubscribeResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SubscribeResponse.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.sub = false;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.sub != null && message.hasOwnProperty("sub"))
                        object.sub = message.sub;
                    return object;
                };

                /**
                 * Converts this SubscribeResponse to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.SubscribeResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SubscribeResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SubscribeResponse;
            })();

            chatroom.ChatRoomUpToServer = (function () {

                /**
                 * Properties of a ChatRoomUpToServer.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomUpToServer
                 * @property {number} payloadtype ChatRoomUpToServer payloadtype
                 * @property {qihoo.protocol.chatroom.ICreateChatRoomRequest|null} [createchatroomreq] ChatRoomUpToServer createchatroomreq
                 * @property {qihoo.protocol.chatroom.IGetChatRoomDetailRequest|null} [getchatroominforeq] ChatRoomUpToServer getchatroominforeq
                 * @property {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest|null} [applyjoinchatroomreq] ChatRoomUpToServer applyjoinchatroomreq
                 * @property {qihoo.protocol.chatroom.IQuitChatRoomRequest|null} [quitchatroomreq] ChatRoomUpToServer quitchatroomreq
                 * @property {qihoo.protocol.chatroom.IUpdateChatRoomRequest|null} [updatechatroomreq] ChatRoomUpToServer updatechatroomreq
                 * @property {qihoo.protocol.chatroom.IKickChatRoomMemberRequest|null} [kickmemberreq] ChatRoomUpToServer kickmemberreq
                 * @property {qihoo.protocol.chatroom.IQueryChatRoomIDRequest|null} [querychatroomidreq] ChatRoomUpToServer querychatroomidreq
                 * @property {qihoo.protocol.chatroom.IUpdateRoomIDRequest|null} [updategameidreq] ChatRoomUpToServer updategameidreq
                 * @property {qihoo.protocol.chatroom.IQueryAllGameRoomRequest|null} [queryallgameroomreq] ChatRoomUpToServer queryallgameroomreq
                 * @property {qihoo.protocol.chatroom.IChatRoomMessageRequest|null} [chatroommessagereq] ChatRoomUpToServer chatroommessagereq
                 * @property {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest|null} [createrooms] ChatRoomUpToServer createrooms
                 * @property {qihoo.protocol.chatroom.ISyncRoomToDBRequest|null} [syncroomtodba] ChatRoomUpToServer syncroomtodba
                 * @property {qihoo.protocol.chatroom.ISubscribeRequest|null} [subreq] ChatRoomUpToServer subreq
                 */

                /**
                 * Constructs a new ChatRoomUpToServer.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc payloadtype options:
                 * 100 -- createchatroomreq ;
                 * 101 -- getchatroominforeq ;
                 * 102 -- applyjoinchatroomreq;
                 * 103 -- quitchatroomreq;
                 * 104 -- updatechatroomreq;
                 * 105 -- kickmemberreq;
                 * 106 -- querychatroomidreq;
                 * 107 -- updategameidreq;
                 * 108 -- queryallgameroomreq;
                 * 109 -- subscribe chatroom message req;
                 * 200 -- syncroomtodba
                 * 300 -- chatroommessagereq;
                 * @implements IChatRoomUpToServer
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomUpToServer=} [properties] Properties to set
                 */
                function ChatRoomUpToServer(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomUpToServer payloadtype.
                 * @member {number} payloadtype
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.payloadtype = 0;

                /**
                 * ChatRoomUpToServer createchatroomreq.
                 * @member {qihoo.protocol.chatroom.ICreateChatRoomRequest|null|undefined} createchatroomreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.createchatroomreq = null;

                /**
                 * ChatRoomUpToServer getchatroominforeq.
                 * @member {qihoo.protocol.chatroom.IGetChatRoomDetailRequest|null|undefined} getchatroominforeq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.getchatroominforeq = null;

                /**
                 * ChatRoomUpToServer applyjoinchatroomreq.
                 * @member {qihoo.protocol.chatroom.IApplyJoinChatRoomRequest|null|undefined} applyjoinchatroomreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.applyjoinchatroomreq = null;

                /**
                 * ChatRoomUpToServer quitchatroomreq.
                 * @member {qihoo.protocol.chatroom.IQuitChatRoomRequest|null|undefined} quitchatroomreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.quitchatroomreq = null;

                /**
                 * ChatRoomUpToServer updatechatroomreq.
                 * @member {qihoo.protocol.chatroom.IUpdateChatRoomRequest|null|undefined} updatechatroomreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.updatechatroomreq = null;

                /**
                 * ChatRoomUpToServer kickmemberreq.
                 * @member {qihoo.protocol.chatroom.IKickChatRoomMemberRequest|null|undefined} kickmemberreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.kickmemberreq = null;

                /**
                 * ChatRoomUpToServer querychatroomidreq.
                 * @member {qihoo.protocol.chatroom.IQueryChatRoomIDRequest|null|undefined} querychatroomidreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.querychatroomidreq = null;

                /**
                 * ChatRoomUpToServer updategameidreq.
                 * @member {qihoo.protocol.chatroom.IUpdateRoomIDRequest|null|undefined} updategameidreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.updategameidreq = null;

                /**
                 * ChatRoomUpToServer queryallgameroomreq.
                 * @member {qihoo.protocol.chatroom.IQueryAllGameRoomRequest|null|undefined} queryallgameroomreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.queryallgameroomreq = null;

                /**
                 * ChatRoomUpToServer chatroommessagereq.
                 * @member {qihoo.protocol.chatroom.IChatRoomMessageRequest|null|undefined} chatroommessagereq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.chatroommessagereq = null;

                /**
                 * ChatRoomUpToServer createrooms.
                 * @member {qihoo.protocol.chatroom.ICreateMultiChatRoomRequest|null|undefined} createrooms
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.createrooms = null;

                /**
                 * ChatRoomUpToServer syncroomtodba.
                 * @member {qihoo.protocol.chatroom.ISyncRoomToDBRequest|null|undefined} syncroomtodba
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.syncroomtodba = null;

                /**
                 * ChatRoomUpToServer subreq.
                 * @member {qihoo.protocol.chatroom.ISubscribeRequest|null|undefined} subreq
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 */
                ChatRoomUpToServer.prototype.subreq = null;

                /**
                 * Creates a new ChatRoomUpToServer instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomUpToServer=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomUpToServer} ChatRoomUpToServer instance
                 */
                ChatRoomUpToServer.create = function create(properties) {
                    return new ChatRoomUpToServer(properties);
                };

                /**
                 * Encodes the specified ChatRoomUpToServer message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomUpToServer.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomUpToServer} message ChatRoomUpToServer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomUpToServer.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.payloadtype);
                    if(message.createchatroomreq != null && message.hasOwnProperty("createchatroomreq"))
                        $root.qihoo.protocol.chatroom.CreateChatRoomRequest.encode(message.createchatroomreq, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.getchatroominforeq != null && message.hasOwnProperty("getchatroominforeq"))
                        $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest.encode(message.getchatroominforeq, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.applyjoinchatroomreq != null && message.hasOwnProperty("applyjoinchatroomreq"))
                        $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.encode(message.applyjoinchatroomreq, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if(message.quitchatroomreq != null && message.hasOwnProperty("quitchatroomreq"))
                        $root.qihoo.protocol.chatroom.QuitChatRoomRequest.encode(message.quitchatroomreq, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if(message.updatechatroomreq != null && message.hasOwnProperty("updatechatroomreq"))
                        $root.qihoo.protocol.chatroom.UpdateChatRoomRequest.encode(message.updatechatroomreq, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.kickmemberreq != null && message.hasOwnProperty("kickmemberreq"))
                        $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest.encode(message.kickmemberreq, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if(message.querychatroomidreq != null && message.hasOwnProperty("querychatroomidreq"))
                        $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest.encode(message.querychatroomidreq, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if(message.updategameidreq != null && message.hasOwnProperty("updategameidreq"))
                        $root.qihoo.protocol.chatroom.UpdateRoomIDRequest.encode(message.updategameidreq, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.queryallgameroomreq != null && message.hasOwnProperty("queryallgameroomreq"))
                        $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest.encode(message.queryallgameroomreq, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if(message.chatroommessagereq != null && message.hasOwnProperty("chatroommessagereq"))
                        $root.qihoo.protocol.chatroom.ChatRoomMessageRequest.encode(message.chatroommessagereq, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if(message.createrooms != null && message.hasOwnProperty("createrooms"))
                        $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest.encode(message.createrooms, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if(message.syncroomtodba != null && message.hasOwnProperty("syncroomtodba"))
                        $root.qihoo.protocol.chatroom.SyncRoomToDBRequest.encode(message.syncroomtodba, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if(message.subreq != null && message.hasOwnProperty("subreq"))
                        $root.qihoo.protocol.chatroom.SubscribeRequest.encode(message.subreq, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomUpToServer message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomUpToServer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomUpToServer} message ChatRoomUpToServer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomUpToServer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomUpToServer message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomUpToServer} ChatRoomUpToServer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomUpToServer.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomUpToServer();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.payloadtype = reader.uint32();
                                break;
                            case 2:
                                message.createchatroomreq = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.getchatroominforeq = $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.applyjoinchatroomreq = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.quitchatroomreq = $root.qihoo.protocol.chatroom.QuitChatRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.updatechatroomreq = $root.qihoo.protocol.chatroom.UpdateChatRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.kickmemberreq = $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.querychatroomidreq = $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.updategameidreq = $root.qihoo.protocol.chatroom.UpdateRoomIDRequest.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.queryallgameroomreq = $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.chatroommessagereq = $root.qihoo.protocol.chatroom.ChatRoomMessageRequest.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.syncroomtodba = $root.qihoo.protocol.chatroom.SyncRoomToDBRequest.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.subreq = $root.qihoo.protocol.chatroom.SubscribeRequest.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("payloadtype"))
                        throw $util.ProtocolError("missing required 'payloadtype'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomUpToServer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomUpToServer} ChatRoomUpToServer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomUpToServer.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomUpToServer message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomUpToServer.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.payloadtype))
                        return "payloadtype: integer expected";
                    if(message.createchatroomreq != null && message.hasOwnProperty("createchatroomreq")) {
                        let error = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.verify(message.createchatroomreq);
                        if(error)
                            return "createchatroomreq." + error;
                    }
                    if(message.getchatroominforeq != null && message.hasOwnProperty("getchatroominforeq")) {
                        let error = $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest.verify(message.getchatroominforeq);
                        if(error)
                            return "getchatroominforeq." + error;
                    }
                    if(message.applyjoinchatroomreq != null && message.hasOwnProperty("applyjoinchatroomreq")) {
                        let error = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.verify(message.applyjoinchatroomreq);
                        if(error)
                            return "applyjoinchatroomreq." + error;
                    }
                    if(message.quitchatroomreq != null && message.hasOwnProperty("quitchatroomreq")) {
                        let error = $root.qihoo.protocol.chatroom.QuitChatRoomRequest.verify(message.quitchatroomreq);
                        if(error)
                            return "quitchatroomreq." + error;
                    }
                    if(message.updatechatroomreq != null && message.hasOwnProperty("updatechatroomreq")) {
                        let error = $root.qihoo.protocol.chatroom.UpdateChatRoomRequest.verify(message.updatechatroomreq);
                        if(error)
                            return "updatechatroomreq." + error;
                    }
                    if(message.kickmemberreq != null && message.hasOwnProperty("kickmemberreq")) {
                        let error = $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest.verify(message.kickmemberreq);
                        if(error)
                            return "kickmemberreq." + error;
                    }
                    if(message.querychatroomidreq != null && message.hasOwnProperty("querychatroomidreq")) {
                        let error = $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest.verify(message.querychatroomidreq);
                        if(error)
                            return "querychatroomidreq." + error;
                    }
                    if(message.updategameidreq != null && message.hasOwnProperty("updategameidreq")) {
                        let error = $root.qihoo.protocol.chatroom.UpdateRoomIDRequest.verify(message.updategameidreq);
                        if(error)
                            return "updategameidreq." + error;
                    }
                    if(message.queryallgameroomreq != null && message.hasOwnProperty("queryallgameroomreq")) {
                        let error = $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest.verify(message.queryallgameroomreq);
                        if(error)
                            return "queryallgameroomreq." + error;
                    }
                    if(message.chatroommessagereq != null && message.hasOwnProperty("chatroommessagereq")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomMessageRequest.verify(message.chatroommessagereq);
                        if(error)
                            return "chatroommessagereq." + error;
                    }
                    if(message.createrooms != null && message.hasOwnProperty("createrooms")) {
                        let error = $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest.verify(message.createrooms);
                        if(error)
                            return "createrooms." + error;
                    }
                    if(message.syncroomtodba != null && message.hasOwnProperty("syncroomtodba")) {
                        let error = $root.qihoo.protocol.chatroom.SyncRoomToDBRequest.verify(message.syncroomtodba);
                        if(error)
                            return "syncroomtodba." + error;
                    }
                    if(message.subreq != null && message.hasOwnProperty("subreq")) {
                        let error = $root.qihoo.protocol.chatroom.SubscribeRequest.verify(message.subreq);
                        if(error)
                            return "subreq." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ChatRoomUpToServer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomUpToServer} ChatRoomUpToServer
                 */
                ChatRoomUpToServer.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomUpToServer)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomUpToServer();
                    if(object.payloadtype != null)
                        message.payloadtype = object.payloadtype >>> 0;
                    if(object.createchatroomreq != null) {
                        if(typeof object.createchatroomreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.createchatroomreq: object expected");
                        message.createchatroomreq = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.fromObject(object.createchatroomreq);
                    }
                    if(object.getchatroominforeq != null) {
                        if(typeof object.getchatroominforeq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.getchatroominforeq: object expected");
                        message.getchatroominforeq = $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest.fromObject(object.getchatroominforeq);
                    }
                    if(object.applyjoinchatroomreq != null) {
                        if(typeof object.applyjoinchatroomreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.applyjoinchatroomreq: object expected");
                        message.applyjoinchatroomreq = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.fromObject(object.applyjoinchatroomreq);
                    }
                    if(object.quitchatroomreq != null) {
                        if(typeof object.quitchatroomreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.quitchatroomreq: object expected");
                        message.quitchatroomreq = $root.qihoo.protocol.chatroom.QuitChatRoomRequest.fromObject(object.quitchatroomreq);
                    }
                    if(object.updatechatroomreq != null) {
                        if(typeof object.updatechatroomreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.updatechatroomreq: object expected");
                        message.updatechatroomreq = $root.qihoo.protocol.chatroom.UpdateChatRoomRequest.fromObject(object.updatechatroomreq);
                    }
                    if(object.kickmemberreq != null) {
                        if(typeof object.kickmemberreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.kickmemberreq: object expected");
                        message.kickmemberreq = $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest.fromObject(object.kickmemberreq);
                    }
                    if(object.querychatroomidreq != null) {
                        if(typeof object.querychatroomidreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.querychatroomidreq: object expected");
                        message.querychatroomidreq = $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest.fromObject(object.querychatroomidreq);
                    }
                    if(object.updategameidreq != null) {
                        if(typeof object.updategameidreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.updategameidreq: object expected");
                        message.updategameidreq = $root.qihoo.protocol.chatroom.UpdateRoomIDRequest.fromObject(object.updategameidreq);
                    }
                    if(object.queryallgameroomreq != null) {
                        if(typeof object.queryallgameroomreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.queryallgameroomreq: object expected");
                        message.queryallgameroomreq = $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest.fromObject(object.queryallgameroomreq);
                    }
                    if(object.chatroommessagereq != null) {
                        if(typeof object.chatroommessagereq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.chatroommessagereq: object expected");
                        message.chatroommessagereq = $root.qihoo.protocol.chatroom.ChatRoomMessageRequest.fromObject(object.chatroommessagereq);
                    }
                    if(object.createrooms != null) {
                        if(typeof object.createrooms !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.createrooms: object expected");
                        message.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest.fromObject(object.createrooms);
                    }
                    if(object.syncroomtodba != null) {
                        if(typeof object.syncroomtodba !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.syncroomtodba: object expected");
                        message.syncroomtodba = $root.qihoo.protocol.chatroom.SyncRoomToDBRequest.fromObject(object.syncroomtodba);
                    }
                    if(object.subreq != null) {
                        if(typeof object.subreq !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomUpToServer.subreq: object expected");
                        message.subreq = $root.qihoo.protocol.chatroom.SubscribeRequest.fromObject(object.subreq);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomUpToServer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomUpToServer} message ChatRoomUpToServer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomUpToServer.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.payloadtype = 0;
                        object.createchatroomreq = null;
                        object.getchatroominforeq = null;
                        object.applyjoinchatroomreq = null;
                        object.quitchatroomreq = null;
                        object.updatechatroomreq = null;
                        object.kickmemberreq = null;
                        object.querychatroomidreq = null;
                        object.updategameidreq = null;
                        object.queryallgameroomreq = null;
                        object.chatroommessagereq = null;
                        object.createrooms = null;
                        object.syncroomtodba = null;
                        object.subreq = null;
                    }
                    if(message.payloadtype != null && message.hasOwnProperty("payloadtype"))
                        object.payloadtype = message.payloadtype;
                    if(message.createchatroomreq != null && message.hasOwnProperty("createchatroomreq"))
                        object.createchatroomreq = $root.qihoo.protocol.chatroom.CreateChatRoomRequest.toObject(message.createchatroomreq, options);
                    if(message.getchatroominforeq != null && message.hasOwnProperty("getchatroominforeq"))
                        object.getchatroominforeq = $root.qihoo.protocol.chatroom.GetChatRoomDetailRequest.toObject(message.getchatroominforeq, options);
                    if(message.applyjoinchatroomreq != null && message.hasOwnProperty("applyjoinchatroomreq"))
                        object.applyjoinchatroomreq = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomRequest.toObject(message.applyjoinchatroomreq, options);
                    if(message.quitchatroomreq != null && message.hasOwnProperty("quitchatroomreq"))
                        object.quitchatroomreq = $root.qihoo.protocol.chatroom.QuitChatRoomRequest.toObject(message.quitchatroomreq, options);
                    if(message.updatechatroomreq != null && message.hasOwnProperty("updatechatroomreq"))
                        object.updatechatroomreq = $root.qihoo.protocol.chatroom.UpdateChatRoomRequest.toObject(message.updatechatroomreq, options);
                    if(message.kickmemberreq != null && message.hasOwnProperty("kickmemberreq"))
                        object.kickmemberreq = $root.qihoo.protocol.chatroom.KickChatRoomMemberRequest.toObject(message.kickmemberreq, options);
                    if(message.querychatroomidreq != null && message.hasOwnProperty("querychatroomidreq"))
                        object.querychatroomidreq = $root.qihoo.protocol.chatroom.QueryChatRoomIDRequest.toObject(message.querychatroomidreq, options);
                    if(message.updategameidreq != null && message.hasOwnProperty("updategameidreq"))
                        object.updategameidreq = $root.qihoo.protocol.chatroom.UpdateRoomIDRequest.toObject(message.updategameidreq, options);
                    if(message.queryallgameroomreq != null && message.hasOwnProperty("queryallgameroomreq"))
                        object.queryallgameroomreq = $root.qihoo.protocol.chatroom.QueryAllGameRoomRequest.toObject(message.queryallgameroomreq, options);
                    if(message.chatroommessagereq != null && message.hasOwnProperty("chatroommessagereq"))
                        object.chatroommessagereq = $root.qihoo.protocol.chatroom.ChatRoomMessageRequest.toObject(message.chatroommessagereq, options);
                    if(message.createrooms != null && message.hasOwnProperty("createrooms"))
                        object.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomRequest.toObject(message.createrooms, options);
                    if(message.syncroomtodba != null && message.hasOwnProperty("syncroomtodba"))
                        object.syncroomtodba = $root.qihoo.protocol.chatroom.SyncRoomToDBRequest.toObject(message.syncroomtodba, options);
                    if(message.subreq != null && message.hasOwnProperty("subreq"))
                        object.subreq = $root.qihoo.protocol.chatroom.SubscribeRequest.toObject(message.subreq, options);
                    return object;
                };

                /**
                 * Converts this ChatRoomUpToServer to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomUpToServer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomUpToServer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomUpToServer;
            })();

            chatroom.ChatRoomDownToUser = (function () {

                /**
                 * Properties of a ChatRoomDownToUser.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomDownToUser
                 * @property {number} result ChatRoomDownToUser result
                 * @property {number} payloadtype ChatRoomDownToUser payloadtype
                 * @property {qihoo.protocol.chatroom.ICreateChatRoomResponse|null} [createchatroomresp] ChatRoomDownToUser createchatroomresp
                 * @property {qihoo.protocol.chatroom.IGetChatRoomDetailResponse|null} [getchatroominforesp] ChatRoomDownToUser getchatroominforesp
                 * @property {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse|null} [applyjoinchatroomresp] ChatRoomDownToUser applyjoinchatroomresp
                 * @property {qihoo.protocol.chatroom.IQuitChatRoomResponse|null} [quitchatroomresp] ChatRoomDownToUser quitchatroomresp
                 * @property {qihoo.protocol.chatroom.IUpdateChatRoomResponse|null} [updatechatroomresp] ChatRoomDownToUser updatechatroomresp
                 * @property {qihoo.protocol.chatroom.IKickChatRoomMemberResponse|null} [kickmemberresp] ChatRoomDownToUser kickmemberresp
                 * @property {qihoo.protocol.chatroom.IQueryChatRoomIDResponse|null} [querychatroomidresp] ChatRoomDownToUser querychatroomidresp
                 * @property {qihoo.protocol.chatroom.IUpdateRoomIDResponse|null} [updategameidresp] ChatRoomDownToUser updategameidresp
                 * @property {qihoo.protocol.chatroom.IQueryAllGameRoomResponse|null} [queryallgameroomresp] ChatRoomDownToUser queryallgameroomresp
                 * @property {qihoo.protocol.chatroom.IChatRoomMessageResponse|null} [chatroommessageresp] ChatRoomDownToUser chatroommessageresp
                 * @property {qihoo.protocol.chatroom.IChatRoomNewMsg|null} [newmsgnotify] ChatRoomDownToUser newmsgnotify
                 * @property {qihoo.protocol.chatroom.IChatRoomErrorMsg|null} [errormsgnotify] ChatRoomDownToUser errormsgnotify
                 * @property {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse|null} [createrooms] ChatRoomDownToUser createrooms
                 * @property {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify|null} [memberjoinnotify] ChatRoomDownToUser memberjoinnotify
                 * @property {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify|null} [memberquitnotify] ChatRoomDownToUser memberquitnotify
                 * @property {qihoo.protocol.chatroom.ISubscribeResponse|null} [subresp] ChatRoomDownToUser subresp
                 * @property {Uint8Array|null} [reason] ChatRoomDownToUser reason
                 * @property {Array.<qihoo.protocol.chatroom.IChatRoomMNotify>|null} [multinotify] ChatRoomDownToUser multinotify
                 */

                /**
                 * Constructs a new ChatRoomDownToUser.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc payloadtype options:
                 * 100 -- createchatroomresp ;
                 * 101 -- getchatroominforesp ;
                 * 102 -- applyjoinchatroomresp;
                 * 103 -- quitchatroomresp;
                 * 104 -- updatechatroomresp;
                 * 105 -- kickmemberresp;
                 * 106 -- querychatroomidresp;
                 * 107 -- updategameidresp;
                 * 108 -- queryallgameroomresp;
                 * 300 -- chatroommessageresp;
                 * 1000 -- newmsgnotify
                 * 1001 -- memberjoinnotify
                 * 1002 -- memberquitnotify
                 * 1003 -- multinotify
                 * 1100 -- errormsgnotify
                 * [result]
                 * 0   -- successful
                 *
                 * 5000 exist in [GetChatRoomDetailRequest,ApplyJoinChatRoomRequest,QuitChatRoomRequest,UpdateChatRoomRequest,KickChatRoomMemberRequest,ChatRoomMessageRequest]
                 * 50000 -- peration failed, chat room server error.
                 * 5001 exist in [All Request]
                 * 50001 -- protocol error, not support payload type.
                 * 5002 exist in [GetChatRoomDetailRequest,ApplyJoinChatRoomRequest,QuitChatRoomRequest,UpdateChatRoomRequest,KickChatRoomMemberRequest,ChatRoomMessageRequest]
                 * 50002 -- operation failed, because room id does not exist
                 * 5003 exist in [GetChatRoomDetailRequest,ApplyJoinChatRoomRequest,QuitChatRoomRequest,UpdateChatRoomRequest,KickChatRoomMemberRequest,ChatRoomMessageRequest]
                 * 50003 -- operation failed, bcause room id is not same between inner and outer.
                 *
                 * 10001 -- create chat room failed, because dba return error
                 * 10002 -- create chat room failed, because has no authority
                 * 10003 -- create chat room failed, because no game id
                 * 10004 -- create chat room failed, because member count is over upper limit
                 *
                 * 10101 -- get chat room info failed, because user does not join this chat room
                 *
                 *
                 * 10201 -- join chat room failed, because room id does not exist
                 * 10202 -- join chat room failed, because member count reach upper limit
                 * 10203 -- join chat room failed, because dba return error
                 * 10204 -- join chat room failed, because user is in blacklist
                 *
                 * 10301 -- quit chat room failed, because user is not chat room member
                 * 10302 -- quit chat room failed, because dba return error
                 *
                 * 10401 -- update chat room failed, because user has no authority
                 * 10402 -- update chat room failed, because dba return error
                 *
                 * 10501 -- kick member failed, because user has no authority
                 * 10502 -- kick member failed, because user is not in chatroom
                 * 10503 -- kick member failed, because dba return error
                 *
                 * 10601 -- query room id failed, because dba return error
                 *
                 * 10701 -- update game and room relationship failed, because user has no authority
                 * 10702 -- update game and room relationship failed, because not set game id
                 * 10703 -- update game and room relationship failed, because dba return error
                 *
                 * 10801 -- query all game room mapping failed, because user has no authority
                 * 10802 -- query all game room mapping failed, because dba return error
                 *
                 * 30001 -- send message failed, because user is not chat room member
                 * 30002 -- send message failed, because dba return error
                 * @implements IChatRoomDownToUser
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomDownToUser=} [properties] Properties to set
                 */
                function ChatRoomDownToUser(properties) {
                    this.multinotify = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomDownToUser result.
                 * @member {number} result
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.result = 0;

                /**
                 * ChatRoomDownToUser payloadtype.
                 * @member {number} payloadtype
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.payloadtype = 0;

                /**
                 * ChatRoomDownToUser createchatroomresp.
                 * @member {qihoo.protocol.chatroom.ICreateChatRoomResponse|null|undefined} createchatroomresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.createchatroomresp = null;

                /**
                 * ChatRoomDownToUser getchatroominforesp.
                 * @member {qihoo.protocol.chatroom.IGetChatRoomDetailResponse|null|undefined} getchatroominforesp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.getchatroominforesp = null;

                /**
                 * ChatRoomDownToUser applyjoinchatroomresp.
                 * @member {qihoo.protocol.chatroom.IApplyJoinChatRoomResponse|null|undefined} applyjoinchatroomresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.applyjoinchatroomresp = null;

                /**
                 * ChatRoomDownToUser quitchatroomresp.
                 * @member {qihoo.protocol.chatroom.IQuitChatRoomResponse|null|undefined} quitchatroomresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.quitchatroomresp = null;

                /**
                 * ChatRoomDownToUser updatechatroomresp.
                 * @member {qihoo.protocol.chatroom.IUpdateChatRoomResponse|null|undefined} updatechatroomresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.updatechatroomresp = null;

                /**
                 * ChatRoomDownToUser kickmemberresp.
                 * @member {qihoo.protocol.chatroom.IKickChatRoomMemberResponse|null|undefined} kickmemberresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.kickmemberresp = null;

                /**
                 * ChatRoomDownToUser querychatroomidresp.
                 * @member {qihoo.protocol.chatroom.IQueryChatRoomIDResponse|null|undefined} querychatroomidresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.querychatroomidresp = null;

                /**
                 * ChatRoomDownToUser updategameidresp.
                 * @member {qihoo.protocol.chatroom.IUpdateRoomIDResponse|null|undefined} updategameidresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.updategameidresp = null;

                /**
                 * ChatRoomDownToUser queryallgameroomresp.
                 * @member {qihoo.protocol.chatroom.IQueryAllGameRoomResponse|null|undefined} queryallgameroomresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.queryallgameroomresp = null;

                /**
                 * ChatRoomDownToUser chatroommessageresp.
                 * @member {qihoo.protocol.chatroom.IChatRoomMessageResponse|null|undefined} chatroommessageresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.chatroommessageresp = null;

                /**
                 * ChatRoomDownToUser newmsgnotify.
                 * @member {qihoo.protocol.chatroom.IChatRoomNewMsg|null|undefined} newmsgnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.newmsgnotify = null;

                /**
                 * ChatRoomDownToUser errormsgnotify.
                 * @member {qihoo.protocol.chatroom.IChatRoomErrorMsg|null|undefined} errormsgnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.errormsgnotify = null;

                /**
                 * ChatRoomDownToUser createrooms.
                 * @member {qihoo.protocol.chatroom.ICreateMultiChatRoomResponse|null|undefined} createrooms
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.createrooms = null;

                /**
                 * ChatRoomDownToUser memberjoinnotify.
                 * @member {qihoo.protocol.chatroom.IMemberJoinChatRoomNotify|null|undefined} memberjoinnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.memberjoinnotify = null;

                /**
                 * ChatRoomDownToUser memberquitnotify.
                 * @member {qihoo.protocol.chatroom.IMemberQuitChatRoomNotify|null|undefined} memberquitnotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.memberquitnotify = null;

                /**
                 * ChatRoomDownToUser subresp.
                 * @member {qihoo.protocol.chatroom.ISubscribeResponse|null|undefined} subresp
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.subresp = null;

                /**
                 * ChatRoomDownToUser reason.
                 * @member {Uint8Array} reason
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.reason = $util.newBuffer([]);

                /**
                 * ChatRoomDownToUser multinotify.
                 * @member {Array.<qihoo.protocol.chatroom.IChatRoomMNotify>} multinotify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 */
                ChatRoomDownToUser.prototype.multinotify = $util.emptyArray;

                /**
                 * Creates a new ChatRoomDownToUser instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomDownToUser=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomDownToUser} ChatRoomDownToUser instance
                 */
                ChatRoomDownToUser.create = function create(properties) {
                    return new ChatRoomDownToUser(properties);
                };

                /**
                 * Encodes the specified ChatRoomDownToUser message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomDownToUser.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomDownToUser} message ChatRoomDownToUser message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomDownToUser.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.payloadtype);
                    if(message.createchatroomresp != null && message.hasOwnProperty("createchatroomresp"))
                        $root.qihoo.protocol.chatroom.CreateChatRoomResponse.encode(message.createchatroomresp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.getchatroominforesp != null && message.hasOwnProperty("getchatroominforesp"))
                        $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse.encode(message.getchatroominforesp, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if(message.applyjoinchatroomresp != null && message.hasOwnProperty("applyjoinchatroomresp"))
                        $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.encode(message.applyjoinchatroomresp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if(message.quitchatroomresp != null && message.hasOwnProperty("quitchatroomresp"))
                        $root.qihoo.protocol.chatroom.QuitChatRoomResponse.encode(message.quitchatroomresp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.updatechatroomresp != null && message.hasOwnProperty("updatechatroomresp"))
                        $root.qihoo.protocol.chatroom.UpdateChatRoomResponse.encode(message.updatechatroomresp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if(message.kickmemberresp != null && message.hasOwnProperty("kickmemberresp"))
                        $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse.encode(message.kickmemberresp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if(message.querychatroomidresp != null && message.hasOwnProperty("querychatroomidresp"))
                        $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse.encode(message.querychatroomidresp, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.updategameidresp != null && message.hasOwnProperty("updategameidresp"))
                        $root.qihoo.protocol.chatroom.UpdateRoomIDResponse.encode(message.updategameidresp, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if(message.queryallgameroomresp != null && message.hasOwnProperty("queryallgameroomresp"))
                        $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse.encode(message.queryallgameroomresp, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if(message.chatroommessageresp != null && message.hasOwnProperty("chatroommessageresp"))
                        $root.qihoo.protocol.chatroom.ChatRoomMessageResponse.encode(message.chatroommessageresp, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if(message.newmsgnotify != null && message.hasOwnProperty("newmsgnotify"))
                        $root.qihoo.protocol.chatroom.ChatRoomNewMsg.encode(message.newmsgnotify, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if(message.errormsgnotify != null && message.hasOwnProperty("errormsgnotify"))
                        $root.qihoo.protocol.chatroom.ChatRoomErrorMsg.encode(message.errormsgnotify, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if(message.createrooms != null && message.hasOwnProperty("createrooms"))
                        $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse.encode(message.createrooms, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if(message.memberjoinnotify != null && message.hasOwnProperty("memberjoinnotify"))
                        $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.encode(message.memberjoinnotify, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if(message.memberquitnotify != null && message.hasOwnProperty("memberquitnotify"))
                        $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.encode(message.memberquitnotify, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if(message.subresp != null && message.hasOwnProperty("subresp"))
                        $root.qihoo.protocol.chatroom.SubscribeResponse.encode(message.subresp, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 100, wireType 2 =*/802).bytes(message.reason);
                    if(message.multinotify != null && message.multinotify.length)
                        for(let i = 0; i < message.multinotify.length; ++i)
                            $root.qihoo.protocol.chatroom.ChatRoomMNotify.encode(message.multinotify[i], writer.uint32(/* id 200, wireType 2 =*/1602).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomDownToUser message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomDownToUser.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomDownToUser} message ChatRoomDownToUser message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomDownToUser.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomDownToUser message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomDownToUser} ChatRoomDownToUser
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomDownToUser.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomDownToUser();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.result = reader.int32();
                                break;
                            case 2:
                                message.payloadtype = reader.uint32();
                                break;
                            case 3:
                                message.createchatroomresp = $root.qihoo.protocol.chatroom.CreateChatRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.getchatroominforesp = $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.applyjoinchatroomresp = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.quitchatroomresp = $root.qihoo.protocol.chatroom.QuitChatRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.updatechatroomresp = $root.qihoo.protocol.chatroom.UpdateChatRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.kickmemberresp = $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.querychatroomidresp = $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.updategameidresp = $root.qihoo.protocol.chatroom.UpdateRoomIDResponse.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.queryallgameroomresp = $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.chatroommessageresp = $root.qihoo.protocol.chatroom.ChatRoomMessageResponse.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.newmsgnotify = $root.qihoo.protocol.chatroom.ChatRoomNewMsg.decode(reader, reader.uint32());
                                break;
                            case 14:
                                message.errormsgnotify = $root.qihoo.protocol.chatroom.ChatRoomErrorMsg.decode(reader, reader.uint32());
                                break;
                            case 15:
                                message.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse.decode(reader, reader.uint32());
                                break;
                            case 16:
                                message.memberjoinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 17:
                                message.memberquitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.decode(reader, reader.uint32());
                                break;
                            case 18:
                                message.subresp = $root.qihoo.protocol.chatroom.SubscribeResponse.decode(reader, reader.uint32());
                                break;
                            case 100:
                                message.reason = reader.bytes();
                                break;
                            case 200:
                                if(!(message.multinotify && message.multinotify.length))
                                    message.multinotify = [];
                                message.multinotify.push($root.qihoo.protocol.chatroom.ChatRoomMNotify.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("result"))
                        throw $util.ProtocolError("missing required 'result'", { instance: message });
                    if(!message.hasOwnProperty("payloadtype"))
                        throw $util.ProtocolError("missing required 'payloadtype'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomDownToUser message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomDownToUser} ChatRoomDownToUser
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomDownToUser.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomDownToUser message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomDownToUser.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.result))
                        return "result: integer expected";
                    if(!$util.isInteger(message.payloadtype))
                        return "payloadtype: integer expected";
                    if(message.createchatroomresp != null && message.hasOwnProperty("createchatroomresp")) {
                        let error = $root.qihoo.protocol.chatroom.CreateChatRoomResponse.verify(message.createchatroomresp);
                        if(error)
                            return "createchatroomresp." + error;
                    }
                    if(message.getchatroominforesp != null && message.hasOwnProperty("getchatroominforesp")) {
                        let error = $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse.verify(message.getchatroominforesp);
                        if(error)
                            return "getchatroominforesp." + error;
                    }
                    if(message.applyjoinchatroomresp != null && message.hasOwnProperty("applyjoinchatroomresp")) {
                        let error = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.verify(message.applyjoinchatroomresp);
                        if(error)
                            return "applyjoinchatroomresp." + error;
                    }
                    if(message.quitchatroomresp != null && message.hasOwnProperty("quitchatroomresp")) {
                        let error = $root.qihoo.protocol.chatroom.QuitChatRoomResponse.verify(message.quitchatroomresp);
                        if(error)
                            return "quitchatroomresp." + error;
                    }
                    if(message.updatechatroomresp != null && message.hasOwnProperty("updatechatroomresp")) {
                        let error = $root.qihoo.protocol.chatroom.UpdateChatRoomResponse.verify(message.updatechatroomresp);
                        if(error)
                            return "updatechatroomresp." + error;
                    }
                    if(message.kickmemberresp != null && message.hasOwnProperty("kickmemberresp")) {
                        let error = $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse.verify(message.kickmemberresp);
                        if(error)
                            return "kickmemberresp." + error;
                    }
                    if(message.querychatroomidresp != null && message.hasOwnProperty("querychatroomidresp")) {
                        let error = $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse.verify(message.querychatroomidresp);
                        if(error)
                            return "querychatroomidresp." + error;
                    }
                    if(message.updategameidresp != null && message.hasOwnProperty("updategameidresp")) {
                        let error = $root.qihoo.protocol.chatroom.UpdateRoomIDResponse.verify(message.updategameidresp);
                        if(error)
                            return "updategameidresp." + error;
                    }
                    if(message.queryallgameroomresp != null && message.hasOwnProperty("queryallgameroomresp")) {
                        let error = $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse.verify(message.queryallgameroomresp);
                        if(error)
                            return "queryallgameroomresp." + error;
                    }
                    if(message.chatroommessageresp != null && message.hasOwnProperty("chatroommessageresp")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomMessageResponse.verify(message.chatroommessageresp);
                        if(error)
                            return "chatroommessageresp." + error;
                    }
                    if(message.newmsgnotify != null && message.hasOwnProperty("newmsgnotify")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomNewMsg.verify(message.newmsgnotify);
                        if(error)
                            return "newmsgnotify." + error;
                    }
                    if(message.errormsgnotify != null && message.hasOwnProperty("errormsgnotify")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomErrorMsg.verify(message.errormsgnotify);
                        if(error)
                            return "errormsgnotify." + error;
                    }
                    if(message.createrooms != null && message.hasOwnProperty("createrooms")) {
                        let error = $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse.verify(message.createrooms);
                        if(error)
                            return "createrooms." + error;
                    }
                    if(message.memberjoinnotify != null && message.hasOwnProperty("memberjoinnotify")) {
                        let error = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.verify(message.memberjoinnotify);
                        if(error)
                            return "memberjoinnotify." + error;
                    }
                    if(message.memberquitnotify != null && message.hasOwnProperty("memberquitnotify")) {
                        let error = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.verify(message.memberquitnotify);
                        if(error)
                            return "memberquitnotify." + error;
                    }
                    if(message.subresp != null && message.hasOwnProperty("subresp")) {
                        let error = $root.qihoo.protocol.chatroom.SubscribeResponse.verify(message.subresp);
                        if(error)
                            return "subresp." + error;
                    }
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        if(!(message.reason && typeof message.reason.length === "number" || $util.isString(message.reason)))
                            return "reason: buffer expected";
                    if(message.multinotify != null && message.hasOwnProperty("multinotify")) {
                        if(!Array.isArray(message.multinotify))
                            return "multinotify: array expected";
                        for(let i = 0; i < message.multinotify.length; ++i) {
                            let error = $root.qihoo.protocol.chatroom.ChatRoomMNotify.verify(message.multinotify[i]);
                            if(error)
                                return "multinotify." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ChatRoomDownToUser message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomDownToUser} ChatRoomDownToUser
                 */
                ChatRoomDownToUser.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomDownToUser)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomDownToUser();
                    if(object.result != null)
                        message.result = object.result | 0;
                    if(object.payloadtype != null)
                        message.payloadtype = object.payloadtype >>> 0;
                    if(object.createchatroomresp != null) {
                        if(typeof object.createchatroomresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.createchatroomresp: object expected");
                        message.createchatroomresp = $root.qihoo.protocol.chatroom.CreateChatRoomResponse.fromObject(object.createchatroomresp);
                    }
                    if(object.getchatroominforesp != null) {
                        if(typeof object.getchatroominforesp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.getchatroominforesp: object expected");
                        message.getchatroominforesp = $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse.fromObject(object.getchatroominforesp);
                    }
                    if(object.applyjoinchatroomresp != null) {
                        if(typeof object.applyjoinchatroomresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.applyjoinchatroomresp: object expected");
                        message.applyjoinchatroomresp = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.fromObject(object.applyjoinchatroomresp);
                    }
                    if(object.quitchatroomresp != null) {
                        if(typeof object.quitchatroomresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.quitchatroomresp: object expected");
                        message.quitchatroomresp = $root.qihoo.protocol.chatroom.QuitChatRoomResponse.fromObject(object.quitchatroomresp);
                    }
                    if(object.updatechatroomresp != null) {
                        if(typeof object.updatechatroomresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.updatechatroomresp: object expected");
                        message.updatechatroomresp = $root.qihoo.protocol.chatroom.UpdateChatRoomResponse.fromObject(object.updatechatroomresp);
                    }
                    if(object.kickmemberresp != null) {
                        if(typeof object.kickmemberresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.kickmemberresp: object expected");
                        message.kickmemberresp = $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse.fromObject(object.kickmemberresp);
                    }
                    if(object.querychatroomidresp != null) {
                        if(typeof object.querychatroomidresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.querychatroomidresp: object expected");
                        message.querychatroomidresp = $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse.fromObject(object.querychatroomidresp);
                    }
                    if(object.updategameidresp != null) {
                        if(typeof object.updategameidresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.updategameidresp: object expected");
                        message.updategameidresp = $root.qihoo.protocol.chatroom.UpdateRoomIDResponse.fromObject(object.updategameidresp);
                    }
                    if(object.queryallgameroomresp != null) {
                        if(typeof object.queryallgameroomresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.queryallgameroomresp: object expected");
                        message.queryallgameroomresp = $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse.fromObject(object.queryallgameroomresp);
                    }
                    if(object.chatroommessageresp != null) {
                        if(typeof object.chatroommessageresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.chatroommessageresp: object expected");
                        message.chatroommessageresp = $root.qihoo.protocol.chatroom.ChatRoomMessageResponse.fromObject(object.chatroommessageresp);
                    }
                    if(object.newmsgnotify != null) {
                        if(typeof object.newmsgnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.newmsgnotify: object expected");
                        message.newmsgnotify = $root.qihoo.protocol.chatroom.ChatRoomNewMsg.fromObject(object.newmsgnotify);
                    }
                    if(object.errormsgnotify != null) {
                        if(typeof object.errormsgnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.errormsgnotify: object expected");
                        message.errormsgnotify = $root.qihoo.protocol.chatroom.ChatRoomErrorMsg.fromObject(object.errormsgnotify);
                    }
                    if(object.createrooms != null) {
                        if(typeof object.createrooms !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.createrooms: object expected");
                        message.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse.fromObject(object.createrooms);
                    }
                    if(object.memberjoinnotify != null) {
                        if(typeof object.memberjoinnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.memberjoinnotify: object expected");
                        message.memberjoinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.fromObject(object.memberjoinnotify);
                    }
                    if(object.memberquitnotify != null) {
                        if(typeof object.memberquitnotify !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.memberquitnotify: object expected");
                        message.memberquitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.fromObject(object.memberquitnotify);
                    }
                    if(object.subresp != null) {
                        if(typeof object.subresp !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.subresp: object expected");
                        message.subresp = $root.qihoo.protocol.chatroom.SubscribeResponse.fromObject(object.subresp);
                    }
                    if(object.reason != null)
                        if(typeof object.reason === "string")
                            $util.base64.decode(object.reason, message.reason = $util.newBuffer($util.base64.length(object.reason)), 0);
                        else if(object.reason.length)
                            message.reason = object.reason;
                    if(object.multinotify) {
                        if(!Array.isArray(object.multinotify))
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.multinotify: array expected");
                        message.multinotify = [];
                        for(let i = 0; i < object.multinotify.length; ++i) {
                            if(typeof object.multinotify[i] !== "object")
                                throw TypeError(".qihoo.protocol.chatroom.ChatRoomDownToUser.multinotify: object expected");
                            message.multinotify[i] = $root.qihoo.protocol.chatroom.ChatRoomMNotify.fromObject(object.multinotify[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomDownToUser message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomDownToUser} message ChatRoomDownToUser
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomDownToUser.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.multinotify = [];
                    if(options.defaults) {
                        object.result = 0;
                        object.payloadtype = 0;
                        object.createchatroomresp = null;
                        object.getchatroominforesp = null;
                        object.applyjoinchatroomresp = null;
                        object.quitchatroomresp = null;
                        object.updatechatroomresp = null;
                        object.kickmemberresp = null;
                        object.querychatroomidresp = null;
                        object.updategameidresp = null;
                        object.queryallgameroomresp = null;
                        object.chatroommessageresp = null;
                        object.newmsgnotify = null;
                        object.errormsgnotify = null;
                        object.createrooms = null;
                        object.memberjoinnotify = null;
                        object.memberquitnotify = null;
                        object.subresp = null;
                        if(options.bytes === String)
                            object.reason = "";
                        else {
                            object.reason = [];
                            if(options.bytes !== Array)
                                object.reason = $util.newBuffer(object.reason);
                        }
                    }
                    if(message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    if(message.payloadtype != null && message.hasOwnProperty("payloadtype"))
                        object.payloadtype = message.payloadtype;
                    if(message.createchatroomresp != null && message.hasOwnProperty("createchatroomresp"))
                        object.createchatroomresp = $root.qihoo.protocol.chatroom.CreateChatRoomResponse.toObject(message.createchatroomresp, options);
                    if(message.getchatroominforesp != null && message.hasOwnProperty("getchatroominforesp"))
                        object.getchatroominforesp = $root.qihoo.protocol.chatroom.GetChatRoomDetailResponse.toObject(message.getchatroominforesp, options);
                    if(message.applyjoinchatroomresp != null && message.hasOwnProperty("applyjoinchatroomresp"))
                        object.applyjoinchatroomresp = $root.qihoo.protocol.chatroom.ApplyJoinChatRoomResponse.toObject(message.applyjoinchatroomresp, options);
                    if(message.quitchatroomresp != null && message.hasOwnProperty("quitchatroomresp"))
                        object.quitchatroomresp = $root.qihoo.protocol.chatroom.QuitChatRoomResponse.toObject(message.quitchatroomresp, options);
                    if(message.updatechatroomresp != null && message.hasOwnProperty("updatechatroomresp"))
                        object.updatechatroomresp = $root.qihoo.protocol.chatroom.UpdateChatRoomResponse.toObject(message.updatechatroomresp, options);
                    if(message.kickmemberresp != null && message.hasOwnProperty("kickmemberresp"))
                        object.kickmemberresp = $root.qihoo.protocol.chatroom.KickChatRoomMemberResponse.toObject(message.kickmemberresp, options);
                    if(message.querychatroomidresp != null && message.hasOwnProperty("querychatroomidresp"))
                        object.querychatroomidresp = $root.qihoo.protocol.chatroom.QueryChatRoomIDResponse.toObject(message.querychatroomidresp, options);
                    if(message.updategameidresp != null && message.hasOwnProperty("updategameidresp"))
                        object.updategameidresp = $root.qihoo.protocol.chatroom.UpdateRoomIDResponse.toObject(message.updategameidresp, options);
                    if(message.queryallgameroomresp != null && message.hasOwnProperty("queryallgameroomresp"))
                        object.queryallgameroomresp = $root.qihoo.protocol.chatroom.QueryAllGameRoomResponse.toObject(message.queryallgameroomresp, options);
                    if(message.chatroommessageresp != null && message.hasOwnProperty("chatroommessageresp"))
                        object.chatroommessageresp = $root.qihoo.protocol.chatroom.ChatRoomMessageResponse.toObject(message.chatroommessageresp, options);
                    if(message.newmsgnotify != null && message.hasOwnProperty("newmsgnotify"))
                        object.newmsgnotify = $root.qihoo.protocol.chatroom.ChatRoomNewMsg.toObject(message.newmsgnotify, options);
                    if(message.errormsgnotify != null && message.hasOwnProperty("errormsgnotify"))
                        object.errormsgnotify = $root.qihoo.protocol.chatroom.ChatRoomErrorMsg.toObject(message.errormsgnotify, options);
                    if(message.createrooms != null && message.hasOwnProperty("createrooms"))
                        object.createrooms = $root.qihoo.protocol.chatroom.CreateMultiChatRoomResponse.toObject(message.createrooms, options);
                    if(message.memberjoinnotify != null && message.hasOwnProperty("memberjoinnotify"))
                        object.memberjoinnotify = $root.qihoo.protocol.chatroom.MemberJoinChatRoomNotify.toObject(message.memberjoinnotify, options);
                    if(message.memberquitnotify != null && message.hasOwnProperty("memberquitnotify"))
                        object.memberquitnotify = $root.qihoo.protocol.chatroom.MemberQuitChatRoomNotify.toObject(message.memberquitnotify, options);
                    if(message.subresp != null && message.hasOwnProperty("subresp"))
                        object.subresp = $root.qihoo.protocol.chatroom.SubscribeResponse.toObject(message.subresp, options);
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = options.bytes === String ? $util.base64.encode(message.reason, 0, message.reason.length) : options.bytes === Array ? Array.prototype.slice.call(message.reason) : message.reason;
                    if(message.multinotify && message.multinotify.length) {
                        object.multinotify = [];
                        for(let j = 0; j < message.multinotify.length; ++j)
                            object.multinotify[j] = $root.qihoo.protocol.chatroom.ChatRoomMNotify.toObject(message.multinotify[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ChatRoomDownToUser to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomDownToUser
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomDownToUser.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomDownToUser;
            })();

            chatroom.ChatRoomPacket = (function () {

                /**
                 * Properties of a ChatRoomPacket.
                 * @memberof qihoo.protocol.chatroom
                 * @interface IChatRoomPacket
                 * @property {Uint8Array} roomid ChatRoomPacket roomid
                 * @property {qihoo.protocol.chatroom.IChatRoomUpToServer|null} [to_server_data] ChatRoomPacket to_server_data
                 * @property {qihoo.protocol.chatroom.IChatRoomDownToUser|null} [to_user_data] ChatRoomPacket to_user_data
                 * @property {string|null} [uuid] ChatRoomPacket uuid
                 * @property {number|Long|null} [client_sn] ChatRoomPacket client_sn
                 * @property {number|null} [appid] ChatRoomPacket appid
                 */

                /**
                 * Constructs a new ChatRoomPacket.
                 * @memberof qihoo.protocol.chatroom
                 * @classdesc Represents a ChatRoomPacket.
                 * @implements IChatRoomPacket
                 * @constructor
                 * @param {qihoo.protocol.chatroom.IChatRoomPacket=} [properties] Properties to set
                 */
                function ChatRoomPacket(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatRoomPacket roomid.
                 * @member {Uint8Array} roomid
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.roomid = $util.newBuffer([]);

                /**
                 * ChatRoomPacket to_server_data.
                 * @member {qihoo.protocol.chatroom.IChatRoomUpToServer|null|undefined} to_server_data
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.to_server_data = null;

                /**
                 * ChatRoomPacket to_user_data.
                 * @member {qihoo.protocol.chatroom.IChatRoomDownToUser|null|undefined} to_user_data
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.to_user_data = null;

                /**
                 * ChatRoomPacket uuid.
                 * @member {string} uuid
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.uuid = "";

                /**
                 * ChatRoomPacket client_sn.
                 * @member {number|Long} client_sn
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.client_sn = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * ChatRoomPacket appid.
                 * @member {number} appid
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 */
                ChatRoomPacket.prototype.appid = 0;

                /**
                 * Creates a new ChatRoomPacket instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomPacket=} [properties] Properties to set
                 * @returns {qihoo.protocol.chatroom.ChatRoomPacket} ChatRoomPacket instance
                 */
                ChatRoomPacket.create = function create(properties) {
                    return new ChatRoomPacket(properties);
                };

                /**
                 * Encodes the specified ChatRoomPacket message. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomPacket.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomPacket} message ChatRoomPacket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomPacket.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.roomid);
                    if(message.to_server_data != null && message.hasOwnProperty("to_server_data"))
                        $root.qihoo.protocol.chatroom.ChatRoomUpToServer.encode(message.to_server_data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.to_user_data != null && message.hasOwnProperty("to_user_data"))
                        $root.qihoo.protocol.chatroom.ChatRoomDownToUser.encode(message.to_user_data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.uuid != null && message.hasOwnProperty("uuid"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.uuid);
                    if(message.client_sn != null && message.hasOwnProperty("client_sn"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.client_sn);
                    if(message.appid != null && message.hasOwnProperty("appid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.appid);
                    return writer;
                };

                /**
                 * Encodes the specified ChatRoomPacket message, length delimited. Does not implicitly {@link qihoo.protocol.chatroom.ChatRoomPacket.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {qihoo.protocol.chatroom.IChatRoomPacket} message ChatRoomPacket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatRoomPacket.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatRoomPacket message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.chatroom.ChatRoomPacket} ChatRoomPacket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomPacket.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.chatroom.ChatRoomPacket();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.roomid = reader.bytes();
                                break;
                            case 2:
                                message.to_server_data = $root.qihoo.protocol.chatroom.ChatRoomUpToServer.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.to_user_data = $root.qihoo.protocol.chatroom.ChatRoomDownToUser.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.uuid = reader.string();
                                break;
                            case 5:
                                message.client_sn = reader.uint64();
                                break;
                            case 6:
                                message.appid = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("roomid"))
                        throw $util.ProtocolError("missing required 'roomid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatRoomPacket message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.chatroom.ChatRoomPacket} ChatRoomPacket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatRoomPacket.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatRoomPacket message.
                 * @function verify
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatRoomPacket.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.roomid && typeof message.roomid.length === "number" || $util.isString(message.roomid)))
                        return "roomid: buffer expected";
                    if(message.to_server_data != null && message.hasOwnProperty("to_server_data")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomUpToServer.verify(message.to_server_data);
                        if(error)
                            return "to_server_data." + error;
                    }
                    if(message.to_user_data != null && message.hasOwnProperty("to_user_data")) {
                        let error = $root.qihoo.protocol.chatroom.ChatRoomDownToUser.verify(message.to_user_data);
                        if(error)
                            return "to_user_data." + error;
                    }
                    if(message.uuid != null && message.hasOwnProperty("uuid"))
                        if(!$util.isString(message.uuid))
                            return "uuid: string expected";
                    if(message.client_sn != null && message.hasOwnProperty("client_sn"))
                        if(!$util.isInteger(message.client_sn) && !(message.client_sn && $util.isInteger(message.client_sn.low) && $util.isInteger(message.client_sn.high)))
                            return "client_sn: integer|Long expected";
                    if(message.appid != null && message.hasOwnProperty("appid"))
                        if(!$util.isInteger(message.appid))
                            return "appid: integer expected";
                    return null;
                };

                /**
                 * Creates a ChatRoomPacket message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.chatroom.ChatRoomPacket} ChatRoomPacket
                 */
                ChatRoomPacket.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.chatroom.ChatRoomPacket)
                        return object;
                    let message = new $root.qihoo.protocol.chatroom.ChatRoomPacket();
                    if(object.roomid != null)
                        if(typeof object.roomid === "string")
                            $util.base64.decode(object.roomid, message.roomid = $util.newBuffer($util.base64.length(object.roomid)), 0);
                        else if(object.roomid.length)
                            message.roomid = object.roomid;
                    if(object.to_server_data != null) {
                        if(typeof object.to_server_data !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomPacket.to_server_data: object expected");
                        message.to_server_data = $root.qihoo.protocol.chatroom.ChatRoomUpToServer.fromObject(object.to_server_data);
                    }
                    if(object.to_user_data != null) {
                        if(typeof object.to_user_data !== "object")
                            throw TypeError(".qihoo.protocol.chatroom.ChatRoomPacket.to_user_data: object expected");
                        message.to_user_data = $root.qihoo.protocol.chatroom.ChatRoomDownToUser.fromObject(object.to_user_data);
                    }
                    if(object.uuid != null)
                        message.uuid = String(object.uuid);
                    if(object.client_sn != null)
                        if($util.Long)
                            (message.client_sn = $util.Long.fromValue(object.client_sn)).unsigned = true;
                        else if(typeof object.client_sn === "string")
                            message.client_sn = parseInt(object.client_sn, 10);
                        else if(typeof object.client_sn === "number")
                            message.client_sn = object.client_sn;
                        else if(typeof object.client_sn === "object")
                            message.client_sn = new $util.LongBits(object.client_sn.low >>> 0, object.client_sn.high >>> 0).toNumber(true);
                    if(object.appid != null)
                        message.appid = object.appid >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatRoomPacket message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @static
                 * @param {qihoo.protocol.chatroom.ChatRoomPacket} message ChatRoomPacket
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatRoomPacket.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.roomid = "";
                        else {
                            object.roomid = [];
                            if(options.bytes !== Array)
                                object.roomid = $util.newBuffer(object.roomid);
                        }
                        object.to_server_data = null;
                        object.to_user_data = null;
                        object.uuid = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.client_sn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.client_sn = options.longs === String ? "0" : 0;
                        object.appid = 0;
                    }
                    if(message.roomid != null && message.hasOwnProperty("roomid"))
                        object.roomid = options.bytes === String ? $util.base64.encode(message.roomid, 0, message.roomid.length) : options.bytes === Array ? Array.prototype.slice.call(message.roomid) : message.roomid;
                    if(message.to_server_data != null && message.hasOwnProperty("to_server_data"))
                        object.to_server_data = $root.qihoo.protocol.chatroom.ChatRoomUpToServer.toObject(message.to_server_data, options);
                    if(message.to_user_data != null && message.hasOwnProperty("to_user_data"))
                        object.to_user_data = $root.qihoo.protocol.chatroom.ChatRoomDownToUser.toObject(message.to_user_data, options);
                    if(message.uuid != null && message.hasOwnProperty("uuid"))
                        object.uuid = message.uuid;
                    if(message.client_sn != null && message.hasOwnProperty("client_sn"))
                        if(typeof message.client_sn === "number")
                            object.client_sn = options.longs === String ? String(message.client_sn) : message.client_sn;
                        else
                            object.client_sn = options.longs === String ? $util.Long.prototype.toString.call(message.client_sn) : options.longs === Number ? new $util.LongBits(message.client_sn.low >>> 0, message.client_sn.high >>> 0).toNumber(true) : message.client_sn;
                    if(message.appid != null && message.hasOwnProperty("appid"))
                        object.appid = message.appid;
                    return object;
                };

                /**
                 * Converts this ChatRoomPacket to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.chatroom.ChatRoomPacket
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatRoomPacket.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatRoomPacket;
            })();

            return chatroom;
        })();

        protocol.messages = (function () {

            /**
             * Namespace messages.
             * @memberof qihoo.protocol
             * @namespace
             */
            const messages = {};

            messages.Pair = (function () {

                /**
                 * Properties of a Pair.
                 * @memberof qihoo.protocol.messages
                 * @interface IPair
                 * @property {Uint8Array} key Pair key
                 * @property {Uint8Array|null} [value] Pair value
                 */

                /**
                 * Constructs a new Pair.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Pair.
                 * @implements IPair
                 * @constructor
                 * @param {qihoo.protocol.messages.IPair=} [properties] Properties to set
                 */
                function Pair(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pair key.
                 * @member {Uint8Array} key
                 * @memberof qihoo.protocol.messages.Pair
                 * @instance
                 */
                Pair.prototype.key = $util.newBuffer([]);

                /**
                 * Pair value.
                 * @member {Uint8Array} value
                 * @memberof qihoo.protocol.messages.Pair
                 * @instance
                 */
                Pair.prototype.value = $util.newBuffer([]);

                /**
                 * Creates a new Pair instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {qihoo.protocol.messages.IPair=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Pair} Pair instance
                 */
                Pair.create = function create(properties) {
                    return new Pair(properties);
                };

                /**
                 * Encodes the specified Pair message. Does not implicitly {@link qihoo.protocol.messages.Pair.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {qihoo.protocol.messages.IPair} message Pair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pair.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                    if(message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified Pair message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Pair.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {qihoo.protocol.messages.IPair} message Pair message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pair.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Pair message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Pair} Pair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pair.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Pair();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.key = reader.bytes();
                                break;
                            case 2:
                                message.value = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("key"))
                        throw $util.ProtocolError("missing required 'key'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Pair message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Pair} Pair
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pair.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Pair message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pair.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                    if(message.value != null && message.hasOwnProperty("value"))
                        if(!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };

                /**
                 * Creates a Pair message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Pair} Pair
                 */
                Pair.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Pair)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Pair();
                    if(object.key != null)
                        if(typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if(object.key.length)
                            message.key = object.key;
                    if(object.value != null)
                        if(typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if(object.value.length)
                            message.value = object.value;
                    return message;
                };

                /**
                 * Creates a plain object from a Pair message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Pair
                 * @static
                 * @param {qihoo.protocol.messages.Pair} message Pair
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pair.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if(options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                        if(options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if(options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if(message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if(message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };

                /**
                 * Converts this Pair to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Pair
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pair.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Pair;
            })();

            messages.Error = (function () {

                /**
                 * Properties of an Error.
                 * @memberof qihoo.protocol.messages
                 * @interface IError
                 * @property {number} id Error id
                 * @property {Uint8Array|null} [description] Error description
                 */

                /**
                 * Constructs a new Error.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an Error.
                 * @implements IError
                 * @constructor
                 * @param {qihoo.protocol.messages.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Error id.
                 * @member {number} id
                 * @memberof qihoo.protocol.messages.Error
                 * @instance
                 */
                Error.prototype.id = 0;

                /**
                 * Error description.
                 * @member {Uint8Array} description
                 * @memberof qihoo.protocol.messages.Error
                 * @instance
                 */
                Error.prototype.description = $util.newBuffer([]);

                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {qihoo.protocol.messages.IError=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };

                /**
                 * Encodes the specified Error message. Does not implicitly {@link qihoo.protocol.messages.Error.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {qihoo.protocol.messages.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                    if(message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified Error message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Error.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {qihoo.protocol.messages.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Error();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.id = reader.uint32();
                                break;
                            case 2:
                                message.description = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("id"))
                        throw $util.ProtocolError("missing required 'id'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Error message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.id))
                        return "id: integer expected";
                    if(message.description != null && message.hasOwnProperty("description"))
                        if(!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                            return "description: buffer expected";
                    return null;
                };

                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Error} Error
                 */
                Error.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Error)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Error();
                    if(object.id != null)
                        message.id = object.id >>> 0;
                    if(object.description != null)
                        if(typeof object.description === "string")
                            $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                        else if(object.description.length)
                            message.description = object.description;
                    return message;
                };

                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Error
                 * @static
                 * @param {qihoo.protocol.messages.Error} message Error
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Error.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.id = 0;
                        if(options.bytes === String)
                            object.description = "";
                        else {
                            object.description = [];
                            if(options.bytes !== Array)
                                object.description = $util.newBuffer(object.description);
                        }
                    }
                    if(message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if(message.description != null && message.hasOwnProperty("description"))
                        object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
                    return object;
                };

                /**
                 * Converts this Error to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Error
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Error.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Error;
            })();

            messages.User = (function () {

                /**
                 * Properties of a User.
                 * @memberof qihoo.protocol.messages
                 * @interface IUser
                 * @property {string} userid User userid
                 * @property {Array.<qihoo.protocol.messages.IPair>|null} [property_pairs] User property_pairs
                 */

                /**
                 * Constructs a new User.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a User.
                 * @implements IUser
                 * @constructor
                 * @param {qihoo.protocol.messages.IUser=} [properties] Properties to set
                 */
                function User(properties) {
                    this.property_pairs = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * User userid.
                 * @member {string} userid
                 * @memberof qihoo.protocol.messages.User
                 * @instance
                 */
                User.prototype.userid = "";

                /**
                 * User property_pairs.
                 * @member {Array.<qihoo.protocol.messages.IPair>} property_pairs
                 * @memberof qihoo.protocol.messages.User
                 * @instance
                 */
                User.prototype.property_pairs = $util.emptyArray;

                /**
                 * Creates a new User instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {qihoo.protocol.messages.IUser=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.User} User instance
                 */
                User.create = function create(properties) {
                    return new User(properties);
                };

                /**
                 * Encodes the specified User message. Does not implicitly {@link qihoo.protocol.messages.User.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {qihoo.protocol.messages.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userid);
                    if(message.property_pairs != null && message.property_pairs.length)
                        for(let i = 0; i < message.property_pairs.length; ++i)
                            $root.qihoo.protocol.messages.Pair.encode(message.property_pairs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified User message, length delimited. Does not implicitly {@link qihoo.protocol.messages.User.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {qihoo.protocol.messages.IUser} message User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                User.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a User message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.User();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.userid = reader.string();
                                break;
                            case 2:
                                if(!(message.property_pairs && message.property_pairs.length))
                                    message.property_pairs = [];
                                message.property_pairs.push($root.qihoo.protocol.messages.Pair.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("userid"))
                        throw $util.ProtocolError("missing required 'userid'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a User message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.User} User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                User.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a User message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                User.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.userid))
                        return "userid: string expected";
                    if(message.property_pairs != null && message.hasOwnProperty("property_pairs")) {
                        if(!Array.isArray(message.property_pairs))
                            return "property_pairs: array expected";
                        for(let i = 0; i < message.property_pairs.length; ++i) {
                            let error = $root.qihoo.protocol.messages.Pair.verify(message.property_pairs[i]);
                            if(error)
                                return "property_pairs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a User message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.User} User
                 */
                User.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.User)
                        return object;
                    let message = new $root.qihoo.protocol.messages.User();
                    if(object.userid != null)
                        message.userid = String(object.userid);
                    if(object.property_pairs) {
                        if(!Array.isArray(object.property_pairs))
                            throw TypeError(".qihoo.protocol.messages.User.property_pairs: array expected");
                        message.property_pairs = [];
                        for(let i = 0; i < object.property_pairs.length; ++i) {
                            if(typeof object.property_pairs[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.User.property_pairs: object expected");
                            message.property_pairs[i] = $root.qihoo.protocol.messages.Pair.fromObject(object.property_pairs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a User message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.User
                 * @static
                 * @param {qihoo.protocol.messages.User} message User
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                User.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.property_pairs = [];
                    if(options.defaults)
                        object.userid = "";
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        object.userid = message.userid;
                    if(message.property_pairs && message.property_pairs.length) {
                        object.property_pairs = [];
                        for(let j = 0; j < message.property_pairs.length; ++j)
                            object.property_pairs[j] = $root.qihoo.protocol.messages.Pair.toObject(message.property_pairs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this User to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.User
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                User.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return User;
            })();

            messages.Info = (function () {

                /**
                 * Properties of an Info.
                 * @memberof qihoo.protocol.messages
                 * @interface IInfo
                 * @property {Array.<qihoo.protocol.messages.IPair>|null} [property_pairs] Info property_pairs
                 */

                /**
                 * Constructs a new Info.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an Info.
                 * @implements IInfo
                 * @constructor
                 * @param {qihoo.protocol.messages.IInfo=} [properties] Properties to set
                 */
                function Info(properties) {
                    this.property_pairs = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Info property_pairs.
                 * @member {Array.<qihoo.protocol.messages.IPair>} property_pairs
                 * @memberof qihoo.protocol.messages.Info
                 * @instance
                 */
                Info.prototype.property_pairs = $util.emptyArray;

                /**
                 * Creates a new Info instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {qihoo.protocol.messages.IInfo=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Info} Info instance
                 */
                Info.create = function create(properties) {
                    return new Info(properties);
                };

                /**
                 * Encodes the specified Info message. Does not implicitly {@link qihoo.protocol.messages.Info.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {qihoo.protocol.messages.IInfo} message Info message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Info.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.property_pairs != null && message.property_pairs.length)
                        for(let i = 0; i < message.property_pairs.length; ++i)
                            $root.qihoo.protocol.messages.Pair.encode(message.property_pairs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Info message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Info.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {qihoo.protocol.messages.IInfo} message Info message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Info.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Info message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Info} Info
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Info.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Info();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.property_pairs && message.property_pairs.length))
                                    message.property_pairs = [];
                                message.property_pairs.push($root.qihoo.protocol.messages.Pair.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Info message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Info} Info
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Info.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Info message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Info.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.property_pairs != null && message.hasOwnProperty("property_pairs")) {
                        if(!Array.isArray(message.property_pairs))
                            return "property_pairs: array expected";
                        for(let i = 0; i < message.property_pairs.length; ++i) {
                            let error = $root.qihoo.protocol.messages.Pair.verify(message.property_pairs[i]);
                            if(error)
                                return "property_pairs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Info message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Info} Info
                 */
                Info.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Info)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Info();
                    if(object.property_pairs) {
                        if(!Array.isArray(object.property_pairs))
                            throw TypeError(".qihoo.protocol.messages.Info.property_pairs: array expected");
                        message.property_pairs = [];
                        for(let i = 0; i < object.property_pairs.length; ++i) {
                            if(typeof object.property_pairs[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.Info.property_pairs: object expected");
                            message.property_pairs[i] = $root.qihoo.protocol.messages.Pair.fromObject(object.property_pairs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Info message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Info
                 * @static
                 * @param {qihoo.protocol.messages.Info} message Info
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Info.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.property_pairs = [];
                    if(message.property_pairs && message.property_pairs.length) {
                        object.property_pairs = [];
                        for(let j = 0; j < message.property_pairs.length; ++j)
                            object.property_pairs[j] = $root.qihoo.protocol.messages.Pair.toObject(message.property_pairs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Info to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Info
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Info.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Info;
            })();

            messages.LoginReq = (function () {

                /**
                 * Properties of a LoginReq.
                 * @memberof qihoo.protocol.messages
                 * @interface ILoginReq
                 * @property {string} mobile_type LoginReq mobile_type
                 * @property {number} net_type LoginReq net_type
                 * @property {string} server_ram LoginReq server_ram
                 * @property {Uint8Array|null} [secret_ram] LoginReq secret_ram
                 * @property {number|null} [app_id] LoginReq app_id
                 * @property {number|null} [heart_feq] LoginReq heart_feq
                 * @property {string|null} [deviceid] LoginReq deviceid
                 * @property {string|null} [platform] LoginReq platform
                 * @property {string|null} [verf_code] LoginReq verf_code
                 * @property {boolean|null} [not_encrypt] LoginReq not_encrypt
                 */

                /**
                 * Constructs a new LoginReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a LoginReq.
                 * @implements ILoginReq
                 * @constructor
                 * @param {qihoo.protocol.messages.ILoginReq=} [properties] Properties to set
                 */
                function LoginReq(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginReq mobile_type.
                 * @member {string} mobile_type
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.mobile_type = "";

                /**
                 * LoginReq net_type.
                 * @member {number} net_type
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.net_type = 0;

                /**
                 * LoginReq server_ram.
                 * @member {string} server_ram
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.server_ram = "";

                /**
                 * LoginReq secret_ram.
                 * @member {Uint8Array} secret_ram
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.secret_ram = $util.newBuffer([]);

                /**
                 * LoginReq app_id.
                 * @member {number} app_id
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.app_id = 2000;

                /**
                 * LoginReq heart_feq.
                 * @member {number} heart_feq
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.heart_feq = 300;

                /**
                 * LoginReq deviceid.
                 * @member {string} deviceid
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.deviceid = "";

                /**
                 * LoginReq platform.
                 * @member {string} platform
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.platform = "";

                /**
                 * LoginReq verf_code.
                 * @member {string} verf_code
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.verf_code = "";

                /**
                 * LoginReq not_encrypt.
                 * @member {boolean} not_encrypt
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 */
                LoginReq.prototype.not_encrypt = false;

                /**
                 * Creates a new LoginReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {qihoo.protocol.messages.ILoginReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.LoginReq} LoginReq instance
                 */
                LoginReq.create = function create(properties) {
                    return new LoginReq(properties);
                };

                /**
                 * Encodes the specified LoginReq message. Does not implicitly {@link qihoo.protocol.messages.LoginReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {qihoo.protocol.messages.ILoginReq} message LoginReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoginReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mobile_type);
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.net_type);
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.server_ram);
                    if(message.secret_ram != null && message.hasOwnProperty("secret_ram"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.secret_ram);
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.app_id);
                    if(message.heart_feq != null && message.hasOwnProperty("heart_feq"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.heart_feq);
                    if(message.deviceid != null && message.hasOwnProperty("deviceid"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.deviceid);
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.platform);
                    if(message.verf_code != null && message.hasOwnProperty("verf_code"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.verf_code);
                    if(message.not_encrypt != null && message.hasOwnProperty("not_encrypt"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.not_encrypt);
                    return writer;
                };

                /**
                 * Encodes the specified LoginReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.LoginReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {qihoo.protocol.messages.ILoginReq} message LoginReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoginReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LoginReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.LoginReq} LoginReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoginReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.LoginReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.mobile_type = reader.string();
                                break;
                            case 2:
                                message.net_type = reader.uint32();
                                break;
                            case 3:
                                message.server_ram = reader.string();
                                break;
                            case 4:
                                message.secret_ram = reader.bytes();
                                break;
                            case 5:
                                message.app_id = reader.uint32();
                                break;
                            case 6:
                                message.heart_feq = reader.uint32();
                                break;
                            case 7:
                                message.deviceid = reader.string();
                                break;
                            case 8:
                                message.platform = reader.string();
                                break;
                            case 9:
                                message.verf_code = reader.string();
                                break;
                            case 10:
                                message.not_encrypt = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("mobile_type"))
                        throw $util.ProtocolError("missing required 'mobile_type'", { instance: message });
                    if(!message.hasOwnProperty("net_type"))
                        throw $util.ProtocolError("missing required 'net_type'", { instance: message });
                    if(!message.hasOwnProperty("server_ram"))
                        throw $util.ProtocolError("missing required 'server_ram'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a LoginReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.LoginReq} LoginReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoginReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LoginReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.mobile_type))
                        return "mobile_type: string expected";
                    if(!$util.isInteger(message.net_type))
                        return "net_type: integer expected";
                    if(!$util.isString(message.server_ram))
                        return "server_ram: string expected";
                    if(message.secret_ram != null && message.hasOwnProperty("secret_ram"))
                        if(!(message.secret_ram && typeof message.secret_ram.length === "number" || $util.isString(message.secret_ram)))
                            return "secret_ram: buffer expected";
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        if(!$util.isInteger(message.app_id))
                            return "app_id: integer expected";
                    if(message.heart_feq != null && message.hasOwnProperty("heart_feq"))
                        if(!$util.isInteger(message.heart_feq))
                            return "heart_feq: integer expected";
                    if(message.deviceid != null && message.hasOwnProperty("deviceid"))
                        if(!$util.isString(message.deviceid))
                            return "deviceid: string expected";
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        if(!$util.isString(message.platform))
                            return "platform: string expected";
                    if(message.verf_code != null && message.hasOwnProperty("verf_code"))
                        if(!$util.isString(message.verf_code))
                            return "verf_code: string expected";
                    if(message.not_encrypt != null && message.hasOwnProperty("not_encrypt"))
                        if(typeof message.not_encrypt !== "boolean")
                            return "not_encrypt: boolean expected";
                    return null;
                };

                /**
                 * Creates a LoginReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.LoginReq} LoginReq
                 */
                LoginReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.LoginReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.LoginReq();
                    if(object.mobile_type != null)
                        message.mobile_type = String(object.mobile_type);
                    if(object.net_type != null)
                        message.net_type = object.net_type >>> 0;
                    if(object.server_ram != null)
                        message.server_ram = String(object.server_ram);
                    if(object.secret_ram != null)
                        if(typeof object.secret_ram === "string")
                            $util.base64.decode(object.secret_ram, message.secret_ram = $util.newBuffer($util.base64.length(object.secret_ram)), 0);
                        else if(object.secret_ram.length)
                            message.secret_ram = object.secret_ram;
                    if(object.app_id != null)
                        message.app_id = object.app_id >>> 0;
                    if(object.heart_feq != null)
                        message.heart_feq = object.heart_feq >>> 0;
                    if(object.deviceid != null)
                        message.deviceid = String(object.deviceid);
                    if(object.platform != null)
                        message.platform = String(object.platform);
                    if(object.verf_code != null)
                        message.verf_code = String(object.verf_code);
                    if(object.not_encrypt != null)
                        message.not_encrypt = Boolean(object.not_encrypt);
                    return message;
                };

                /**
                 * Creates a plain object from a LoginReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @static
                 * @param {qihoo.protocol.messages.LoginReq} message LoginReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.mobile_type = "";
                        object.net_type = 0;
                        object.server_ram = "";
                        if(options.bytes === String)
                            object.secret_ram = "";
                        else {
                            object.secret_ram = [];
                            if(options.bytes !== Array)
                                object.secret_ram = $util.newBuffer(object.secret_ram);
                        }
                        object.app_id = 2000;
                        object.heart_feq = 300;
                        object.deviceid = "";
                        object.platform = "";
                        object.verf_code = "";
                        object.not_encrypt = false;
                    }
                    if(message.mobile_type != null && message.hasOwnProperty("mobile_type"))
                        object.mobile_type = message.mobile_type;
                    if(message.net_type != null && message.hasOwnProperty("net_type"))
                        object.net_type = message.net_type;
                    if(message.server_ram != null && message.hasOwnProperty("server_ram"))
                        object.server_ram = message.server_ram;
                    if(message.secret_ram != null && message.hasOwnProperty("secret_ram"))
                        object.secret_ram = options.bytes === String ? $util.base64.encode(message.secret_ram, 0, message.secret_ram.length) : options.bytes === Array ? Array.prototype.slice.call(message.secret_ram) : message.secret_ram;
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        object.app_id = message.app_id;
                    if(message.heart_feq != null && message.hasOwnProperty("heart_feq"))
                        object.heart_feq = message.heart_feq;
                    if(message.deviceid != null && message.hasOwnProperty("deviceid"))
                        object.deviceid = message.deviceid;
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        object.platform = message.platform;
                    if(message.verf_code != null && message.hasOwnProperty("verf_code"))
                        object.verf_code = message.verf_code;
                    if(message.not_encrypt != null && message.hasOwnProperty("not_encrypt"))
                        object.not_encrypt = message.not_encrypt;
                    return object;
                };

                /**
                 * Converts this LoginReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.LoginReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LoginReq;
            })();

            messages.LoginResp = (function () {

                /**
                 * Properties of a LoginResp.
                 * @memberof qihoo.protocol.messages
                 * @interface ILoginResp
                 * @property {number} timestamp LoginResp timestamp
                 * @property {string} session_id LoginResp session_id
                 * @property {string} session_key LoginResp session_key
                 * @property {string|null} [client_login_ip] LoginResp client_login_ip
                 * @property {string|null} [serverip] LoginResp serverip
                 */

                /**
                 * Constructs a new LoginResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a LoginResp.
                 * @implements ILoginResp
                 * @constructor
                 * @param {qihoo.protocol.messages.ILoginResp=} [properties] Properties to set
                 */
                function LoginResp(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginResp timestamp.
                 * @member {number} timestamp
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 */
                LoginResp.prototype.timestamp = 0;

                /**
                 * LoginResp session_id.
                 * @member {string} session_id
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 */
                LoginResp.prototype.session_id = "";

                /**
                 * LoginResp session_key.
                 * @member {string} session_key
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 */
                LoginResp.prototype.session_key = "";

                /**
                 * LoginResp client_login_ip.
                 * @member {string} client_login_ip
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 */
                LoginResp.prototype.client_login_ip = "";

                /**
                 * LoginResp serverip.
                 * @member {string} serverip
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 */
                LoginResp.prototype.serverip = "";

                /**
                 * Creates a new LoginResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {qihoo.protocol.messages.ILoginResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.LoginResp} LoginResp instance
                 */
                LoginResp.create = function create(properties) {
                    return new LoginResp(properties);
                };

                /**
                 * Encodes the specified LoginResp message. Does not implicitly {@link qihoo.protocol.messages.LoginResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {qihoo.protocol.messages.ILoginResp} message LoginResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoginResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timestamp);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.session_id);
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.session_key);
                    if(message.client_login_ip != null && message.hasOwnProperty("client_login_ip"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.client_login_ip);
                    if(message.serverip != null && message.hasOwnProperty("serverip"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.serverip);
                    return writer;
                };

                /**
                 * Encodes the specified LoginResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.LoginResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {qihoo.protocol.messages.ILoginResp} message LoginResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoginResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LoginResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.LoginResp} LoginResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoginResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.LoginResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.timestamp = reader.uint32();
                                break;
                            case 2:
                                message.session_id = reader.string();
                                break;
                            case 3:
                                message.session_key = reader.string();
                                break;
                            case 4:
                                message.client_login_ip = reader.string();
                                break;
                            case 5:
                                message.serverip = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("timestamp"))
                        throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
                    if(!message.hasOwnProperty("session_id"))
                        throw $util.ProtocolError("missing required 'session_id'", { instance: message });
                    if(!message.hasOwnProperty("session_key"))
                        throw $util.ProtocolError("missing required 'session_key'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a LoginResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.LoginResp} LoginResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoginResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LoginResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.timestamp))
                        return "timestamp: integer expected";
                    if(!$util.isString(message.session_id))
                        return "session_id: string expected";
                    if(!$util.isString(message.session_key))
                        return "session_key: string expected";
                    if(message.client_login_ip != null && message.hasOwnProperty("client_login_ip"))
                        if(!$util.isString(message.client_login_ip))
                            return "client_login_ip: string expected";
                    if(message.serverip != null && message.hasOwnProperty("serverip"))
                        if(!$util.isString(message.serverip))
                            return "serverip: string expected";
                    return null;
                };

                /**
                 * Creates a LoginResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.LoginResp} LoginResp
                 */
                LoginResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.LoginResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.LoginResp();
                    if(object.timestamp != null)
                        message.timestamp = object.timestamp >>> 0;
                    if(object.session_id != null)
                        message.session_id = String(object.session_id);
                    if(object.session_key != null)
                        message.session_key = String(object.session_key);
                    if(object.client_login_ip != null)
                        message.client_login_ip = String(object.client_login_ip);
                    if(object.serverip != null)
                        message.serverip = String(object.serverip);
                    return message;
                };

                /**
                 * Creates a plain object from a LoginResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @static
                 * @param {qihoo.protocol.messages.LoginResp} message LoginResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.timestamp = 0;
                        object.session_id = "";
                        object.session_key = "";
                        object.client_login_ip = "";
                        object.serverip = "";
                    }
                    if(message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = message.timestamp;
                    if(message.session_id != null && message.hasOwnProperty("session_id"))
                        object.session_id = message.session_id;
                    if(message.session_key != null && message.hasOwnProperty("session_key"))
                        object.session_key = message.session_key;
                    if(message.client_login_ip != null && message.hasOwnProperty("client_login_ip"))
                        object.client_login_ip = message.client_login_ip;
                    if(message.serverip != null && message.hasOwnProperty("serverip"))
                        object.serverip = message.serverip;
                    return object;
                };

                /**
                 * Converts this LoginResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.LoginResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LoginResp;
            })();

            messages.ChatReq = (function () {

                /**
                 * Properties of a ChatReq.
                 * @memberof qihoo.protocol.messages
                 * @interface IChatReq
                 * @property {Uint8Array} body ChatReq body
                 * @property {number|null} [body_id] ChatReq body_id
                 * @property {number|null} [more_flag] ChatReq more_flag
                 * @property {number} body_type ChatReq body_type
                 * @property {boolean|null} [store] ChatReq store
                 * @property {Uint8Array|null} [m_parameter] ChatReq m_parameter
                 * @property {number|null} [service_id] ChatReq service_id
                 * @property {Uint8Array|null} [s_parameter] ChatReq s_parameter
                 * @property {number|null} [expire_time] ChatReq expire_time
                 */

                /**
                 * Constructs a new ChatReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a ChatReq.
                 * @implements IChatReq
                 * @constructor
                 * @param {qihoo.protocol.messages.IChatReq=} [properties] Properties to set
                 */
                function ChatReq(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatReq body.
                 * @member {Uint8Array} body
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.body = $util.newBuffer([]);

                /**
                 * ChatReq body_id.
                 * @member {number} body_id
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.body_id = 0;

                /**
                 * ChatReq more_flag.
                 * @member {number} more_flag
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.more_flag = 0;

                /**
                 * ChatReq body_type.
                 * @member {number} body_type
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.body_type = 0;

                /**
                 * ChatReq store.
                 * @member {boolean} store
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.store = false;

                /**
                 * ChatReq m_parameter.
                 * @member {Uint8Array} m_parameter
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.m_parameter = $util.newBuffer([]);

                /**
                 * ChatReq service_id.
                 * @member {number} service_id
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.service_id = 0;

                /**
                 * ChatReq s_parameter.
                 * @member {Uint8Array} s_parameter
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.s_parameter = $util.newBuffer([]);

                /**
                 * ChatReq expire_time.
                 * @member {number} expire_time
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 */
                ChatReq.prototype.expire_time = 0;

                /**
                 * Creates a new ChatReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {qihoo.protocol.messages.IChatReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.ChatReq} ChatReq instance
                 */
                ChatReq.create = function create(properties) {
                    return new ChatReq(properties);
                };

                /**
                 * Encodes the specified ChatReq message. Does not implicitly {@link qihoo.protocol.messages.ChatReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {qihoo.protocol.messages.IChatReq} message ChatReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.body);
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.body_id);
                    if(message.more_flag != null && message.hasOwnProperty("more_flag"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.more_flag);
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.body_type);
                    if(message.store != null && message.hasOwnProperty("store"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.store);
                    if(message.m_parameter != null && message.hasOwnProperty("m_parameter"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.m_parameter);
                    if(message.service_id != null && message.hasOwnProperty("service_id"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.service_id);
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.s_parameter);
                    if(message.expire_time != null && message.hasOwnProperty("expire_time"))
                        writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.expire_time);
                    return writer;
                };

                /**
                 * Encodes the specified ChatReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.ChatReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {qihoo.protocol.messages.IChatReq} message ChatReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.ChatReq} ChatReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.ChatReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.body = reader.bytes();
                                break;
                            case 2:
                                message.body_id = reader.uint32();
                                break;
                            case 3:
                                message.more_flag = reader.uint32();
                                break;
                            case 4:
                                message.body_type = reader.uint32();
                                break;
                            case 5:
                                message.store = reader.bool();
                                break;
                            case 6:
                                message.m_parameter = reader.bytes();
                                break;
                            case 7:
                                message.service_id = reader.uint32();
                                break;
                            case 8:
                                message.s_parameter = reader.bytes();
                                break;
                            case 12:
                                message.expire_time = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("body"))
                        throw $util.ProtocolError("missing required 'body'", { instance: message });
                    if(!message.hasOwnProperty("body_type"))
                        throw $util.ProtocolError("missing required 'body_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.ChatReq} ChatReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.body && typeof message.body.length === "number" || $util.isString(message.body)))
                        return "body: buffer expected";
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        if(!$util.isInteger(message.body_id))
                            return "body_id: integer expected";
                    if(message.more_flag != null && message.hasOwnProperty("more_flag"))
                        if(!$util.isInteger(message.more_flag))
                            return "more_flag: integer expected";
                    if(!$util.isInteger(message.body_type))
                        return "body_type: integer expected";
                    if(message.store != null && message.hasOwnProperty("store"))
                        if(typeof message.store !== "boolean")
                            return "store: boolean expected";
                    if(message.m_parameter != null && message.hasOwnProperty("m_parameter"))
                        if(!(message.m_parameter && typeof message.m_parameter.length === "number" || $util.isString(message.m_parameter)))
                            return "m_parameter: buffer expected";
                    if(message.service_id != null && message.hasOwnProperty("service_id"))
                        if(!$util.isInteger(message.service_id))
                            return "service_id: integer expected";
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        if(!(message.s_parameter && typeof message.s_parameter.length === "number" || $util.isString(message.s_parameter)))
                            return "s_parameter: buffer expected";
                    if(message.expire_time != null && message.hasOwnProperty("expire_time"))
                        if(!$util.isInteger(message.expire_time))
                            return "expire_time: integer expected";
                    return null;
                };

                /**
                 * Creates a ChatReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.ChatReq} ChatReq
                 */
                ChatReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.ChatReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.ChatReq();
                    if(object.body != null)
                        if(typeof object.body === "string")
                            $util.base64.decode(object.body, message.body = $util.newBuffer($util.base64.length(object.body)), 0);
                        else if(object.body.length)
                            message.body = object.body;
                    if(object.body_id != null)
                        message.body_id = object.body_id >>> 0;
                    if(object.more_flag != null)
                        message.more_flag = object.more_flag >>> 0;
                    if(object.body_type != null)
                        message.body_type = object.body_type >>> 0;
                    if(object.store != null)
                        message.store = Boolean(object.store);
                    if(object.m_parameter != null)
                        if(typeof object.m_parameter === "string")
                            $util.base64.decode(object.m_parameter, message.m_parameter = $util.newBuffer($util.base64.length(object.m_parameter)), 0);
                        else if(object.m_parameter.length)
                            message.m_parameter = object.m_parameter;
                    if(object.service_id != null)
                        message.service_id = object.service_id >>> 0;
                    if(object.s_parameter != null)
                        if(typeof object.s_parameter === "string")
                            $util.base64.decode(object.s_parameter, message.s_parameter = $util.newBuffer($util.base64.length(object.s_parameter)), 0);
                        else if(object.s_parameter.length)
                            message.s_parameter = object.s_parameter;
                    if(object.expire_time != null)
                        message.expire_time = object.expire_time >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @static
                 * @param {qihoo.protocol.messages.ChatReq} message ChatReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.body = "";
                        else {
                            object.body = [];
                            if(options.bytes !== Array)
                                object.body = $util.newBuffer(object.body);
                        }
                        object.body_id = 0;
                        object.more_flag = 0;
                        object.body_type = 0;
                        object.store = false;
                        if(options.bytes === String)
                            object.m_parameter = "";
                        else {
                            object.m_parameter = [];
                            if(options.bytes !== Array)
                                object.m_parameter = $util.newBuffer(object.m_parameter);
                        }
                        object.service_id = 0;
                        if(options.bytes === String)
                            object.s_parameter = "";
                        else {
                            object.s_parameter = [];
                            if(options.bytes !== Array)
                                object.s_parameter = $util.newBuffer(object.s_parameter);
                        }
                        object.expire_time = 0;
                    }
                    if(message.body != null && message.hasOwnProperty("body"))
                        object.body = options.bytes === String ? $util.base64.encode(message.body, 0, message.body.length) : options.bytes === Array ? Array.prototype.slice.call(message.body) : message.body;
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        object.body_id = message.body_id;
                    if(message.more_flag != null && message.hasOwnProperty("more_flag"))
                        object.more_flag = message.more_flag;
                    if(message.body_type != null && message.hasOwnProperty("body_type"))
                        object.body_type = message.body_type;
                    if(message.store != null && message.hasOwnProperty("store"))
                        object.store = message.store;
                    if(message.m_parameter != null && message.hasOwnProperty("m_parameter"))
                        object.m_parameter = options.bytes === String ? $util.base64.encode(message.m_parameter, 0, message.m_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.m_parameter) : message.m_parameter;
                    if(message.service_id != null && message.hasOwnProperty("service_id"))
                        object.service_id = message.service_id;
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        object.s_parameter = options.bytes === String ? $util.base64.encode(message.s_parameter, 0, message.s_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.s_parameter) : message.s_parameter;
                    if(message.expire_time != null && message.hasOwnProperty("expire_time"))
                        object.expire_time = message.expire_time;
                    return object;
                };

                /**
                 * Converts this ChatReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.ChatReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatReq;
            })();

            messages.ChatResp = (function () {

                /**
                 * Properties of a ChatResp.
                 * @memberof qihoo.protocol.messages
                 * @interface IChatResp
                 * @property {number} result ChatResp result
                 * @property {number|null} [body_id] ChatResp body_id
                 */

                /**
                 * Constructs a new ChatResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a ChatResp.
                 * @implements IChatResp
                 * @constructor
                 * @param {qihoo.protocol.messages.IChatResp=} [properties] Properties to set
                 */
                function ChatResp(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChatResp result.
                 * @member {number} result
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @instance
                 */
                ChatResp.prototype.result = 0;

                /**
                 * ChatResp body_id.
                 * @member {number} body_id
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @instance
                 */
                ChatResp.prototype.body_id = 0;

                /**
                 * Creates a new ChatResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {qihoo.protocol.messages.IChatResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.ChatResp} ChatResp instance
                 */
                ChatResp.create = function create(properties) {
                    return new ChatResp(properties);
                };

                /**
                 * Encodes the specified ChatResp message. Does not implicitly {@link qihoo.protocol.messages.ChatResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {qihoo.protocol.messages.IChatResp} message ChatResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.result);
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.body_id);
                    return writer;
                };

                /**
                 * Encodes the specified ChatResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.ChatResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {qihoo.protocol.messages.IChatResp} message ChatResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChatResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChatResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.ChatResp} ChatResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.ChatResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.result = reader.uint32();
                                break;
                            case 2:
                                message.body_id = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("result"))
                        throw $util.ProtocolError("missing required 'result'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ChatResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.ChatResp} ChatResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChatResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChatResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChatResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.result))
                        return "result: integer expected";
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        if(!$util.isInteger(message.body_id))
                            return "body_id: integer expected";
                    return null;
                };

                /**
                 * Creates a ChatResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.ChatResp} ChatResp
                 */
                ChatResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.ChatResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.ChatResp();
                    if(object.result != null)
                        message.result = object.result >>> 0;
                    if(object.body_id != null)
                        message.body_id = object.body_id >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ChatResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @static
                 * @param {qihoo.protocol.messages.ChatResp} message ChatResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChatResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.result = 0;
                        object.body_id = 0;
                    }
                    if(message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    if(message.body_id != null && message.hasOwnProperty("body_id"))
                        object.body_id = message.body_id;
                    return object;
                };

                /**
                 * Converts this ChatResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.ChatResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChatResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ChatResp;
            })();

            messages.GetInfoReq = (function () {

                /**
                 * Properties of a GetInfoReq.
                 * @memberof qihoo.protocol.messages
                 * @interface IGetInfoReq
                 * @property {string} info_type GetInfoReq info_type
                 * @property {number|Long} get_info_id GetInfoReq get_info_id
                 * @property {number|null} [get_info_offset] GetInfoReq get_info_offset
                 * @property {Uint8Array|null} [s_parameter] GetInfoReq s_parameter
                 */

                /**
                 * Constructs a new GetInfoReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a GetInfoReq.
                 * @implements IGetInfoReq
                 * @constructor
                 * @param {qihoo.protocol.messages.IGetInfoReq=} [properties] Properties to set
                 */
                function GetInfoReq(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetInfoReq info_type.
                 * @member {string} info_type
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @instance
                 */
                GetInfoReq.prototype.info_type = "";

                /**
                 * GetInfoReq get_info_id.
                 * @member {number|Long} get_info_id
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @instance
                 */
                GetInfoReq.prototype.get_info_id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

                /**
                 * GetInfoReq get_info_offset.
                 * @member {number} get_info_offset
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @instance
                 */
                GetInfoReq.prototype.get_info_offset = 0;

                /**
                 * GetInfoReq s_parameter.
                 * @member {Uint8Array} s_parameter
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @instance
                 */
                GetInfoReq.prototype.s_parameter = $util.newBuffer([]);

                /**
                 * Creates a new GetInfoReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.GetInfoReq} GetInfoReq instance
                 */
                GetInfoReq.create = function create(properties) {
                    return new GetInfoReq(properties);
                };

                /**
                 * Encodes the specified GetInfoReq message. Does not implicitly {@link qihoo.protocol.messages.GetInfoReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoReq} message GetInfoReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInfoReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.info_type);
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.get_info_id);
                    if(message.get_info_offset != null && message.hasOwnProperty("get_info_offset"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.get_info_offset);
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s_parameter);
                    return writer;
                };

                /**
                 * Encodes the specified GetInfoReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.GetInfoReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoReq} message GetInfoReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInfoReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetInfoReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.GetInfoReq} GetInfoReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInfoReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.GetInfoReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.info_type = reader.string();
                                break;
                            case 2:
                                message.get_info_id = reader.int64();
                                break;
                            case 3:
                                message.get_info_offset = reader.int32();
                                break;
                            case 4:
                                message.s_parameter = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("info_type"))
                        throw $util.ProtocolError("missing required 'info_type'", { instance: message });
                    if(!message.hasOwnProperty("get_info_id"))
                        throw $util.ProtocolError("missing required 'get_info_id'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a GetInfoReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.GetInfoReq} GetInfoReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInfoReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetInfoReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetInfoReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.info_type))
                        return "info_type: string expected";
                    if(!$util.isInteger(message.get_info_id) && !(message.get_info_id && $util.isInteger(message.get_info_id.low) && $util.isInteger(message.get_info_id.high)))
                        return "get_info_id: integer|Long expected";
                    if(message.get_info_offset != null && message.hasOwnProperty("get_info_offset"))
                        if(!$util.isInteger(message.get_info_offset))
                            return "get_info_offset: integer expected";
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        if(!(message.s_parameter && typeof message.s_parameter.length === "number" || $util.isString(message.s_parameter)))
                            return "s_parameter: buffer expected";
                    return null;
                };

                /**
                 * Creates a GetInfoReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.GetInfoReq} GetInfoReq
                 */
                GetInfoReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.GetInfoReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.GetInfoReq();
                    if(object.info_type != null)
                        message.info_type = String(object.info_type);
                    if(object.get_info_id != null)
                        if($util.Long)
                            (message.get_info_id = $util.Long.fromValue(object.get_info_id)).unsigned = false;
                        else if(typeof object.get_info_id === "string")
                            message.get_info_id = parseInt(object.get_info_id, 10);
                        else if(typeof object.get_info_id === "number")
                            message.get_info_id = object.get_info_id;
                        else if(typeof object.get_info_id === "object")
                            message.get_info_id = new $util.LongBits(object.get_info_id.low >>> 0, object.get_info_id.high >>> 0).toNumber();
                    if(object.get_info_offset != null)
                        message.get_info_offset = object.get_info_offset | 0;
                    if(object.s_parameter != null)
                        if(typeof object.s_parameter === "string")
                            $util.base64.decode(object.s_parameter, message.s_parameter = $util.newBuffer($util.base64.length(object.s_parameter)), 0);
                        else if(object.s_parameter.length)
                            message.s_parameter = object.s_parameter;
                    return message;
                };

                /**
                 * Creates a plain object from a GetInfoReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @static
                 * @param {qihoo.protocol.messages.GetInfoReq} message GetInfoReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetInfoReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.info_type = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.get_info_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.get_info_id = options.longs === String ? "0" : 0;
                        object.get_info_offset = 0;
                        if(options.bytes === String)
                            object.s_parameter = "";
                        else {
                            object.s_parameter = [];
                            if(options.bytes !== Array)
                                object.s_parameter = $util.newBuffer(object.s_parameter);
                        }
                    }
                    if(message.info_type != null && message.hasOwnProperty("info_type"))
                        object.info_type = message.info_type;
                    if(message.get_info_id != null && message.hasOwnProperty("get_info_id"))
                        if(typeof message.get_info_id === "number")
                            object.get_info_id = options.longs === String ? String(message.get_info_id) : message.get_info_id;
                        else
                            object.get_info_id = options.longs === String ? $util.Long.prototype.toString.call(message.get_info_id) : options.longs === Number ? new $util.LongBits(message.get_info_id.low >>> 0, message.get_info_id.high >>> 0).toNumber() : message.get_info_id;
                    if(message.get_info_offset != null && message.hasOwnProperty("get_info_offset"))
                        object.get_info_offset = message.get_info_offset;
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        object.s_parameter = options.bytes === String ? $util.base64.encode(message.s_parameter, 0, message.s_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.s_parameter) : message.s_parameter;
                    return object;
                };

                /**
                 * Converts this GetInfoReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.GetInfoReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetInfoReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetInfoReq;
            })();

            messages.GetInfoResp = (function () {

                /**
                 * Properties of a GetInfoResp.
                 * @memberof qihoo.protocol.messages
                 * @interface IGetInfoResp
                 * @property {string} info_type GetInfoResp info_type
                 * @property {Array.<qihoo.protocol.messages.IInfo>|null} [infos] GetInfoResp infos
                 * @property {number|Long|null} [last_info_id] GetInfoResp last_info_id
                 * @property {Uint8Array|null} [s_parameter] GetInfoResp s_parameter
                 */

                /**
                 * Constructs a new GetInfoResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a GetInfoResp.
                 * @implements IGetInfoResp
                 * @constructor
                 * @param {qihoo.protocol.messages.IGetInfoResp=} [properties] Properties to set
                 */
                function GetInfoResp(properties) {
                    this.infos = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetInfoResp info_type.
                 * @member {string} info_type
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @instance
                 */
                GetInfoResp.prototype.info_type = "";

                /**
                 * GetInfoResp infos.
                 * @member {Array.<qihoo.protocol.messages.IInfo>} infos
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @instance
                 */
                GetInfoResp.prototype.infos = $util.emptyArray;

                /**
                 * GetInfoResp last_info_id.
                 * @member {number|Long} last_info_id
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @instance
                 */
                GetInfoResp.prototype.last_info_id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

                /**
                 * GetInfoResp s_parameter.
                 * @member {Uint8Array} s_parameter
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @instance
                 */
                GetInfoResp.prototype.s_parameter = $util.newBuffer([]);

                /**
                 * Creates a new GetInfoResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.GetInfoResp} GetInfoResp instance
                 */
                GetInfoResp.create = function create(properties) {
                    return new GetInfoResp(properties);
                };

                /**
                 * Encodes the specified GetInfoResp message. Does not implicitly {@link qihoo.protocol.messages.GetInfoResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoResp} message GetInfoResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInfoResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.info_type);
                    if(message.infos != null && message.infos.length)
                        for(let i = 0; i < message.infos.length; ++i)
                            $root.qihoo.protocol.messages.Info.encode(message.infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.last_info_id);
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s_parameter);
                    return writer;
                };

                /**
                 * Encodes the specified GetInfoResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.GetInfoResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetInfoResp} message GetInfoResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetInfoResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetInfoResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.GetInfoResp} GetInfoResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInfoResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.GetInfoResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.info_type = reader.string();
                                break;
                            case 2:
                                if(!(message.infos && message.infos.length))
                                    message.infos = [];
                                message.infos.push($root.qihoo.protocol.messages.Info.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.last_info_id = reader.int64();
                                break;
                            case 4:
                                message.s_parameter = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("info_type"))
                        throw $util.ProtocolError("missing required 'info_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a GetInfoResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.GetInfoResp} GetInfoResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetInfoResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetInfoResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetInfoResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.info_type))
                        return "info_type: string expected";
                    if(message.infos != null && message.hasOwnProperty("infos")) {
                        if(!Array.isArray(message.infos))
                            return "infos: array expected";
                        for(let i = 0; i < message.infos.length; ++i) {
                            let error = $root.qihoo.protocol.messages.Info.verify(message.infos[i]);
                            if(error)
                                return "infos." + error;
                        }
                    }
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        if(!$util.isInteger(message.last_info_id) && !(message.last_info_id && $util.isInteger(message.last_info_id.low) && $util.isInteger(message.last_info_id.high)))
                            return "last_info_id: integer|Long expected";
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        if(!(message.s_parameter && typeof message.s_parameter.length === "number" || $util.isString(message.s_parameter)))
                            return "s_parameter: buffer expected";
                    return null;
                };

                /**
                 * Creates a GetInfoResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.GetInfoResp} GetInfoResp
                 */
                GetInfoResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.GetInfoResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.GetInfoResp();
                    if(object.info_type != null)
                        message.info_type = String(object.info_type);
                    if(object.infos) {
                        if(!Array.isArray(object.infos))
                            throw TypeError(".qihoo.protocol.messages.GetInfoResp.infos: array expected");
                        message.infos = [];
                        for(let i = 0; i < object.infos.length; ++i) {
                            if(typeof object.infos[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.GetInfoResp.infos: object expected");
                            message.infos[i] = $root.qihoo.protocol.messages.Info.fromObject(object.infos[i]);
                        }
                    }
                    if(object.last_info_id != null)
                        if($util.Long)
                            (message.last_info_id = $util.Long.fromValue(object.last_info_id)).unsigned = false;
                        else if(typeof object.last_info_id === "string")
                            message.last_info_id = parseInt(object.last_info_id, 10);
                        else if(typeof object.last_info_id === "number")
                            message.last_info_id = object.last_info_id;
                        else if(typeof object.last_info_id === "object")
                            message.last_info_id = new $util.LongBits(object.last_info_id.low >>> 0, object.last_info_id.high >>> 0).toNumber();
                    if(object.s_parameter != null)
                        if(typeof object.s_parameter === "string")
                            $util.base64.decode(object.s_parameter, message.s_parameter = $util.newBuffer($util.base64.length(object.s_parameter)), 0);
                        else if(object.s_parameter.length)
                            message.s_parameter = object.s_parameter;
                    return message;
                };

                /**
                 * Creates a plain object from a GetInfoResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @static
                 * @param {qihoo.protocol.messages.GetInfoResp} message GetInfoResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetInfoResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.infos = [];
                    if(options.defaults) {
                        object.info_type = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.last_info_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.last_info_id = options.longs === String ? "0" : 0;
                        if(options.bytes === String)
                            object.s_parameter = "";
                        else {
                            object.s_parameter = [];
                            if(options.bytes !== Array)
                                object.s_parameter = $util.newBuffer(object.s_parameter);
                        }
                    }
                    if(message.info_type != null && message.hasOwnProperty("info_type"))
                        object.info_type = message.info_type;
                    if(message.infos && message.infos.length) {
                        object.infos = [];
                        for(let j = 0; j < message.infos.length; ++j)
                            object.infos[j] = $root.qihoo.protocol.messages.Info.toObject(message.infos[j], options);
                    }
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        if(typeof message.last_info_id === "number")
                            object.last_info_id = options.longs === String ? String(message.last_info_id) : message.last_info_id;
                        else
                            object.last_info_id = options.longs === String ? $util.Long.prototype.toString.call(message.last_info_id) : options.longs === Number ? new $util.LongBits(message.last_info_id.low >>> 0, message.last_info_id.high >>> 0).toNumber() : message.last_info_id;
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        object.s_parameter = options.bytes === String ? $util.base64.encode(message.s_parameter, 0, message.s_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.s_parameter) : message.s_parameter;
                    return object;
                };

                /**
                 * Converts this GetInfoResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.GetInfoResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetInfoResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetInfoResp;
            })();

            messages.GetMultiInfosReq = (function () {

                /**
                 * Properties of a GetMultiInfosReq.
                 * @memberof qihoo.protocol.messages
                 * @interface IGetMultiInfosReq
                 * @property {string} info_type GetMultiInfosReq info_type
                 * @property {Array.<number|Long>|null} [get_info_ids] GetMultiInfosReq get_info_ids
                 * @property {Uint8Array|null} [s_parameter] GetMultiInfosReq s_parameter
                 */

                /**
                 * Constructs a new GetMultiInfosReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a GetMultiInfosReq.
                 * @implements IGetMultiInfosReq
                 * @constructor
                 * @param {qihoo.protocol.messages.IGetMultiInfosReq=} [properties] Properties to set
                 */
                function GetMultiInfosReq(properties) {
                    this.get_info_ids = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetMultiInfosReq info_type.
                 * @member {string} info_type
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @instance
                 */
                GetMultiInfosReq.prototype.info_type = "";

                /**
                 * GetMultiInfosReq get_info_ids.
                 * @member {Array.<number|Long>} get_info_ids
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @instance
                 */
                GetMultiInfosReq.prototype.get_info_ids = $util.emptyArray;

                /**
                 * GetMultiInfosReq s_parameter.
                 * @member {Uint8Array} s_parameter
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @instance
                 */
                GetMultiInfosReq.prototype.s_parameter = $util.newBuffer([]);

                /**
                 * Creates a new GetMultiInfosReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.GetMultiInfosReq} GetMultiInfosReq instance
                 */
                GetMultiInfosReq.create = function create(properties) {
                    return new GetMultiInfosReq(properties);
                };

                /**
                 * Encodes the specified GetMultiInfosReq message. Does not implicitly {@link qihoo.protocol.messages.GetMultiInfosReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosReq} message GetMultiInfosReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetMultiInfosReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.info_type);
                    if(message.get_info_ids != null && message.get_info_ids.length)
                        for(let i = 0; i < message.get_info_ids.length; ++i)
                            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.get_info_ids[i]);
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.s_parameter);
                    return writer;
                };

                /**
                 * Encodes the specified GetMultiInfosReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.GetMultiInfosReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosReq} message GetMultiInfosReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetMultiInfosReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetMultiInfosReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.GetMultiInfosReq} GetMultiInfosReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetMultiInfosReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.GetMultiInfosReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.info_type = reader.string();
                                break;
                            case 2:
                                if(!(message.get_info_ids && message.get_info_ids.length))
                                    message.get_info_ids = [];
                                if((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while(reader.pos < end2)
                                        message.get_info_ids.push(reader.int64());
                                } else
                                    message.get_info_ids.push(reader.int64());
                                break;
                            case 3:
                                message.s_parameter = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("info_type"))
                        throw $util.ProtocolError("missing required 'info_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a GetMultiInfosReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.GetMultiInfosReq} GetMultiInfosReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetMultiInfosReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetMultiInfosReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetMultiInfosReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.info_type))
                        return "info_type: string expected";
                    if(message.get_info_ids != null && message.hasOwnProperty("get_info_ids")) {
                        if(!Array.isArray(message.get_info_ids))
                            return "get_info_ids: array expected";
                        for(let i = 0; i < message.get_info_ids.length; ++i)
                            if(!$util.isInteger(message.get_info_ids[i]) && !(message.get_info_ids[i] && $util.isInteger(message.get_info_ids[i].low) && $util.isInteger(message.get_info_ids[i].high)))
                                return "get_info_ids: integer|Long[] expected";
                    }
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        if(!(message.s_parameter && typeof message.s_parameter.length === "number" || $util.isString(message.s_parameter)))
                            return "s_parameter: buffer expected";
                    return null;
                };

                /**
                 * Creates a GetMultiInfosReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.GetMultiInfosReq} GetMultiInfosReq
                 */
                GetMultiInfosReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.GetMultiInfosReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.GetMultiInfosReq();
                    if(object.info_type != null)
                        message.info_type = String(object.info_type);
                    if(object.get_info_ids) {
                        if(!Array.isArray(object.get_info_ids))
                            throw TypeError(".qihoo.protocol.messages.GetMultiInfosReq.get_info_ids: array expected");
                        message.get_info_ids = [];
                        for(let i = 0; i < object.get_info_ids.length; ++i)
                            if($util.Long)
                                (message.get_info_ids[i] = $util.Long.fromValue(object.get_info_ids[i])).unsigned = false;
                            else if(typeof object.get_info_ids[i] === "string")
                                message.get_info_ids[i] = parseInt(object.get_info_ids[i], 10);
                            else if(typeof object.get_info_ids[i] === "number")
                                message.get_info_ids[i] = object.get_info_ids[i];
                            else if(typeof object.get_info_ids[i] === "object")
                                message.get_info_ids[i] = new $util.LongBits(object.get_info_ids[i].low >>> 0, object.get_info_ids[i].high >>> 0).toNumber();
                    }
                    if(object.s_parameter != null)
                        if(typeof object.s_parameter === "string")
                            $util.base64.decode(object.s_parameter, message.s_parameter = $util.newBuffer($util.base64.length(object.s_parameter)), 0);
                        else if(object.s_parameter.length)
                            message.s_parameter = object.s_parameter;
                    return message;
                };

                /**
                 * Creates a plain object from a GetMultiInfosReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @static
                 * @param {qihoo.protocol.messages.GetMultiInfosReq} message GetMultiInfosReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetMultiInfosReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.get_info_ids = [];
                    if(options.defaults) {
                        object.info_type = "";
                        if(options.bytes === String)
                            object.s_parameter = "";
                        else {
                            object.s_parameter = [];
                            if(options.bytes !== Array)
                                object.s_parameter = $util.newBuffer(object.s_parameter);
                        }
                    }
                    if(message.info_type != null && message.hasOwnProperty("info_type"))
                        object.info_type = message.info_type;
                    if(message.get_info_ids && message.get_info_ids.length) {
                        object.get_info_ids = [];
                        for(let j = 0; j < message.get_info_ids.length; ++j)
                            if(typeof message.get_info_ids[j] === "number")
                                object.get_info_ids[j] = options.longs === String ? String(message.get_info_ids[j]) : message.get_info_ids[j];
                            else
                                object.get_info_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.get_info_ids[j]) : options.longs === Number ? new $util.LongBits(message.get_info_ids[j].low >>> 0, message.get_info_ids[j].high >>> 0).toNumber() : message.get_info_ids[j];
                    }
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        object.s_parameter = options.bytes === String ? $util.base64.encode(message.s_parameter, 0, message.s_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.s_parameter) : message.s_parameter;
                    return object;
                };

                /**
                 * Converts this GetMultiInfosReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.GetMultiInfosReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetMultiInfosReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetMultiInfosReq;
            })();

            messages.GetMultiInfosResp = (function () {

                /**
                 * Properties of a GetMultiInfosResp.
                 * @memberof qihoo.protocol.messages
                 * @interface IGetMultiInfosResp
                 * @property {string} info_type GetMultiInfosResp info_type
                 * @property {Array.<qihoo.protocol.messages.IInfo>|null} [infos] GetMultiInfosResp infos
                 * @property {number|Long|null} [last_info_id] GetMultiInfosResp last_info_id
                 * @property {Uint8Array|null} [s_parameter] GetMultiInfosResp s_parameter
                 */

                /**
                 * Constructs a new GetMultiInfosResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a GetMultiInfosResp.
                 * @implements IGetMultiInfosResp
                 * @constructor
                 * @param {qihoo.protocol.messages.IGetMultiInfosResp=} [properties] Properties to set
                 */
                function GetMultiInfosResp(properties) {
                    this.infos = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetMultiInfosResp info_type.
                 * @member {string} info_type
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @instance
                 */
                GetMultiInfosResp.prototype.info_type = "";

                /**
                 * GetMultiInfosResp infos.
                 * @member {Array.<qihoo.protocol.messages.IInfo>} infos
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @instance
                 */
                GetMultiInfosResp.prototype.infos = $util.emptyArray;

                /**
                 * GetMultiInfosResp last_info_id.
                 * @member {number|Long} last_info_id
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @instance
                 */
                GetMultiInfosResp.prototype.last_info_id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

                /**
                 * GetMultiInfosResp s_parameter.
                 * @member {Uint8Array} s_parameter
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @instance
                 */
                GetMultiInfosResp.prototype.s_parameter = $util.newBuffer([]);

                /**
                 * Creates a new GetMultiInfosResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.GetMultiInfosResp} GetMultiInfosResp instance
                 */
                GetMultiInfosResp.create = function create(properties) {
                    return new GetMultiInfosResp(properties);
                };

                /**
                 * Encodes the specified GetMultiInfosResp message. Does not implicitly {@link qihoo.protocol.messages.GetMultiInfosResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosResp} message GetMultiInfosResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetMultiInfosResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.info_type);
                    if(message.infos != null && message.infos.length)
                        for(let i = 0; i < message.infos.length; ++i)
                            $root.qihoo.protocol.messages.Info.encode(message.infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.last_info_id);
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s_parameter);
                    return writer;
                };

                /**
                 * Encodes the specified GetMultiInfosResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.GetMultiInfosResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {qihoo.protocol.messages.IGetMultiInfosResp} message GetMultiInfosResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetMultiInfosResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetMultiInfosResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.GetMultiInfosResp} GetMultiInfosResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetMultiInfosResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.GetMultiInfosResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.info_type = reader.string();
                                break;
                            case 2:
                                if(!(message.infos && message.infos.length))
                                    message.infos = [];
                                message.infos.push($root.qihoo.protocol.messages.Info.decode(reader, reader.uint32()));
                                break;
                            case 3:
                                message.last_info_id = reader.int64();
                                break;
                            case 4:
                                message.s_parameter = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("info_type"))
                        throw $util.ProtocolError("missing required 'info_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a GetMultiInfosResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.GetMultiInfosResp} GetMultiInfosResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetMultiInfosResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetMultiInfosResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetMultiInfosResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.info_type))
                        return "info_type: string expected";
                    if(message.infos != null && message.hasOwnProperty("infos")) {
                        if(!Array.isArray(message.infos))
                            return "infos: array expected";
                        for(let i = 0; i < message.infos.length; ++i) {
                            let error = $root.qihoo.protocol.messages.Info.verify(message.infos[i]);
                            if(error)
                                return "infos." + error;
                        }
                    }
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        if(!$util.isInteger(message.last_info_id) && !(message.last_info_id && $util.isInteger(message.last_info_id.low) && $util.isInteger(message.last_info_id.high)))
                            return "last_info_id: integer|Long expected";
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        if(!(message.s_parameter && typeof message.s_parameter.length === "number" || $util.isString(message.s_parameter)))
                            return "s_parameter: buffer expected";
                    return null;
                };

                /**
                 * Creates a GetMultiInfosResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.GetMultiInfosResp} GetMultiInfosResp
                 */
                GetMultiInfosResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.GetMultiInfosResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.GetMultiInfosResp();
                    if(object.info_type != null)
                        message.info_type = String(object.info_type);
                    if(object.infos) {
                        if(!Array.isArray(object.infos))
                            throw TypeError(".qihoo.protocol.messages.GetMultiInfosResp.infos: array expected");
                        message.infos = [];
                        for(let i = 0; i < object.infos.length; ++i) {
                            if(typeof object.infos[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.GetMultiInfosResp.infos: object expected");
                            message.infos[i] = $root.qihoo.protocol.messages.Info.fromObject(object.infos[i]);
                        }
                    }
                    if(object.last_info_id != null)
                        if($util.Long)
                            (message.last_info_id = $util.Long.fromValue(object.last_info_id)).unsigned = false;
                        else if(typeof object.last_info_id === "string")
                            message.last_info_id = parseInt(object.last_info_id, 10);
                        else if(typeof object.last_info_id === "number")
                            message.last_info_id = object.last_info_id;
                        else if(typeof object.last_info_id === "object")
                            message.last_info_id = new $util.LongBits(object.last_info_id.low >>> 0, object.last_info_id.high >>> 0).toNumber();
                    if(object.s_parameter != null)
                        if(typeof object.s_parameter === "string")
                            $util.base64.decode(object.s_parameter, message.s_parameter = $util.newBuffer($util.base64.length(object.s_parameter)), 0);
                        else if(object.s_parameter.length)
                            message.s_parameter = object.s_parameter;
                    return message;
                };

                /**
                 * Creates a plain object from a GetMultiInfosResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @static
                 * @param {qihoo.protocol.messages.GetMultiInfosResp} message GetMultiInfosResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetMultiInfosResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.infos = [];
                    if(options.defaults) {
                        object.info_type = "";
                        if($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.last_info_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.last_info_id = options.longs === String ? "0" : 0;
                        if(options.bytes === String)
                            object.s_parameter = "";
                        else {
                            object.s_parameter = [];
                            if(options.bytes !== Array)
                                object.s_parameter = $util.newBuffer(object.s_parameter);
                        }
                    }
                    if(message.info_type != null && message.hasOwnProperty("info_type"))
                        object.info_type = message.info_type;
                    if(message.infos && message.infos.length) {
                        object.infos = [];
                        for(let j = 0; j < message.infos.length; ++j)
                            object.infos[j] = $root.qihoo.protocol.messages.Info.toObject(message.infos[j], options);
                    }
                    if(message.last_info_id != null && message.hasOwnProperty("last_info_id"))
                        if(typeof message.last_info_id === "number")
                            object.last_info_id = options.longs === String ? String(message.last_info_id) : message.last_info_id;
                        else
                            object.last_info_id = options.longs === String ? $util.Long.prototype.toString.call(message.last_info_id) : options.longs === Number ? new $util.LongBits(message.last_info_id.low >>> 0, message.last_info_id.high >>> 0).toNumber() : message.last_info_id;
                    if(message.s_parameter != null && message.hasOwnProperty("s_parameter"))
                        object.s_parameter = options.bytes === String ? $util.base64.encode(message.s_parameter, 0, message.s_parameter.length) : options.bytes === Array ? Array.prototype.slice.call(message.s_parameter) : message.s_parameter;
                    return object;
                };

                /**
                 * Converts this GetMultiInfosResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.GetMultiInfosResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetMultiInfosResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetMultiInfosResp;
            })();

            messages.LogoutReq = (function () {

                /**
                 * Properties of a LogoutReq.
                 * @memberof qihoo.protocol.messages
                 * @interface ILogoutReq
                 * @property {string|null} [reason] LogoutReq reason
                 */

                /**
                 * Constructs a new LogoutReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a LogoutReq.
                 * @implements ILogoutReq
                 * @constructor
                 * @param {qihoo.protocol.messages.ILogoutReq=} [properties] Properties to set
                 */
                function LogoutReq(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogoutReq reason.
                 * @member {string} reason
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @instance
                 */
                LogoutReq.prototype.reason = "";

                /**
                 * Creates a new LogoutReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.LogoutReq} LogoutReq instance
                 */
                LogoutReq.create = function create(properties) {
                    return new LogoutReq(properties);
                };

                /**
                 * Encodes the specified LogoutReq message. Does not implicitly {@link qihoo.protocol.messages.LogoutReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutReq} message LogoutReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogoutReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
                    return writer;
                };

                /**
                 * Encodes the specified LogoutReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.LogoutReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutReq} message LogoutReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogoutReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogoutReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.LogoutReq} LogoutReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogoutReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.LogoutReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.reason = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogoutReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.LogoutReq} LogoutReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogoutReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogoutReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LogoutReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        if(!$util.isString(message.reason))
                            return "reason: string expected";
                    return null;
                };

                /**
                 * Creates a LogoutReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.LogoutReq} LogoutReq
                 */
                LogoutReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.LogoutReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.LogoutReq();
                    if(object.reason != null)
                        message.reason = String(object.reason);
                    return message;
                };

                /**
                 * Creates a plain object from a LogoutReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @static
                 * @param {qihoo.protocol.messages.LogoutReq} message LogoutReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogoutReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.reason = "";
                    if(message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    return object;
                };

                /**
                 * Converts this LogoutReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.LogoutReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LogoutReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogoutReq;
            })();

            messages.LogoutResp = (function () {

                /**
                 * Properties of a LogoutResp.
                 * @memberof qihoo.protocol.messages
                 * @interface ILogoutResp
                 * @property {number} result LogoutResp result
                 */

                /**
                 * Constructs a new LogoutResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a LogoutResp.
                 * @implements ILogoutResp
                 * @constructor
                 * @param {qihoo.protocol.messages.ILogoutResp=} [properties] Properties to set
                 */
                function LogoutResp(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogoutResp result.
                 * @member {number} result
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @instance
                 */
                LogoutResp.prototype.result = 0;

                /**
                 * Creates a new LogoutResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.LogoutResp} LogoutResp instance
                 */
                LogoutResp.create = function create(properties) {
                    return new LogoutResp(properties);
                };

                /**
                 * Encodes the specified LogoutResp message. Does not implicitly {@link qihoo.protocol.messages.LogoutResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutResp} message LogoutResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogoutResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.result);
                    return writer;
                };

                /**
                 * Encodes the specified LogoutResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.LogoutResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {qihoo.protocol.messages.ILogoutResp} message LogoutResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogoutResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogoutResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.LogoutResp} LogoutResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogoutResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.LogoutResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.result = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("result"))
                        throw $util.ProtocolError("missing required 'result'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a LogoutResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.LogoutResp} LogoutResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogoutResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogoutResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LogoutResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.result))
                        return "result: integer expected";
                    return null;
                };

                /**
                 * Creates a LogoutResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.LogoutResp} LogoutResp
                 */
                LogoutResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.LogoutResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.LogoutResp();
                    if(object.result != null)
                        message.result = object.result >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a LogoutResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @static
                 * @param {qihoo.protocol.messages.LogoutResp} message LogoutResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogoutResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.result = 0;
                    if(message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    return object;
                };

                /**
                 * Converts this LogoutResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.LogoutResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LogoutResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogoutResp;
            })();

            messages.InitLoginReq = (function () {

                /**
                 * Properties of an InitLoginReq.
                 * @memberof qihoo.protocol.messages
                 * @interface IInitLoginReq
                 * @property {string} client_ram InitLoginReq client_ram
                 * @property {string|null} [sig] InitLoginReq sig
                 */

                /**
                 * Constructs a new InitLoginReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an InitLoginReq.
                 * @implements IInitLoginReq
                 * @constructor
                 * @param {qihoo.protocol.messages.IInitLoginReq=} [properties] Properties to set
                 */
                function InitLoginReq(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InitLoginReq client_ram.
                 * @member {string} client_ram
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @instance
                 */
                InitLoginReq.prototype.client_ram = "";

                /**
                 * InitLoginReq sig.
                 * @member {string} sig
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @instance
                 */
                InitLoginReq.prototype.sig = "";

                /**
                 * Creates a new InitLoginReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.InitLoginReq} InitLoginReq instance
                 */
                InitLoginReq.create = function create(properties) {
                    return new InitLoginReq(properties);
                };

                /**
                 * Encodes the specified InitLoginReq message. Does not implicitly {@link qihoo.protocol.messages.InitLoginReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginReq} message InitLoginReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InitLoginReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.client_ram);
                    if(message.sig != null && message.hasOwnProperty("sig"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sig);
                    return writer;
                };

                /**
                 * Encodes the specified InitLoginReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.InitLoginReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginReq} message InitLoginReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InitLoginReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InitLoginReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.InitLoginReq} InitLoginReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InitLoginReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.InitLoginReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.client_ram = reader.string();
                                break;
                            case 2:
                                message.sig = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("client_ram"))
                        throw $util.ProtocolError("missing required 'client_ram'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an InitLoginReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.InitLoginReq} InitLoginReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InitLoginReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InitLoginReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InitLoginReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.client_ram))
                        return "client_ram: string expected";
                    if(message.sig != null && message.hasOwnProperty("sig"))
                        if(!$util.isString(message.sig))
                            return "sig: string expected";
                    return null;
                };

                /**
                 * Creates an InitLoginReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.InitLoginReq} InitLoginReq
                 */
                InitLoginReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.InitLoginReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.InitLoginReq();
                    if(object.client_ram != null)
                        message.client_ram = String(object.client_ram);
                    if(object.sig != null)
                        message.sig = String(object.sig);
                    return message;
                };

                /**
                 * Creates a plain object from an InitLoginReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @static
                 * @param {qihoo.protocol.messages.InitLoginReq} message InitLoginReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InitLoginReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.client_ram = "";
                        object.sig = "";
                    }
                    if(message.client_ram != null && message.hasOwnProperty("client_ram"))
                        object.client_ram = message.client_ram;
                    if(message.sig != null && message.hasOwnProperty("sig"))
                        object.sig = message.sig;
                    return object;
                };

                /**
                 * Converts this InitLoginReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.InitLoginReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InitLoginReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InitLoginReq;
            })();

            messages.InitLoginResp = (function () {

                /**
                 * Properties of an InitLoginResp.
                 * @memberof qihoo.protocol.messages
                 * @interface IInitLoginResp
                 * @property {string} client_ram InitLoginResp client_ram
                 * @property {string} server_ram InitLoginResp server_ram
                 */

                /**
                 * Constructs a new InitLoginResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an InitLoginResp.
                 * @implements IInitLoginResp
                 * @constructor
                 * @param {qihoo.protocol.messages.IInitLoginResp=} [properties] Properties to set
                 */
                function InitLoginResp(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InitLoginResp client_ram.
                 * @member {string} client_ram
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @instance
                 */
                InitLoginResp.prototype.client_ram = "";

                /**
                 * InitLoginResp server_ram.
                 * @member {string} server_ram
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @instance
                 */
                InitLoginResp.prototype.server_ram = "";

                /**
                 * Creates a new InitLoginResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.InitLoginResp} InitLoginResp instance
                 */
                InitLoginResp.create = function create(properties) {
                    return new InitLoginResp(properties);
                };

                /**
                 * Encodes the specified InitLoginResp message. Does not implicitly {@link qihoo.protocol.messages.InitLoginResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginResp} message InitLoginResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InitLoginResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.client_ram);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.server_ram);
                    return writer;
                };

                /**
                 * Encodes the specified InitLoginResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.InitLoginResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {qihoo.protocol.messages.IInitLoginResp} message InitLoginResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InitLoginResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InitLoginResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.InitLoginResp} InitLoginResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InitLoginResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.InitLoginResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.client_ram = reader.string();
                                break;
                            case 2:
                                message.server_ram = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("client_ram"))
                        throw $util.ProtocolError("missing required 'client_ram'", { instance: message });
                    if(!message.hasOwnProperty("server_ram"))
                        throw $util.ProtocolError("missing required 'server_ram'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an InitLoginResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.InitLoginResp} InitLoginResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InitLoginResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InitLoginResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InitLoginResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.client_ram))
                        return "client_ram: string expected";
                    if(!$util.isString(message.server_ram))
                        return "server_ram: string expected";
                    return null;
                };

                /**
                 * Creates an InitLoginResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.InitLoginResp} InitLoginResp
                 */
                InitLoginResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.InitLoginResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.InitLoginResp();
                    if(object.client_ram != null)
                        message.client_ram = String(object.client_ram);
                    if(object.server_ram != null)
                        message.server_ram = String(object.server_ram);
                    return message;
                };

                /**
                 * Creates a plain object from an InitLoginResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @static
                 * @param {qihoo.protocol.messages.InitLoginResp} message InitLoginResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InitLoginResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.client_ram = "";
                        object.server_ram = "";
                    }
                    if(message.client_ram != null && message.hasOwnProperty("client_ram"))
                        object.client_ram = message.client_ram;
                    if(message.server_ram != null && message.hasOwnProperty("server_ram"))
                        object.server_ram = message.server_ram;
                    return object;
                };

                /**
                 * Converts this InitLoginResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.InitLoginResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InitLoginResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InitLoginResp;
            })();

            messages.Service_Req = (function () {

                /**
                 * Properties of a Service_Req.
                 * @memberof qihoo.protocol.messages
                 * @interface IService_Req
                 * @property {number} service_id Service_Req service_id
                 * @property {Uint8Array} request Service_Req request
                 */

                /**
                 * Constructs a new Service_Req.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Service_Req.
                 * @implements IService_Req
                 * @constructor
                 * @param {qihoo.protocol.messages.IService_Req=} [properties] Properties to set
                 */
                function Service_Req(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Service_Req service_id.
                 * @member {number} service_id
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @instance
                 */
                Service_Req.prototype.service_id = 0;

                /**
                 * Service_Req request.
                 * @member {Uint8Array} request
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @instance
                 */
                Service_Req.prototype.request = $util.newBuffer([]);

                /**
                 * Creates a new Service_Req instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {qihoo.protocol.messages.IService_Req=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Service_Req} Service_Req instance
                 */
                Service_Req.create = function create(properties) {
                    return new Service_Req(properties);
                };

                /**
                 * Encodes the specified Service_Req message. Does not implicitly {@link qihoo.protocol.messages.Service_Req.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {qihoo.protocol.messages.IService_Req} message Service_Req message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Service_Req.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.service_id);
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.request);
                    return writer;
                };

                /**
                 * Encodes the specified Service_Req message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Service_Req.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {qihoo.protocol.messages.IService_Req} message Service_Req message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Service_Req.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Service_Req message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Service_Req} Service_Req
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Service_Req.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Service_Req();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.service_id = reader.uint32();
                                break;
                            case 2:
                                message.request = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("service_id"))
                        throw $util.ProtocolError("missing required 'service_id'", { instance: message });
                    if(!message.hasOwnProperty("request"))
                        throw $util.ProtocolError("missing required 'request'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Service_Req message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Service_Req} Service_Req
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Service_Req.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Service_Req message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Service_Req.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.service_id))
                        return "service_id: integer expected";
                    if(!(message.request && typeof message.request.length === "number" || $util.isString(message.request)))
                        return "request: buffer expected";
                    return null;
                };

                /**
                 * Creates a Service_Req message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Service_Req} Service_Req
                 */
                Service_Req.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Service_Req)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Service_Req();
                    if(object.service_id != null)
                        message.service_id = object.service_id >>> 0;
                    if(object.request != null)
                        if(typeof object.request === "string")
                            $util.base64.decode(object.request, message.request = $util.newBuffer($util.base64.length(object.request)), 0);
                        else if(object.request.length)
                            message.request = object.request;
                    return message;
                };

                /**
                 * Creates a plain object from a Service_Req message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @static
                 * @param {qihoo.protocol.messages.Service_Req} message Service_Req
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Service_Req.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.service_id = 0;
                        if(options.bytes === String)
                            object.request = "";
                        else {
                            object.request = [];
                            if(options.bytes !== Array)
                                object.request = $util.newBuffer(object.request);
                        }
                    }
                    if(message.service_id != null && message.hasOwnProperty("service_id"))
                        object.service_id = message.service_id;
                    if(message.request != null && message.hasOwnProperty("request"))
                        object.request = options.bytes === String ? $util.base64.encode(message.request, 0, message.request.length) : options.bytes === Array ? Array.prototype.slice.call(message.request) : message.request;
                    return object;
                };

                /**
                 * Converts this Service_Req to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Service_Req
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Service_Req.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Service_Req;
            })();

            messages.Service_Resp = (function () {

                /**
                 * Properties of a Service_Resp.
                 * @memberof qihoo.protocol.messages
                 * @interface IService_Resp
                 * @property {number} service_id Service_Resp service_id
                 * @property {Uint8Array} response Service_Resp response
                 */

                /**
                 * Constructs a new Service_Resp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Service_Resp.
                 * @implements IService_Resp
                 * @constructor
                 * @param {qihoo.protocol.messages.IService_Resp=} [properties] Properties to set
                 */
                function Service_Resp(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Service_Resp service_id.
                 * @member {number} service_id
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @instance
                 */
                Service_Resp.prototype.service_id = 0;

                /**
                 * Service_Resp response.
                 * @member {Uint8Array} response
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @instance
                 */
                Service_Resp.prototype.response = $util.newBuffer([]);

                /**
                 * Creates a new Service_Resp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {qihoo.protocol.messages.IService_Resp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Service_Resp} Service_Resp instance
                 */
                Service_Resp.create = function create(properties) {
                    return new Service_Resp(properties);
                };

                /**
                 * Encodes the specified Service_Resp message. Does not implicitly {@link qihoo.protocol.messages.Service_Resp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {qihoo.protocol.messages.IService_Resp} message Service_Resp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Service_Resp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.service_id);
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.response);
                    return writer;
                };

                /**
                 * Encodes the specified Service_Resp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Service_Resp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {qihoo.protocol.messages.IService_Resp} message Service_Resp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Service_Resp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Service_Resp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Service_Resp} Service_Resp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Service_Resp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Service_Resp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.service_id = reader.uint32();
                                break;
                            case 2:
                                message.response = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("service_id"))
                        throw $util.ProtocolError("missing required 'service_id'", { instance: message });
                    if(!message.hasOwnProperty("response"))
                        throw $util.ProtocolError("missing required 'response'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Service_Resp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Service_Resp} Service_Resp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Service_Resp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Service_Resp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Service_Resp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.service_id))
                        return "service_id: integer expected";
                    if(!(message.response && typeof message.response.length === "number" || $util.isString(message.response)))
                        return "response: buffer expected";
                    return null;
                };

                /**
                 * Creates a Service_Resp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Service_Resp} Service_Resp
                 */
                Service_Resp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Service_Resp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Service_Resp();
                    if(object.service_id != null)
                        message.service_id = object.service_id >>> 0;
                    if(object.response != null)
                        if(typeof object.response === "string")
                            $util.base64.decode(object.response, message.response = $util.newBuffer($util.base64.length(object.response)), 0);
                        else if(object.response.length)
                            message.response = object.response;
                    return message;
                };

                /**
                 * Creates a plain object from a Service_Resp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @static
                 * @param {qihoo.protocol.messages.Service_Resp} message Service_Resp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Service_Resp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.service_id = 0;
                        if(options.bytes === String)
                            object.response = "";
                        else {
                            object.response = [];
                            if(options.bytes !== Array)
                                object.response = $util.newBuffer(object.response);
                        }
                    }
                    if(message.service_id != null && message.hasOwnProperty("service_id"))
                        object.service_id = message.service_id;
                    if(message.response != null && message.hasOwnProperty("response"))
                        object.response = options.bytes === String ? $util.base64.encode(message.response, 0, message.response.length) : options.bytes === Array ? Array.prototype.slice.call(message.response) : message.response;
                    return object;
                };

                /**
                 * Converts this Service_Resp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Service_Resp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Service_Resp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Service_Resp;
            })();

            messages.ReqEQ1User = (function () {

                /**
                 * Properties of a ReqEQ1User.
                 * @memberof qihoo.protocol.messages
                 * @interface IReqEQ1User
                 * @property {string} userid ReqEQ1User userid
                 * @property {string} user_type ReqEQ1User user_type
                 * @property {number|null} [app_id] ReqEQ1User app_id
                 */

                /**
                 * Constructs a new ReqEQ1User.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a ReqEQ1User.
                 * @implements IReqEQ1User
                 * @constructor
                 * @param {qihoo.protocol.messages.IReqEQ1User=} [properties] Properties to set
                 */
                function ReqEQ1User(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReqEQ1User userid.
                 * @member {string} userid
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @instance
                 */
                ReqEQ1User.prototype.userid = "";

                /**
                 * ReqEQ1User user_type.
                 * @member {string} user_type
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @instance
                 */
                ReqEQ1User.prototype.user_type = "";

                /**
                 * ReqEQ1User app_id.
                 * @member {number} app_id
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @instance
                 */
                ReqEQ1User.prototype.app_id = 0;

                /**
                 * Creates a new ReqEQ1User instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IReqEQ1User=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.ReqEQ1User} ReqEQ1User instance
                 */
                ReqEQ1User.create = function create(properties) {
                    return new ReqEQ1User(properties);
                };

                /**
                 * Encodes the specified ReqEQ1User message. Does not implicitly {@link qihoo.protocol.messages.ReqEQ1User.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IReqEQ1User} message ReqEQ1User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReqEQ1User.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userid);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.user_type);
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.app_id);
                    return writer;
                };

                /**
                 * Encodes the specified ReqEQ1User message, length delimited. Does not implicitly {@link qihoo.protocol.messages.ReqEQ1User.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IReqEQ1User} message ReqEQ1User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReqEQ1User.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReqEQ1User message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.ReqEQ1User} ReqEQ1User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReqEQ1User.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.ReqEQ1User();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.userid = reader.string();
                                break;
                            case 2:
                                message.user_type = reader.string();
                                break;
                            case 3:
                                message.app_id = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("userid"))
                        throw $util.ProtocolError("missing required 'userid'", { instance: message });
                    if(!message.hasOwnProperty("user_type"))
                        throw $util.ProtocolError("missing required 'user_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a ReqEQ1User message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.ReqEQ1User} ReqEQ1User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReqEQ1User.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReqEQ1User message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReqEQ1User.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.userid))
                        return "userid: string expected";
                    if(!$util.isString(message.user_type))
                        return "user_type: string expected";
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        if(!$util.isInteger(message.app_id))
                            return "app_id: integer expected";
                    return null;
                };

                /**
                 * Creates a ReqEQ1User message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.ReqEQ1User} ReqEQ1User
                 */
                ReqEQ1User.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.ReqEQ1User)
                        return object;
                    let message = new $root.qihoo.protocol.messages.ReqEQ1User();
                    if(object.userid != null)
                        message.userid = String(object.userid);
                    if(object.user_type != null)
                        message.user_type = String(object.user_type);
                    if(object.app_id != null)
                        message.app_id = object.app_id >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReqEQ1User message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.ReqEQ1User} message ReqEQ1User
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReqEQ1User.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.userid = "";
                        object.user_type = "";
                        object.app_id = 0;
                    }
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        object.userid = message.userid;
                    if(message.user_type != null && message.hasOwnProperty("user_type"))
                        object.user_type = message.user_type;
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        object.app_id = message.app_id;
                    return object;
                };

                /**
                 * Converts this ReqEQ1User to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.ReqEQ1User
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReqEQ1User.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReqEQ1User;
            })();

            messages.RespEQ1User = (function () {

                /**
                 * Properties of a RespEQ1User.
                 * @memberof qihoo.protocol.messages
                 * @interface IRespEQ1User
                 * @property {string} userid RespEQ1User userid
                 * @property {string} user_type RespEQ1User user_type
                 * @property {number} status RespEQ1User status
                 * @property {string|null} [jid] RespEQ1User jid
                 * @property {number|null} [app_id] RespEQ1User app_id
                 * @property {string|null} [platform] RespEQ1User platform
                 * @property {string|null} [mobile_type] RespEQ1User mobile_type
                 * @property {number|null} [client_ver] RespEQ1User client_ver
                 */

                /**
                 * Constructs a new RespEQ1User.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a RespEQ1User.
                 * @implements IRespEQ1User
                 * @constructor
                 * @param {qihoo.protocol.messages.IRespEQ1User=} [properties] Properties to set
                 */
                function RespEQ1User(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RespEQ1User userid.
                 * @member {string} userid
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.userid = "";

                /**
                 * RespEQ1User user_type.
                 * @member {string} user_type
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.user_type = "";

                /**
                 * RespEQ1User status.
                 * @member {number} status
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.status = 0;

                /**
                 * RespEQ1User jid.
                 * @member {string} jid
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.jid = "";

                /**
                 * RespEQ1User app_id.
                 * @member {number} app_id
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.app_id = 0;

                /**
                 * RespEQ1User platform.
                 * @member {string} platform
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.platform = "";

                /**
                 * RespEQ1User mobile_type.
                 * @member {string} mobile_type
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.mobile_type = "";

                /**
                 * RespEQ1User client_ver.
                 * @member {number} client_ver
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 */
                RespEQ1User.prototype.client_ver = 0;

                /**
                 * Creates a new RespEQ1User instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IRespEQ1User=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.RespEQ1User} RespEQ1User instance
                 */
                RespEQ1User.create = function create(properties) {
                    return new RespEQ1User(properties);
                };

                /**
                 * Encodes the specified RespEQ1User message. Does not implicitly {@link qihoo.protocol.messages.RespEQ1User.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IRespEQ1User} message RespEQ1User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RespEQ1User.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userid);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.user_type);
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                    if(message.jid != null && message.hasOwnProperty("jid"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.jid);
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.app_id);
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.platform);
                    if(message.mobile_type != null && message.hasOwnProperty("mobile_type"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.mobile_type);
                    if(message.client_ver != null && message.hasOwnProperty("client_ver"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.client_ver);
                    return writer;
                };

                /**
                 * Encodes the specified RespEQ1User message, length delimited. Does not implicitly {@link qihoo.protocol.messages.RespEQ1User.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.IRespEQ1User} message RespEQ1User message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RespEQ1User.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RespEQ1User message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.RespEQ1User} RespEQ1User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RespEQ1User.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.RespEQ1User();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.userid = reader.string();
                                break;
                            case 2:
                                message.user_type = reader.string();
                                break;
                            case 3:
                                message.status = reader.int32();
                                break;
                            case 4:
                                message.jid = reader.string();
                                break;
                            case 5:
                                message.app_id = reader.uint32();
                                break;
                            case 6:
                                message.platform = reader.string();
                                break;
                            case 7:
                                message.mobile_type = reader.string();
                                break;
                            case 8:
                                message.client_ver = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("userid"))
                        throw $util.ProtocolError("missing required 'userid'", { instance: message });
                    if(!message.hasOwnProperty("user_type"))
                        throw $util.ProtocolError("missing required 'user_type'", { instance: message });
                    if(!message.hasOwnProperty("status"))
                        throw $util.ProtocolError("missing required 'status'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a RespEQ1User message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.RespEQ1User} RespEQ1User
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RespEQ1User.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RespEQ1User message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RespEQ1User.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.userid))
                        return "userid: string expected";
                    if(!$util.isString(message.user_type))
                        return "user_type: string expected";
                    if(!$util.isInteger(message.status))
                        return "status: integer expected";
                    if(message.jid != null && message.hasOwnProperty("jid"))
                        if(!$util.isString(message.jid))
                            return "jid: string expected";
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        if(!$util.isInteger(message.app_id))
                            return "app_id: integer expected";
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        if(!$util.isString(message.platform))
                            return "platform: string expected";
                    if(message.mobile_type != null && message.hasOwnProperty("mobile_type"))
                        if(!$util.isString(message.mobile_type))
                            return "mobile_type: string expected";
                    if(message.client_ver != null && message.hasOwnProperty("client_ver"))
                        if(!$util.isInteger(message.client_ver))
                            return "client_ver: integer expected";
                    return null;
                };

                /**
                 * Creates a RespEQ1User message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.RespEQ1User} RespEQ1User
                 */
                RespEQ1User.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.RespEQ1User)
                        return object;
                    let message = new $root.qihoo.protocol.messages.RespEQ1User();
                    if(object.userid != null)
                        message.userid = String(object.userid);
                    if(object.user_type != null)
                        message.user_type = String(object.user_type);
                    if(object.status != null)
                        message.status = object.status | 0;
                    if(object.jid != null)
                        message.jid = String(object.jid);
                    if(object.app_id != null)
                        message.app_id = object.app_id >>> 0;
                    if(object.platform != null)
                        message.platform = String(object.platform);
                    if(object.mobile_type != null)
                        message.mobile_type = String(object.mobile_type);
                    if(object.client_ver != null)
                        message.client_ver = object.client_ver >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a RespEQ1User message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @static
                 * @param {qihoo.protocol.messages.RespEQ1User} message RespEQ1User
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RespEQ1User.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.userid = "";
                        object.user_type = "";
                        object.status = 0;
                        object.jid = "";
                        object.app_id = 0;
                        object.platform = "";
                        object.mobile_type = "";
                        object.client_ver = 0;
                    }
                    if(message.userid != null && message.hasOwnProperty("userid"))
                        object.userid = message.userid;
                    if(message.user_type != null && message.hasOwnProperty("user_type"))
                        object.user_type = message.user_type;
                    if(message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    if(message.jid != null && message.hasOwnProperty("jid"))
                        object.jid = message.jid;
                    if(message.app_id != null && message.hasOwnProperty("app_id"))
                        object.app_id = message.app_id;
                    if(message.platform != null && message.hasOwnProperty("platform"))
                        object.platform = message.platform;
                    if(message.mobile_type != null && message.hasOwnProperty("mobile_type"))
                        object.mobile_type = message.mobile_type;
                    if(message.client_ver != null && message.hasOwnProperty("client_ver"))
                        object.client_ver = message.client_ver;
                    return object;
                };

                /**
                 * Converts this RespEQ1User to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.RespEQ1User
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RespEQ1User.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RespEQ1User;
            })();

            messages.Ex1QueryUserStatusReq = (function () {

                /**
                 * Properties of an Ex1QueryUserStatusReq.
                 * @memberof qihoo.protocol.messages
                 * @interface IEx1QueryUserStatusReq
                 * @property {Array.<qihoo.protocol.messages.IReqEQ1User>|null} [user_list] Ex1QueryUserStatusReq user_list
                 */

                /**
                 * Constructs a new Ex1QueryUserStatusReq.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an Ex1QueryUserStatusReq.
                 * @implements IEx1QueryUserStatusReq
                 * @constructor
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusReq=} [properties] Properties to set
                 */
                function Ex1QueryUserStatusReq(properties) {
                    this.user_list = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ex1QueryUserStatusReq user_list.
                 * @member {Array.<qihoo.protocol.messages.IReqEQ1User>} user_list
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @instance
                 */
                Ex1QueryUserStatusReq.prototype.user_list = $util.emptyArray;

                /**
                 * Creates a new Ex1QueryUserStatusReq instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusReq=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusReq} Ex1QueryUserStatusReq instance
                 */
                Ex1QueryUserStatusReq.create = function create(properties) {
                    return new Ex1QueryUserStatusReq(properties);
                };

                /**
                 * Encodes the specified Ex1QueryUserStatusReq message. Does not implicitly {@link qihoo.protocol.messages.Ex1QueryUserStatusReq.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusReq} message Ex1QueryUserStatusReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ex1QueryUserStatusReq.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.user_list != null && message.user_list.length)
                        for(let i = 0; i < message.user_list.length; ++i)
                            $root.qihoo.protocol.messages.ReqEQ1User.encode(message.user_list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Ex1QueryUserStatusReq message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Ex1QueryUserStatusReq.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusReq} message Ex1QueryUserStatusReq message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ex1QueryUserStatusReq.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Ex1QueryUserStatusReq message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusReq} Ex1QueryUserStatusReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ex1QueryUserStatusReq.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Ex1QueryUserStatusReq();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.user_list && message.user_list.length))
                                    message.user_list = [];
                                message.user_list.push($root.qihoo.protocol.messages.ReqEQ1User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Ex1QueryUserStatusReq message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusReq} Ex1QueryUserStatusReq
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ex1QueryUserStatusReq.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Ex1QueryUserStatusReq message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ex1QueryUserStatusReq.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.user_list != null && message.hasOwnProperty("user_list")) {
                        if(!Array.isArray(message.user_list))
                            return "user_list: array expected";
                        for(let i = 0; i < message.user_list.length; ++i) {
                            let error = $root.qihoo.protocol.messages.ReqEQ1User.verify(message.user_list[i]);
                            if(error)
                                return "user_list." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Ex1QueryUserStatusReq message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusReq} Ex1QueryUserStatusReq
                 */
                Ex1QueryUserStatusReq.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Ex1QueryUserStatusReq)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Ex1QueryUserStatusReq();
                    if(object.user_list) {
                        if(!Array.isArray(object.user_list))
                            throw TypeError(".qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list: array expected");
                        message.user_list = [];
                        for(let i = 0; i < object.user_list.length; ++i) {
                            if(typeof object.user_list[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.Ex1QueryUserStatusReq.user_list: object expected");
                            message.user_list[i] = $root.qihoo.protocol.messages.ReqEQ1User.fromObject(object.user_list[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Ex1QueryUserStatusReq message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @static
                 * @param {qihoo.protocol.messages.Ex1QueryUserStatusReq} message Ex1QueryUserStatusReq
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ex1QueryUserStatusReq.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.user_list = [];
                    if(message.user_list && message.user_list.length) {
                        object.user_list = [];
                        for(let j = 0; j < message.user_list.length; ++j)
                            object.user_list[j] = $root.qihoo.protocol.messages.ReqEQ1User.toObject(message.user_list[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Ex1QueryUserStatusReq to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusReq
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ex1QueryUserStatusReq.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ex1QueryUserStatusReq;
            })();

            messages.Ex1QueryUserStatusResp = (function () {

                /**
                 * Properties of an Ex1QueryUserStatusResp.
                 * @memberof qihoo.protocol.messages
                 * @interface IEx1QueryUserStatusResp
                 * @property {Array.<qihoo.protocol.messages.IRespEQ1User>|null} [user_list] Ex1QueryUserStatusResp user_list
                 */

                /**
                 * Constructs a new Ex1QueryUserStatusResp.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an Ex1QueryUserStatusResp.
                 * @implements IEx1QueryUserStatusResp
                 * @constructor
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusResp=} [properties] Properties to set
                 */
                function Ex1QueryUserStatusResp(properties) {
                    this.user_list = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ex1QueryUserStatusResp user_list.
                 * @member {Array.<qihoo.protocol.messages.IRespEQ1User>} user_list
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @instance
                 */
                Ex1QueryUserStatusResp.prototype.user_list = $util.emptyArray;

                /**
                 * Creates a new Ex1QueryUserStatusResp instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusResp=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusResp} Ex1QueryUserStatusResp instance
                 */
                Ex1QueryUserStatusResp.create = function create(properties) {
                    return new Ex1QueryUserStatusResp(properties);
                };

                /**
                 * Encodes the specified Ex1QueryUserStatusResp message. Does not implicitly {@link qihoo.protocol.messages.Ex1QueryUserStatusResp.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusResp} message Ex1QueryUserStatusResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ex1QueryUserStatusResp.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.user_list != null && message.user_list.length)
                        for(let i = 0; i < message.user_list.length; ++i)
                            $root.qihoo.protocol.messages.RespEQ1User.encode(message.user_list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Ex1QueryUserStatusResp message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Ex1QueryUserStatusResp.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {qihoo.protocol.messages.IEx1QueryUserStatusResp} message Ex1QueryUserStatusResp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ex1QueryUserStatusResp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Ex1QueryUserStatusResp message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusResp} Ex1QueryUserStatusResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ex1QueryUserStatusResp.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Ex1QueryUserStatusResp();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                if(!(message.user_list && message.user_list.length))
                                    message.user_list = [];
                                message.user_list.push($root.qihoo.protocol.messages.RespEQ1User.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Ex1QueryUserStatusResp message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusResp} Ex1QueryUserStatusResp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ex1QueryUserStatusResp.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Ex1QueryUserStatusResp message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ex1QueryUserStatusResp.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.user_list != null && message.hasOwnProperty("user_list")) {
                        if(!Array.isArray(message.user_list))
                            return "user_list: array expected";
                        for(let i = 0; i < message.user_list.length; ++i) {
                            let error = $root.qihoo.protocol.messages.RespEQ1User.verify(message.user_list[i]);
                            if(error)
                                return "user_list." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Ex1QueryUserStatusResp message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Ex1QueryUserStatusResp} Ex1QueryUserStatusResp
                 */
                Ex1QueryUserStatusResp.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Ex1QueryUserStatusResp)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Ex1QueryUserStatusResp();
                    if(object.user_list) {
                        if(!Array.isArray(object.user_list))
                            throw TypeError(".qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list: array expected");
                        message.user_list = [];
                        for(let i = 0; i < object.user_list.length; ++i) {
                            if(typeof object.user_list[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.Ex1QueryUserStatusResp.user_list: object expected");
                            message.user_list[i] = $root.qihoo.protocol.messages.RespEQ1User.fromObject(object.user_list[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Ex1QueryUserStatusResp message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @static
                 * @param {qihoo.protocol.messages.Ex1QueryUserStatusResp} message Ex1QueryUserStatusResp
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ex1QueryUserStatusResp.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.user_list = [];
                    if(message.user_list && message.user_list.length) {
                        object.user_list = [];
                        for(let j = 0; j < message.user_list.length; ++j)
                            object.user_list[j] = $root.qihoo.protocol.messages.RespEQ1User.toObject(message.user_list[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Ex1QueryUserStatusResp to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Ex1QueryUserStatusResp
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ex1QueryUserStatusResp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ex1QueryUserStatusResp;
            })();

            messages.Request = (function () {

                /**
                 * Properties of a Request.
                 * @memberof qihoo.protocol.messages
                 * @interface IRequest
                 * @property {qihoo.protocol.messages.ILoginReq|null} [login] Request login
                 * @property {qihoo.protocol.messages.IChatReq|null} [chat] Request chat
                 * @property {qihoo.protocol.messages.IGetInfoReq|null} [get_info] Request get_info
                 * @property {qihoo.protocol.messages.ILogoutReq|null} [logout] Request logout
                 * @property {qihoo.protocol.messages.IInitLoginReq|null} [init_login_req] Request init_login_req
                 * @property {qihoo.protocol.messages.IService_Req|null} [service_req] Request service_req
                 * @property {qihoo.protocol.messages.IEx1QueryUserStatusReq|null} [e1_query_user] Request e1_query_user
                 * @property {qihoo.protocol.messages.IGetMultiInfosReq|null} [get_multi_infos] Request get_multi_infos
                 */

                /**
                 * Constructs a new Request.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Request.
                 * @implements IRequest
                 * @constructor
                 * @param {qihoo.protocol.messages.IRequest=} [properties] Properties to set
                 */
                function Request(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Request login.
                 * @member {qihoo.protocol.messages.ILoginReq|null|undefined} login
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.login = null;

                /**
                 * Request chat.
                 * @member {qihoo.protocol.messages.IChatReq|null|undefined} chat
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.chat = null;

                /**
                 * Request get_info.
                 * @member {qihoo.protocol.messages.IGetInfoReq|null|undefined} get_info
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.get_info = null;

                /**
                 * Request logout.
                 * @member {qihoo.protocol.messages.ILogoutReq|null|undefined} logout
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.logout = null;

                /**
                 * Request init_login_req.
                 * @member {qihoo.protocol.messages.IInitLoginReq|null|undefined} init_login_req
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.init_login_req = null;

                /**
                 * Request service_req.
                 * @member {qihoo.protocol.messages.IService_Req|null|undefined} service_req
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.service_req = null;

                /**
                 * Request e1_query_user.
                 * @member {qihoo.protocol.messages.IEx1QueryUserStatusReq|null|undefined} e1_query_user
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.e1_query_user = null;

                /**
                 * Request get_multi_infos.
                 * @member {qihoo.protocol.messages.IGetMultiInfosReq|null|undefined} get_multi_infos
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 */
                Request.prototype.get_multi_infos = null;

                /**
                 * Creates a new Request instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {qihoo.protocol.messages.IRequest=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Request} Request instance
                 */
                Request.create = function create(properties) {
                    return new Request(properties);
                };

                /**
                 * Encodes the specified Request message. Does not implicitly {@link qihoo.protocol.messages.Request.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {qihoo.protocol.messages.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.login != null && message.hasOwnProperty("login"))
                        $root.qihoo.protocol.messages.LoginReq.encode(message.login, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.chat != null && message.hasOwnProperty("chat"))
                        $root.qihoo.protocol.messages.ChatReq.encode(message.chat, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.get_info != null && message.hasOwnProperty("get_info"))
                        $root.qihoo.protocol.messages.GetInfoReq.encode(message.get_info, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if(message.logout != null && message.hasOwnProperty("logout"))
                        $root.qihoo.protocol.messages.LogoutReq.encode(message.logout, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.init_login_req != null && message.hasOwnProperty("init_login_req"))
                        $root.qihoo.protocol.messages.InitLoginReq.encode(message.init_login_req, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.service_req != null && message.hasOwnProperty("service_req"))
                        $root.qihoo.protocol.messages.Service_Req.encode(message.service_req, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user"))
                        $root.qihoo.protocol.messages.Ex1QueryUserStatusReq.encode(message.e1_query_user, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos"))
                        $root.qihoo.protocol.messages.GetMultiInfosReq.encode(message.get_multi_infos, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Request message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Request.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {qihoo.protocol.messages.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Request message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Request();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 2:
                                message.login = $root.qihoo.protocol.messages.LoginReq.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.chat = $root.qihoo.protocol.messages.ChatReq.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.get_info = $root.qihoo.protocol.messages.GetInfoReq.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.logout = $root.qihoo.protocol.messages.LogoutReq.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.init_login_req = $root.qihoo.protocol.messages.InitLoginReq.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.service_req = $root.qihoo.protocol.messages.Service_Req.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusReq.decode(reader, reader.uint32());
                                break;
                            case 100:
                                message.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosReq.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Request message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Request message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Request.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.login != null && message.hasOwnProperty("login")) {
                        let error = $root.qihoo.protocol.messages.LoginReq.verify(message.login);
                        if(error)
                            return "login." + error;
                    }
                    if(message.chat != null && message.hasOwnProperty("chat")) {
                        let error = $root.qihoo.protocol.messages.ChatReq.verify(message.chat);
                        if(error)
                            return "chat." + error;
                    }
                    if(message.get_info != null && message.hasOwnProperty("get_info")) {
                        let error = $root.qihoo.protocol.messages.GetInfoReq.verify(message.get_info);
                        if(error)
                            return "get_info." + error;
                    }
                    if(message.logout != null && message.hasOwnProperty("logout")) {
                        let error = $root.qihoo.protocol.messages.LogoutReq.verify(message.logout);
                        if(error)
                            return "logout." + error;
                    }
                    if(message.init_login_req != null && message.hasOwnProperty("init_login_req")) {
                        let error = $root.qihoo.protocol.messages.InitLoginReq.verify(message.init_login_req);
                        if(error)
                            return "init_login_req." + error;
                    }
                    if(message.service_req != null && message.hasOwnProperty("service_req")) {
                        let error = $root.qihoo.protocol.messages.Service_Req.verify(message.service_req);
                        if(error)
                            return "service_req." + error;
                    }
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user")) {
                        let error = $root.qihoo.protocol.messages.Ex1QueryUserStatusReq.verify(message.e1_query_user);
                        if(error)
                            return "e1_query_user." + error;
                    }
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos")) {
                        let error = $root.qihoo.protocol.messages.GetMultiInfosReq.verify(message.get_multi_infos);
                        if(error)
                            return "get_multi_infos." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Request message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Request} Request
                 */
                Request.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Request)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Request();
                    if(object.login != null) {
                        if(typeof object.login !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.login: object expected");
                        message.login = $root.qihoo.protocol.messages.LoginReq.fromObject(object.login);
                    }
                    if(object.chat != null) {
                        if(typeof object.chat !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.chat: object expected");
                        message.chat = $root.qihoo.protocol.messages.ChatReq.fromObject(object.chat);
                    }
                    if(object.get_info != null) {
                        if(typeof object.get_info !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.get_info: object expected");
                        message.get_info = $root.qihoo.protocol.messages.GetInfoReq.fromObject(object.get_info);
                    }
                    if(object.logout != null) {
                        if(typeof object.logout !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.logout: object expected");
                        message.logout = $root.qihoo.protocol.messages.LogoutReq.fromObject(object.logout);
                    }
                    if(object.init_login_req != null) {
                        if(typeof object.init_login_req !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.init_login_req: object expected");
                        message.init_login_req = $root.qihoo.protocol.messages.InitLoginReq.fromObject(object.init_login_req);
                    }
                    if(object.service_req != null) {
                        if(typeof object.service_req !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.service_req: object expected");
                        message.service_req = $root.qihoo.protocol.messages.Service_Req.fromObject(object.service_req);
                    }
                    if(object.e1_query_user != null) {
                        if(typeof object.e1_query_user !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.e1_query_user: object expected");
                        message.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusReq.fromObject(object.e1_query_user);
                    }
                    if(object.get_multi_infos != null) {
                        if(typeof object.get_multi_infos !== "object")
                            throw TypeError(".qihoo.protocol.messages.Request.get_multi_infos: object expected");
                        message.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosReq.fromObject(object.get_multi_infos);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Request message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Request
                 * @static
                 * @param {qihoo.protocol.messages.Request} message Request
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Request.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.login = null;
                        object.chat = null;
                        object.get_info = null;
                        object.logout = null;
                        object.init_login_req = null;
                        object.service_req = null;
                        object.e1_query_user = null;
                        object.get_multi_infos = null;
                    }
                    if(message.login != null && message.hasOwnProperty("login"))
                        object.login = $root.qihoo.protocol.messages.LoginReq.toObject(message.login, options);
                    if(message.chat != null && message.hasOwnProperty("chat"))
                        object.chat = $root.qihoo.protocol.messages.ChatReq.toObject(message.chat, options);
                    if(message.get_info != null && message.hasOwnProperty("get_info"))
                        object.get_info = $root.qihoo.protocol.messages.GetInfoReq.toObject(message.get_info, options);
                    if(message.logout != null && message.hasOwnProperty("logout"))
                        object.logout = $root.qihoo.protocol.messages.LogoutReq.toObject(message.logout, options);
                    if(message.init_login_req != null && message.hasOwnProperty("init_login_req"))
                        object.init_login_req = $root.qihoo.protocol.messages.InitLoginReq.toObject(message.init_login_req, options);
                    if(message.service_req != null && message.hasOwnProperty("service_req"))
                        object.service_req = $root.qihoo.protocol.messages.Service_Req.toObject(message.service_req, options);
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user"))
                        object.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusReq.toObject(message.e1_query_user, options);
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos"))
                        object.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosReq.toObject(message.get_multi_infos, options);
                    return object;
                };

                /**
                 * Converts this Request to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Request
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Request.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Request;
            })();

            messages.Response = (function () {

                /**
                 * Properties of a Response.
                 * @memberof qihoo.protocol.messages
                 * @interface IResponse
                 * @property {qihoo.protocol.messages.IError|null} [error] Response error
                 * @property {qihoo.protocol.messages.ILoginResp|null} [login] Response login
                 * @property {qihoo.protocol.messages.IChatResp|null} [chat] Response chat
                 * @property {qihoo.protocol.messages.IGetInfoResp|null} [get_info] Response get_info
                 * @property {qihoo.protocol.messages.ILogoutResp|null} [logout] Response logout
                 * @property {qihoo.protocol.messages.IInitLoginResp|null} [init_login_resp] Response init_login_resp
                 * @property {qihoo.protocol.messages.IService_Resp|null} [service_resp] Response service_resp
                 * @property {qihoo.protocol.messages.IEx1QueryUserStatusResp|null} [e1_query_user] Response e1_query_user
                 * @property {qihoo.protocol.messages.IGetMultiInfosResp|null} [get_multi_infos] Response get_multi_infos
                 */

                /**
                 * Constructs a new Response.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Response.
                 * @implements IResponse
                 * @constructor
                 * @param {qihoo.protocol.messages.IResponse=} [properties] Properties to set
                 */
                function Response(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Response error.
                 * @member {qihoo.protocol.messages.IError|null|undefined} error
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.error = null;

                /**
                 * Response login.
                 * @member {qihoo.protocol.messages.ILoginResp|null|undefined} login
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.login = null;

                /**
                 * Response chat.
                 * @member {qihoo.protocol.messages.IChatResp|null|undefined} chat
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.chat = null;

                /**
                 * Response get_info.
                 * @member {qihoo.protocol.messages.IGetInfoResp|null|undefined} get_info
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.get_info = null;

                /**
                 * Response logout.
                 * @member {qihoo.protocol.messages.ILogoutResp|null|undefined} logout
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.logout = null;

                /**
                 * Response init_login_resp.
                 * @member {qihoo.protocol.messages.IInitLoginResp|null|undefined} init_login_resp
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.init_login_resp = null;

                /**
                 * Response service_resp.
                 * @member {qihoo.protocol.messages.IService_Resp|null|undefined} service_resp
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.service_resp = null;

                /**
                 * Response e1_query_user.
                 * @member {qihoo.protocol.messages.IEx1QueryUserStatusResp|null|undefined} e1_query_user
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.e1_query_user = null;

                /**
                 * Response get_multi_infos.
                 * @member {qihoo.protocol.messages.IGetMultiInfosResp|null|undefined} get_multi_infos
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 */
                Response.prototype.get_multi_infos = null;

                /**
                 * Creates a new Response instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {qihoo.protocol.messages.IResponse=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Response} Response instance
                 */
                Response.create = function create(properties) {
                    return new Response(properties);
                };

                /**
                 * Encodes the specified Response message. Does not implicitly {@link qihoo.protocol.messages.Response.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {qihoo.protocol.messages.IResponse} message Response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Response.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.error != null && message.hasOwnProperty("error"))
                        $root.qihoo.protocol.messages.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.login != null && message.hasOwnProperty("login"))
                        $root.qihoo.protocol.messages.LoginResp.encode(message.login, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if(message.chat != null && message.hasOwnProperty("chat"))
                        $root.qihoo.protocol.messages.ChatResp.encode(message.chat, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if(message.get_info != null && message.hasOwnProperty("get_info"))
                        $root.qihoo.protocol.messages.GetInfoResp.encode(message.get_info, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.logout != null && message.hasOwnProperty("logout"))
                        $root.qihoo.protocol.messages.LogoutResp.encode(message.logout, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if(message.init_login_resp != null && message.hasOwnProperty("init_login_resp"))
                        $root.qihoo.protocol.messages.InitLoginResp.encode(message.init_login_resp, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if(message.service_resp != null && message.hasOwnProperty("service_resp"))
                        $root.qihoo.protocol.messages.Service_Resp.encode(message.service_resp, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user"))
                        $root.qihoo.protocol.messages.Ex1QueryUserStatusResp.encode(message.e1_query_user, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos"))
                        $root.qihoo.protocol.messages.GetMultiInfosResp.encode(message.get_multi_infos, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Response message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Response.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {qihoo.protocol.messages.IResponse} message Response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Response.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Response message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Response} Response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Response.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Response();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.error = $root.qihoo.protocol.messages.Error.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.login = $root.qihoo.protocol.messages.LoginResp.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.chat = $root.qihoo.protocol.messages.ChatResp.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.get_info = $root.qihoo.protocol.messages.GetInfoResp.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.logout = $root.qihoo.protocol.messages.LogoutResp.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.init_login_resp = $root.qihoo.protocol.messages.InitLoginResp.decode(reader, reader.uint32());
                                break;
                            case 12:
                                message.service_resp = $root.qihoo.protocol.messages.Service_Resp.decode(reader, reader.uint32());
                                break;
                            case 13:
                                message.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusResp.decode(reader, reader.uint32());
                                break;
                            case 100:
                                message.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosResp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Response message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Response} Response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Response.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Response message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Response.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.error != null && message.hasOwnProperty("error")) {
                        let error = $root.qihoo.protocol.messages.Error.verify(message.error);
                        if(error)
                            return "error." + error;
                    }
                    if(message.login != null && message.hasOwnProperty("login")) {
                        let error = $root.qihoo.protocol.messages.LoginResp.verify(message.login);
                        if(error)
                            return "login." + error;
                    }
                    if(message.chat != null && message.hasOwnProperty("chat")) {
                        let error = $root.qihoo.protocol.messages.ChatResp.verify(message.chat);
                        if(error)
                            return "chat." + error;
                    }
                    if(message.get_info != null && message.hasOwnProperty("get_info")) {
                        let error = $root.qihoo.protocol.messages.GetInfoResp.verify(message.get_info);
                        if(error)
                            return "get_info." + error;
                    }
                    if(message.logout != null && message.hasOwnProperty("logout")) {
                        let error = $root.qihoo.protocol.messages.LogoutResp.verify(message.logout);
                        if(error)
                            return "logout." + error;
                    }
                    if(message.init_login_resp != null && message.hasOwnProperty("init_login_resp")) {
                        let error = $root.qihoo.protocol.messages.InitLoginResp.verify(message.init_login_resp);
                        if(error)
                            return "init_login_resp." + error;
                    }
                    if(message.service_resp != null && message.hasOwnProperty("service_resp")) {
                        let error = $root.qihoo.protocol.messages.Service_Resp.verify(message.service_resp);
                        if(error)
                            return "service_resp." + error;
                    }
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user")) {
                        let error = $root.qihoo.protocol.messages.Ex1QueryUserStatusResp.verify(message.e1_query_user);
                        if(error)
                            return "e1_query_user." + error;
                    }
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos")) {
                        let error = $root.qihoo.protocol.messages.GetMultiInfosResp.verify(message.get_multi_infos);
                        if(error)
                            return "get_multi_infos." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Response message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Response} Response
                 */
                Response.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Response)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Response();
                    if(object.error != null) {
                        if(typeof object.error !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.error: object expected");
                        message.error = $root.qihoo.protocol.messages.Error.fromObject(object.error);
                    }
                    if(object.login != null) {
                        if(typeof object.login !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.login: object expected");
                        message.login = $root.qihoo.protocol.messages.LoginResp.fromObject(object.login);
                    }
                    if(object.chat != null) {
                        if(typeof object.chat !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.chat: object expected");
                        message.chat = $root.qihoo.protocol.messages.ChatResp.fromObject(object.chat);
                    }
                    if(object.get_info != null) {
                        if(typeof object.get_info !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.get_info: object expected");
                        message.get_info = $root.qihoo.protocol.messages.GetInfoResp.fromObject(object.get_info);
                    }
                    if(object.logout != null) {
                        if(typeof object.logout !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.logout: object expected");
                        message.logout = $root.qihoo.protocol.messages.LogoutResp.fromObject(object.logout);
                    }
                    if(object.init_login_resp != null) {
                        if(typeof object.init_login_resp !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.init_login_resp: object expected");
                        message.init_login_resp = $root.qihoo.protocol.messages.InitLoginResp.fromObject(object.init_login_resp);
                    }
                    if(object.service_resp != null) {
                        if(typeof object.service_resp !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.service_resp: object expected");
                        message.service_resp = $root.qihoo.protocol.messages.Service_Resp.fromObject(object.service_resp);
                    }
                    if(object.e1_query_user != null) {
                        if(typeof object.e1_query_user !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.e1_query_user: object expected");
                        message.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusResp.fromObject(object.e1_query_user);
                    }
                    if(object.get_multi_infos != null) {
                        if(typeof object.get_multi_infos !== "object")
                            throw TypeError(".qihoo.protocol.messages.Response.get_multi_infos: object expected");
                        message.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosResp.fromObject(object.get_multi_infos);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Response message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Response
                 * @static
                 * @param {qihoo.protocol.messages.Response} message Response
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Response.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.error = null;
                        object.login = null;
                        object.chat = null;
                        object.get_info = null;
                        object.logout = null;
                        object.init_login_resp = null;
                        object.service_resp = null;
                        object.e1_query_user = null;
                        object.get_multi_infos = null;
                    }
                    if(message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.qihoo.protocol.messages.Error.toObject(message.error, options);
                    if(message.login != null && message.hasOwnProperty("login"))
                        object.login = $root.qihoo.protocol.messages.LoginResp.toObject(message.login, options);
                    if(message.chat != null && message.hasOwnProperty("chat"))
                        object.chat = $root.qihoo.protocol.messages.ChatResp.toObject(message.chat, options);
                    if(message.get_info != null && message.hasOwnProperty("get_info"))
                        object.get_info = $root.qihoo.protocol.messages.GetInfoResp.toObject(message.get_info, options);
                    if(message.logout != null && message.hasOwnProperty("logout"))
                        object.logout = $root.qihoo.protocol.messages.LogoutResp.toObject(message.logout, options);
                    if(message.init_login_resp != null && message.hasOwnProperty("init_login_resp"))
                        object.init_login_resp = $root.qihoo.protocol.messages.InitLoginResp.toObject(message.init_login_resp, options);
                    if(message.service_resp != null && message.hasOwnProperty("service_resp"))
                        object.service_resp = $root.qihoo.protocol.messages.Service_Resp.toObject(message.service_resp, options);
                    if(message.e1_query_user != null && message.hasOwnProperty("e1_query_user"))
                        object.e1_query_user = $root.qihoo.protocol.messages.Ex1QueryUserStatusResp.toObject(message.e1_query_user, options);
                    if(message.get_multi_infos != null && message.hasOwnProperty("get_multi_infos"))
                        object.get_multi_infos = $root.qihoo.protocol.messages.GetMultiInfosResp.toObject(message.get_multi_infos, options);
                    return object;
                };

                /**
                 * Converts this Response to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Response
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Response.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Response;
            })();

            messages.NewMessageNotify = (function () {

                /**
                 * Properties of a NewMessageNotify.
                 * @memberof qihoo.protocol.messages
                 * @interface INewMessageNotify
                 * @property {string} info_type NewMessageNotify info_type
                 * @property {Uint8Array|null} [info_content] NewMessageNotify info_content
                 * @property {number|Long|null} [info_id] NewMessageNotify info_id
                 * @property {number|null} [query_after_seconds] NewMessageNotify query_after_seconds
                 */

                /**
                 * Constructs a new NewMessageNotify.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a NewMessageNotify.
                 * @implements INewMessageNotify
                 * @constructor
                 * @param {qihoo.protocol.messages.INewMessageNotify=} [properties] Properties to set
                 */
                function NewMessageNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NewMessageNotify info_type.
                 * @member {string} info_type
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @instance
                 */
                NewMessageNotify.prototype.info_type = "";

                /**
                 * NewMessageNotify info_content.
                 * @member {Uint8Array} info_content
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @instance
                 */
                NewMessageNotify.prototype.info_content = $util.newBuffer([]);

                /**
                 * NewMessageNotify info_id.
                 * @member {number|Long} info_id
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @instance
                 */
                NewMessageNotify.prototype.info_id = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;

                /**
                 * NewMessageNotify query_after_seconds.
                 * @member {number} query_after_seconds
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @instance
                 */
                NewMessageNotify.prototype.query_after_seconds = 0;

                /**
                 * Creates a new NewMessageNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {qihoo.protocol.messages.INewMessageNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.NewMessageNotify} NewMessageNotify instance
                 */
                NewMessageNotify.create = function create(properties) {
                    return new NewMessageNotify(properties);
                };

                /**
                 * Encodes the specified NewMessageNotify message. Does not implicitly {@link qihoo.protocol.messages.NewMessageNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {qihoo.protocol.messages.INewMessageNotify} message NewMessageNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NewMessageNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.info_type);
                    if(message.info_content != null && message.hasOwnProperty("info_content"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.info_content);
                    if(message.info_id != null && message.hasOwnProperty("info_id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.info_id);
                    if(message.query_after_seconds != null && message.hasOwnProperty("query_after_seconds"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.query_after_seconds);
                    return writer;
                };

                /**
                 * Encodes the specified NewMessageNotify message, length delimited. Does not implicitly {@link qihoo.protocol.messages.NewMessageNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {qihoo.protocol.messages.INewMessageNotify} message NewMessageNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NewMessageNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NewMessageNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.NewMessageNotify} NewMessageNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NewMessageNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.NewMessageNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.info_type = reader.string();
                                break;
                            case 2:
                                message.info_content = reader.bytes();
                                break;
                            case 3:
                                message.info_id = reader.int64();
                                break;
                            case 4:
                                message.query_after_seconds = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("info_type"))
                        throw $util.ProtocolError("missing required 'info_type'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NewMessageNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.NewMessageNotify} NewMessageNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NewMessageNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NewMessageNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NewMessageNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.info_type))
                        return "info_type: string expected";
                    if(message.info_content != null && message.hasOwnProperty("info_content"))
                        if(!(message.info_content && typeof message.info_content.length === "number" || $util.isString(message.info_content)))
                            return "info_content: buffer expected";
                    if(message.info_id != null && message.hasOwnProperty("info_id"))
                        if(!$util.isInteger(message.info_id) && !(message.info_id && $util.isInteger(message.info_id.low) && $util.isInteger(message.info_id.high)))
                            return "info_id: integer|Long expected";
                    if(message.query_after_seconds != null && message.hasOwnProperty("query_after_seconds"))
                        if(!$util.isInteger(message.query_after_seconds))
                            return "query_after_seconds: integer expected";
                    return null;
                };

                /**
                 * Creates a NewMessageNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.NewMessageNotify} NewMessageNotify
                 */
                NewMessageNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.NewMessageNotify)
                        return object;
                    let message = new $root.qihoo.protocol.messages.NewMessageNotify();
                    if(object.info_type != null)
                        message.info_type = String(object.info_type);
                    if(object.info_content != null)
                        if(typeof object.info_content === "string")
                            $util.base64.decode(object.info_content, message.info_content = $util.newBuffer($util.base64.length(object.info_content)), 0);
                        else if(object.info_content.length)
                            message.info_content = object.info_content;
                    if(object.info_id != null)
                        if($util.Long)
                            (message.info_id = $util.Long.fromValue(object.info_id)).unsigned = false;
                        else if(typeof object.info_id === "string")
                            message.info_id = parseInt(object.info_id, 10);
                        else if(typeof object.info_id === "number")
                            message.info_id = object.info_id;
                        else if(typeof object.info_id === "object")
                            message.info_id = new $util.LongBits(object.info_id.low >>> 0, object.info_id.high >>> 0).toNumber();
                    if(object.query_after_seconds != null)
                        message.query_after_seconds = object.query_after_seconds >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a NewMessageNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @static
                 * @param {qihoo.protocol.messages.NewMessageNotify} message NewMessageNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NewMessageNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.info_type = "";
                        if(options.bytes === String)
                            object.info_content = "";
                        else {
                            object.info_content = [];
                            if(options.bytes !== Array)
                                object.info_content = $util.newBuffer(object.info_content);
                        }
                        if($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.info_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.info_id = options.longs === String ? "0" : 0;
                        object.query_after_seconds = 0;
                    }
                    if(message.info_type != null && message.hasOwnProperty("info_type"))
                        object.info_type = message.info_type;
                    if(message.info_content != null && message.hasOwnProperty("info_content"))
                        object.info_content = options.bytes === String ? $util.base64.encode(message.info_content, 0, message.info_content.length) : options.bytes === Array ? Array.prototype.slice.call(message.info_content) : message.info_content;
                    if(message.info_id != null && message.hasOwnProperty("info_id"))
                        if(typeof message.info_id === "number")
                            object.info_id = options.longs === String ? String(message.info_id) : message.info_id;
                        else
                            object.info_id = options.longs === String ? $util.Long.prototype.toString.call(message.info_id) : options.longs === Number ? new $util.LongBits(message.info_id.low >>> 0, message.info_id.high >>> 0).toNumber() : message.info_id;
                    if(message.query_after_seconds != null && message.hasOwnProperty("query_after_seconds"))
                        object.query_after_seconds = message.query_after_seconds;
                    return object;
                };

                /**
                 * Converts this NewMessageNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.NewMessageNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NewMessageNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NewMessageNotify;
            })();

            messages.ReLoginNotify = (function () {

                /**
                 * Properties of a ReLoginNotify.
                 * @memberof qihoo.protocol.messages
                 * @interface IReLoginNotify
                 * @property {string|null} [new_ip] ReLoginNotify new_ip
                 */

                /**
                 * Constructs a new ReLoginNotify.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a ReLoginNotify.
                 * @implements IReLoginNotify
                 * @constructor
                 * @param {qihoo.protocol.messages.IReLoginNotify=} [properties] Properties to set
                 */
                function ReLoginNotify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReLoginNotify new_ip.
                 * @member {string} new_ip
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @instance
                 */
                ReLoginNotify.prototype.new_ip = "";

                /**
                 * Creates a new ReLoginNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReLoginNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.ReLoginNotify} ReLoginNotify instance
                 */
                ReLoginNotify.create = function create(properties) {
                    return new ReLoginNotify(properties);
                };

                /**
                 * Encodes the specified ReLoginNotify message. Does not implicitly {@link qihoo.protocol.messages.ReLoginNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReLoginNotify} message ReLoginNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReLoginNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.new_ip != null && message.hasOwnProperty("new_ip"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.new_ip);
                    return writer;
                };

                /**
                 * Encodes the specified ReLoginNotify message, length delimited. Does not implicitly {@link qihoo.protocol.messages.ReLoginNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReLoginNotify} message ReLoginNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReLoginNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReLoginNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.ReLoginNotify} ReLoginNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReLoginNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.ReLoginNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.new_ip = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReLoginNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.ReLoginNotify} ReLoginNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReLoginNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReLoginNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReLoginNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.new_ip != null && message.hasOwnProperty("new_ip"))
                        if(!$util.isString(message.new_ip))
                            return "new_ip: string expected";
                    return null;
                };

                /**
                 * Creates a ReLoginNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.ReLoginNotify} ReLoginNotify
                 */
                ReLoginNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.ReLoginNotify)
                        return object;
                    let message = new $root.qihoo.protocol.messages.ReLoginNotify();
                    if(object.new_ip != null)
                        message.new_ip = String(object.new_ip);
                    return message;
                };

                /**
                 * Creates a plain object from a ReLoginNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @static
                 * @param {qihoo.protocol.messages.ReLoginNotify} message ReLoginNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReLoginNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.new_ip = "";
                    if(message.new_ip != null && message.hasOwnProperty("new_ip"))
                        object.new_ip = message.new_ip;
                    return object;
                };

                /**
                 * Converts this ReLoginNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.ReLoginNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReLoginNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReLoginNotify;
            })();

            messages.ReConnectNotify = (function () {

                /**
                 * Properties of a ReConnectNotify.
                 * @memberof qihoo.protocol.messages
                 * @interface IReConnectNotify
                 * @property {string|null} [ip] ReConnectNotify ip
                 * @property {number|null} [port] ReConnectNotify port
                 * @property {Array.<string>|null} [more_ips] ReConnectNotify more_ips
                 */

                /**
                 * Constructs a new ReConnectNotify.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a ReConnectNotify.
                 * @implements IReConnectNotify
                 * @constructor
                 * @param {qihoo.protocol.messages.IReConnectNotify=} [properties] Properties to set
                 */
                function ReConnectNotify(properties) {
                    this.more_ips = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReConnectNotify ip.
                 * @member {string} ip
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @instance
                 */
                ReConnectNotify.prototype.ip = "";

                /**
                 * ReConnectNotify port.
                 * @member {number} port
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @instance
                 */
                ReConnectNotify.prototype.port = 0;

                /**
                 * ReConnectNotify more_ips.
                 * @member {Array.<string>} more_ips
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @instance
                 */
                ReConnectNotify.prototype.more_ips = $util.emptyArray;

                /**
                 * Creates a new ReConnectNotify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReConnectNotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.ReConnectNotify} ReConnectNotify instance
                 */
                ReConnectNotify.create = function create(properties) {
                    return new ReConnectNotify(properties);
                };

                /**
                 * Encodes the specified ReConnectNotify message. Does not implicitly {@link qihoo.protocol.messages.ReConnectNotify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReConnectNotify} message ReConnectNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReConnectNotify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.ip != null && message.hasOwnProperty("ip"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ip);
                    if(message.port != null && message.hasOwnProperty("port"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                    if(message.more_ips != null && message.more_ips.length)
                        for(let i = 0; i < message.more_ips.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.more_ips[i]);
                    return writer;
                };

                /**
                 * Encodes the specified ReConnectNotify message, length delimited. Does not implicitly {@link qihoo.protocol.messages.ReConnectNotify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {qihoo.protocol.messages.IReConnectNotify} message ReConnectNotify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReConnectNotify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReConnectNotify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.ReConnectNotify} ReConnectNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReConnectNotify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.ReConnectNotify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.ip = reader.string();
                                break;
                            case 2:
                                message.port = reader.uint32();
                                break;
                            case 3:
                                if(!(message.more_ips && message.more_ips.length))
                                    message.more_ips = [];
                                message.more_ips.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReConnectNotify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.ReConnectNotify} ReConnectNotify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReConnectNotify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReConnectNotify message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReConnectNotify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.ip != null && message.hasOwnProperty("ip"))
                        if(!$util.isString(message.ip))
                            return "ip: string expected";
                    if(message.port != null && message.hasOwnProperty("port"))
                        if(!$util.isInteger(message.port))
                            return "port: integer expected";
                    if(message.more_ips != null && message.hasOwnProperty("more_ips")) {
                        if(!Array.isArray(message.more_ips))
                            return "more_ips: array expected";
                        for(let i = 0; i < message.more_ips.length; ++i)
                            if(!$util.isString(message.more_ips[i]))
                                return "more_ips: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a ReConnectNotify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.ReConnectNotify} ReConnectNotify
                 */
                ReConnectNotify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.ReConnectNotify)
                        return object;
                    let message = new $root.qihoo.protocol.messages.ReConnectNotify();
                    if(object.ip != null)
                        message.ip = String(object.ip);
                    if(object.port != null)
                        message.port = object.port >>> 0;
                    if(object.more_ips) {
                        if(!Array.isArray(object.more_ips))
                            throw TypeError(".qihoo.protocol.messages.ReConnectNotify.more_ips: array expected");
                        message.more_ips = [];
                        for(let i = 0; i < object.more_ips.length; ++i)
                            message.more_ips[i] = String(object.more_ips[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReConnectNotify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @static
                 * @param {qihoo.protocol.messages.ReConnectNotify} message ReConnectNotify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReConnectNotify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.more_ips = [];
                    if(options.defaults) {
                        object.ip = "";
                        object.port = 0;
                    }
                    if(message.ip != null && message.hasOwnProperty("ip"))
                        object.ip = message.ip;
                    if(message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    if(message.more_ips && message.more_ips.length) {
                        object.more_ips = [];
                        for(let j = 0; j < message.more_ips.length; ++j)
                            object.more_ips[j] = message.more_ips[j];
                    }
                    return object;
                };

                /**
                 * Converts this ReConnectNotify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.ReConnectNotify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReConnectNotify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReConnectNotify;
            })();

            messages.Notify = (function () {

                /**
                 * Properties of a Notify.
                 * @memberof qihoo.protocol.messages
                 * @interface INotify
                 * @property {qihoo.protocol.messages.INewMessageNotify|null} [newinfo_ntf] Notify newinfo_ntf
                 * @property {qihoo.protocol.messages.IReLoginNotify|null} [relogin_ntf] Notify relogin_ntf
                 * @property {qihoo.protocol.messages.IReConnectNotify|null} [reconnect_ntf] Notify reconnect_ntf
                 */

                /**
                 * Constructs a new Notify.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Notify.
                 * @implements INotify
                 * @constructor
                 * @param {qihoo.protocol.messages.INotify=} [properties] Properties to set
                 */
                function Notify(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Notify newinfo_ntf.
                 * @member {qihoo.protocol.messages.INewMessageNotify|null|undefined} newinfo_ntf
                 * @memberof qihoo.protocol.messages.Notify
                 * @instance
                 */
                Notify.prototype.newinfo_ntf = null;

                /**
                 * Notify relogin_ntf.
                 * @member {qihoo.protocol.messages.IReLoginNotify|null|undefined} relogin_ntf
                 * @memberof qihoo.protocol.messages.Notify
                 * @instance
                 */
                Notify.prototype.relogin_ntf = null;

                /**
                 * Notify reconnect_ntf.
                 * @member {qihoo.protocol.messages.IReConnectNotify|null|undefined} reconnect_ntf
                 * @memberof qihoo.protocol.messages.Notify
                 * @instance
                 */
                Notify.prototype.reconnect_ntf = null;

                /**
                 * Creates a new Notify instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {qihoo.protocol.messages.INotify=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Notify} Notify instance
                 */
                Notify.create = function create(properties) {
                    return new Notify(properties);
                };

                /**
                 * Encodes the specified Notify message. Does not implicitly {@link qihoo.protocol.messages.Notify.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {qihoo.protocol.messages.INotify} message Notify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notify.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    if(message.newinfo_ntf != null && message.hasOwnProperty("newinfo_ntf"))
                        $root.qihoo.protocol.messages.NewMessageNotify.encode(message.newinfo_ntf, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if(message.relogin_ntf != null && message.hasOwnProperty("relogin_ntf"))
                        $root.qihoo.protocol.messages.ReLoginNotify.encode(message.relogin_ntf, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if(message.reconnect_ntf != null && message.hasOwnProperty("reconnect_ntf"))
                        $root.qihoo.protocol.messages.ReConnectNotify.encode(message.reconnect_ntf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Notify message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Notify.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {qihoo.protocol.messages.INotify} message Notify message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Notify.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Notify message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Notify} Notify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notify.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Notify();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.newinfo_ntf = $root.qihoo.protocol.messages.NewMessageNotify.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.relogin_ntf = $root.qihoo.protocol.messages.ReLoginNotify.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.reconnect_ntf = $root.qihoo.protocol.messages.ReConnectNotify.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Notify message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Notify} Notify
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Notify.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Notify message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Notify.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(message.newinfo_ntf != null && message.hasOwnProperty("newinfo_ntf")) {
                        let error = $root.qihoo.protocol.messages.NewMessageNotify.verify(message.newinfo_ntf);
                        if(error)
                            return "newinfo_ntf." + error;
                    }
                    if(message.relogin_ntf != null && message.hasOwnProperty("relogin_ntf")) {
                        let error = $root.qihoo.protocol.messages.ReLoginNotify.verify(message.relogin_ntf);
                        if(error)
                            return "relogin_ntf." + error;
                    }
                    if(message.reconnect_ntf != null && message.hasOwnProperty("reconnect_ntf")) {
                        let error = $root.qihoo.protocol.messages.ReConnectNotify.verify(message.reconnect_ntf);
                        if(error)
                            return "reconnect_ntf." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Notify message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Notify} Notify
                 */
                Notify.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Notify)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Notify();
                    if(object.newinfo_ntf != null) {
                        if(typeof object.newinfo_ntf !== "object")
                            throw TypeError(".qihoo.protocol.messages.Notify.newinfo_ntf: object expected");
                        message.newinfo_ntf = $root.qihoo.protocol.messages.NewMessageNotify.fromObject(object.newinfo_ntf);
                    }
                    if(object.relogin_ntf != null) {
                        if(typeof object.relogin_ntf !== "object")
                            throw TypeError(".qihoo.protocol.messages.Notify.relogin_ntf: object expected");
                        message.relogin_ntf = $root.qihoo.protocol.messages.ReLoginNotify.fromObject(object.relogin_ntf);
                    }
                    if(object.reconnect_ntf != null) {
                        if(typeof object.reconnect_ntf !== "object")
                            throw TypeError(".qihoo.protocol.messages.Notify.reconnect_ntf: object expected");
                        message.reconnect_ntf = $root.qihoo.protocol.messages.ReConnectNotify.fromObject(object.reconnect_ntf);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Notify message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Notify
                 * @static
                 * @param {qihoo.protocol.messages.Notify} message Notify
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Notify.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.newinfo_ntf = null;
                        object.relogin_ntf = null;
                        object.reconnect_ntf = null;
                    }
                    if(message.newinfo_ntf != null && message.hasOwnProperty("newinfo_ntf"))
                        object.newinfo_ntf = $root.qihoo.protocol.messages.NewMessageNotify.toObject(message.newinfo_ntf, options);
                    if(message.relogin_ntf != null && message.hasOwnProperty("relogin_ntf"))
                        object.relogin_ntf = $root.qihoo.protocol.messages.ReLoginNotify.toObject(message.relogin_ntf, options);
                    if(message.reconnect_ntf != null && message.hasOwnProperty("reconnect_ntf"))
                        object.reconnect_ntf = $root.qihoo.protocol.messages.ReConnectNotify.toObject(message.reconnect_ntf, options);
                    return object;
                };

                /**
                 * Converts this Notify to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Notify
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Notify.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Notify;
            })();

            messages.Ack = (function () {

                /**
                 * Properties of an Ack.
                 * @memberof qihoo.protocol.messages
                 * @interface IAck
                 * @property {number} result Ack result
                 */

                /**
                 * Constructs a new Ack.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents an Ack.
                 * @implements IAck
                 * @constructor
                 * @param {qihoo.protocol.messages.IAck=} [properties] Properties to set
                 */
                function Ack(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Ack result.
                 * @member {number} result
                 * @memberof qihoo.protocol.messages.Ack
                 * @instance
                 */
                Ack.prototype.result = 0;

                /**
                 * Creates a new Ack instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {qihoo.protocol.messages.IAck=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Ack} Ack instance
                 */
                Ack.create = function create(properties) {
                    return new Ack(properties);
                };

                /**
                 * Encodes the specified Ack message. Does not implicitly {@link qihoo.protocol.messages.Ack.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {qihoo.protocol.messages.IAck} message Ack message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ack.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.result);
                    return writer;
                };

                /**
                 * Encodes the specified Ack message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Ack.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {qihoo.protocol.messages.IAck} message Ack message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Ack.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Ack message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Ack} Ack
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ack.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Ack();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.result = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("result"))
                        throw $util.ProtocolError("missing required 'result'", { instance: message });
                    return message;
                };

                /**
                 * Decodes an Ack message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Ack} Ack
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Ack.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Ack message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Ack.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.result))
                        return "result: integer expected";
                    return null;
                };

                /**
                 * Creates an Ack message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Ack} Ack
                 */
                Ack.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Ack)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Ack();
                    if(object.result != null)
                        message.result = object.result >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Ack message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Ack
                 * @static
                 * @param {qihoo.protocol.messages.Ack} message Ack
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Ack.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults)
                        object.result = 0;
                    if(message.result != null && message.hasOwnProperty("result"))
                        object.result = message.result;
                    return object;
                };

                /**
                 * Converts this Ack to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Ack
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Ack.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Ack;
            })();

            messages.RouteInfo = (function () {

                /**
                 * Properties of a RouteInfo.
                 * @memberof qihoo.protocol.messages
                 * @interface IRouteInfo
                 * @property {Uint8Array} username RouteInfo username
                 * @property {string} msg_exchanger RouteInfo msg_exchanger
                 * @property {string} msg_router RouteInfo msg_router
                 */

                /**
                 * Constructs a new RouteInfo.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a RouteInfo.
                 * @implements IRouteInfo
                 * @constructor
                 * @param {qihoo.protocol.messages.IRouteInfo=} [properties] Properties to set
                 */
                function RouteInfo(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RouteInfo username.
                 * @member {Uint8Array} username
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @instance
                 */
                RouteInfo.prototype.username = $util.newBuffer([]);

                /**
                 * RouteInfo msg_exchanger.
                 * @member {string} msg_exchanger
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @instance
                 */
                RouteInfo.prototype.msg_exchanger = "";

                /**
                 * RouteInfo msg_router.
                 * @member {string} msg_router
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @instance
                 */
                RouteInfo.prototype.msg_router = "";

                /**
                 * Creates a new RouteInfo instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {qihoo.protocol.messages.IRouteInfo=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.RouteInfo} RouteInfo instance
                 */
                RouteInfo.create = function create(properties) {
                    return new RouteInfo(properties);
                };

                /**
                 * Encodes the specified RouteInfo message. Does not implicitly {@link qihoo.protocol.messages.RouteInfo.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {qihoo.protocol.messages.IRouteInfo} message RouteInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteInfo.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.username);
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg_exchanger);
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msg_router);
                    return writer;
                };

                /**
                 * Encodes the specified RouteInfo message, length delimited. Does not implicitly {@link qihoo.protocol.messages.RouteInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {qihoo.protocol.messages.IRouteInfo} message RouteInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RouteInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RouteInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.RouteInfo} RouteInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteInfo.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.RouteInfo();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.username = reader.bytes();
                                break;
                            case 2:
                                message.msg_exchanger = reader.string();
                                break;
                            case 3:
                                message.msg_router = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("username"))
                        throw $util.ProtocolError("missing required 'username'", { instance: message });
                    if(!message.hasOwnProperty("msg_exchanger"))
                        throw $util.ProtocolError("missing required 'msg_exchanger'", { instance: message });
                    if(!message.hasOwnProperty("msg_router"))
                        throw $util.ProtocolError("missing required 'msg_router'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a RouteInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.RouteInfo} RouteInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RouteInfo.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RouteInfo message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RouteInfo.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!(message.username && typeof message.username.length === "number" || $util.isString(message.username)))
                        return "username: buffer expected";
                    if(!$util.isString(message.msg_exchanger))
                        return "msg_exchanger: string expected";
                    if(!$util.isString(message.msg_router))
                        return "msg_router: string expected";
                    return null;
                };

                /**
                 * Creates a RouteInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.RouteInfo} RouteInfo
                 */
                RouteInfo.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.RouteInfo)
                        return object;
                    let message = new $root.qihoo.protocol.messages.RouteInfo();
                    if(object.username != null)
                        if(typeof object.username === "string")
                            $util.base64.decode(object.username, message.username = $util.newBuffer($util.base64.length(object.username)), 0);
                        else if(object.username.length)
                            message.username = object.username;
                    if(object.msg_exchanger != null)
                        message.msg_exchanger = String(object.msg_exchanger);
                    if(object.msg_router != null)
                        message.msg_router = String(object.msg_router);
                    return message;
                };

                /**
                 * Creates a plain object from a RouteInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @static
                 * @param {qihoo.protocol.messages.RouteInfo} message RouteInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RouteInfo.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        if(options.bytes === String)
                            object.username = "";
                        else {
                            object.username = [];
                            if(options.bytes !== Array)
                                object.username = $util.newBuffer(object.username);
                        }
                        object.msg_exchanger = "";
                        object.msg_router = "";
                    }
                    if(message.username != null && message.hasOwnProperty("username"))
                        object.username = options.bytes === String ? $util.base64.encode(message.username, 0, message.username.length) : options.bytes === Array ? Array.prototype.slice.call(message.username) : message.username;
                    if(message.msg_exchanger != null && message.hasOwnProperty("msg_exchanger"))
                        object.msg_exchanger = message.msg_exchanger;
                    if(message.msg_router != null && message.hasOwnProperty("msg_router"))
                        object.msg_router = message.msg_router;
                    return object;
                };

                /**
                 * Converts this RouteInfo to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.RouteInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RouteInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RouteInfo;
            })();

            messages.Proxy = (function () {

                /**
                 * Properties of a Proxy.
                 * @memberof qihoo.protocol.messages
                 * @interface IProxy
                 * @property {string} sender Proxy sender
                 * @property {Array.<qihoo.protocol.messages.IRouteInfo>|null} [receiver] Proxy receiver
                 */

                /**
                 * Constructs a new Proxy.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Proxy.
                 * @implements IProxy
                 * @constructor
                 * @param {qihoo.protocol.messages.IProxy=} [properties] Properties to set
                 */
                function Proxy(properties) {
                    this.receiver = [];
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Proxy sender.
                 * @member {string} sender
                 * @memberof qihoo.protocol.messages.Proxy
                 * @instance
                 */
                Proxy.prototype.sender = "";

                /**
                 * Proxy receiver.
                 * @member {Array.<qihoo.protocol.messages.IRouteInfo>} receiver
                 * @memberof qihoo.protocol.messages.Proxy
                 * @instance
                 */
                Proxy.prototype.receiver = $util.emptyArray;

                /**
                 * Creates a new Proxy instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {qihoo.protocol.messages.IProxy=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Proxy} Proxy instance
                 */
                Proxy.create = function create(properties) {
                    return new Proxy(properties);
                };

                /**
                 * Encodes the specified Proxy message. Does not implicitly {@link qihoo.protocol.messages.Proxy.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {qihoo.protocol.messages.IProxy} message Proxy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Proxy.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sender);
                    if(message.receiver != null && message.receiver.length)
                        for(let i = 0; i < message.receiver.length; ++i)
                            $root.qihoo.protocol.messages.RouteInfo.encode(message.receiver[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Proxy message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Proxy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {qihoo.protocol.messages.IProxy} message Proxy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Proxy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Proxy message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Proxy} Proxy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Proxy.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Proxy();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.sender = reader.string();
                                break;
                            case 2:
                                if(!(message.receiver && message.receiver.length))
                                    message.receiver = [];
                                message.receiver.push($root.qihoo.protocol.messages.RouteInfo.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("sender"))
                        throw $util.ProtocolError("missing required 'sender'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Proxy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Proxy} Proxy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Proxy.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Proxy message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Proxy.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isString(message.sender))
                        return "sender: string expected";
                    if(message.receiver != null && message.hasOwnProperty("receiver")) {
                        if(!Array.isArray(message.receiver))
                            return "receiver: array expected";
                        for(let i = 0; i < message.receiver.length; ++i) {
                            let error = $root.qihoo.protocol.messages.RouteInfo.verify(message.receiver[i]);
                            if(error)
                                return "receiver." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Proxy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Proxy} Proxy
                 */
                Proxy.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Proxy)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Proxy();
                    if(object.sender != null)
                        message.sender = String(object.sender);
                    if(object.receiver) {
                        if(!Array.isArray(object.receiver))
                            throw TypeError(".qihoo.protocol.messages.Proxy.receiver: array expected");
                        message.receiver = [];
                        for(let i = 0; i < object.receiver.length; ++i) {
                            if(typeof object.receiver[i] !== "object")
                                throw TypeError(".qihoo.protocol.messages.Proxy.receiver: object expected");
                            message.receiver[i] = $root.qihoo.protocol.messages.RouteInfo.fromObject(object.receiver[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Proxy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Proxy
                 * @static
                 * @param {qihoo.protocol.messages.Proxy} message Proxy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Proxy.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.arrays || options.defaults)
                        object.receiver = [];
                    if(options.defaults)
                        object.sender = "";
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if(message.receiver && message.receiver.length) {
                        object.receiver = [];
                        for(let j = 0; j < message.receiver.length; ++j)
                            object.receiver[j] = $root.qihoo.protocol.messages.RouteInfo.toObject(message.receiver[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Proxy to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Proxy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Proxy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Proxy;
            })();

            messages.Message = (function () {

                /**
                 * Properties of a Message.
                 * @memberof qihoo.protocol.messages
                 * @interface IMessage
                 * @property {number} msgid Message msgid
                 * @property {number|Long} sn Message sn
                 * @property {string|null} [sender] Message sender
                 * @property {string|null} [receiver] Message receiver
                 * @property {string|null} [receiver_type] Message receiver_type
                 * @property {qihoo.protocol.messages.IRequest|null} [req] Message req
                 * @property {qihoo.protocol.messages.IResponse|null} [resp] Message resp
                 * @property {qihoo.protocol.messages.INotify|null} [notify] Message notify
                 * @property {qihoo.protocol.messages.IAck|null} [ack] Message ack
                 * @property {qihoo.protocol.messages.IProxy|null} [proxy_mesg] Message proxy_mesg
                 * @property {number|Long|null} [client_data] Message client_data
                 * @property {string|null} [sender_type] Message sender_type
                 * @property {string|null} [sender_jid] Message sender_jid
                 */

                /**
                 * Constructs a new Message.
                 * @memberof qihoo.protocol.messages
                 * @classdesc Represents a Message.
                 * @implements IMessage
                 * @constructor
                 * @param {qihoo.protocol.messages.IMessage=} [properties] Properties to set
                 */
                function Message(properties) {
                    if(properties)
                        for(let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if(properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Message msgid.
                 * @member {number} msgid
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.msgid = 0;

                /**
                 * Message sn.
                 * @member {number|Long} sn
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.sn = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * Message sender.
                 * @member {string} sender
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.sender = "";

                /**
                 * Message receiver.
                 * @member {string} receiver
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.receiver = "";

                /**
                 * Message receiver_type.
                 * @member {string} receiver_type
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.receiver_type = "";

                /**
                 * Message req.
                 * @member {qihoo.protocol.messages.IRequest|null|undefined} req
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.req = null;

                /**
                 * Message resp.
                 * @member {qihoo.protocol.messages.IResponse|null|undefined} resp
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.resp = null;

                /**
                 * Message notify.
                 * @member {qihoo.protocol.messages.INotify|null|undefined} notify
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.notify = null;

                /**
                 * Message ack.
                 * @member {qihoo.protocol.messages.IAck|null|undefined} ack
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.ack = null;

                /**
                 * Message proxy_mesg.
                 * @member {qihoo.protocol.messages.IProxy|null|undefined} proxy_mesg
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.proxy_mesg = null;

                /**
                 * Message client_data.
                 * @member {number|Long} client_data
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.client_data = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;

                /**
                 * Message sender_type.
                 * @member {string} sender_type
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.sender_type = "";

                /**
                 * Message sender_jid.
                 * @member {string} sender_jid
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 */
                Message.prototype.sender_jid = "";

                /**
                 * Creates a new Message instance using the specified properties.
                 * @function create
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {qihoo.protocol.messages.IMessage=} [properties] Properties to set
                 * @returns {qihoo.protocol.messages.Message} Message instance
                 */
                Message.create = function create(properties) {
                    return new Message(properties);
                };

                /**
                 * Encodes the specified Message message. Does not implicitly {@link qihoo.protocol.messages.Message.verify|verify} messages.
                 * @function encode
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {qihoo.protocol.messages.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encode = function encode(message, writer) {
                    if(!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.msgid);
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.sn);
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.sender);
                    if(message.receiver != null && message.hasOwnProperty("receiver"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.receiver);
                    if(message.receiver_type != null && message.hasOwnProperty("receiver_type"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.receiver_type);
                    if(message.req != null && message.hasOwnProperty("req"))
                        $root.qihoo.protocol.messages.Request.encode(message.req, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if(message.resp != null && message.hasOwnProperty("resp"))
                        $root.qihoo.protocol.messages.Response.encode(message.resp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if(message.notify != null && message.hasOwnProperty("notify"))
                        $root.qihoo.protocol.messages.Notify.encode(message.notify, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if(message.ack != null && message.hasOwnProperty("ack"))
                        $root.qihoo.protocol.messages.Ack.encode(message.ack, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if(message.proxy_mesg != null && message.hasOwnProperty("proxy_mesg"))
                        $root.qihoo.protocol.messages.Proxy.encode(message.proxy_mesg, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if(message.client_data != null && message.hasOwnProperty("client_data"))
                        writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.client_data);
                    if(message.sender_type != null && message.hasOwnProperty("sender_type"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.sender_type);
                    if(message.sender_jid != null && message.hasOwnProperty("sender_jid"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.sender_jid);
                    return writer;
                };

                /**
                 * Encodes the specified Message message, length delimited. Does not implicitly {@link qihoo.protocol.messages.Message.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {qihoo.protocol.messages.IMessage} message Message message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Message.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Message message from the specified reader or buffer.
                 * @function decode
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {qihoo.protocol.messages.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decode = function decode(reader, length) {
                    if(!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length,
                        message = new $root.qihoo.protocol.messages.Message();
                    while(reader.pos < end) {
                        let tag = reader.uint32();
                        switch(tag >>> 3) {
                            case 1:
                                message.msgid = reader.uint32();
                                break;
                            case 2:
                                message.sn = reader.uint64();
                                break;
                            case 3:
                                message.sender = reader.string();
                                break;
                            case 4:
                                message.receiver = reader.string();
                                break;
                            case 5:
                                message.receiver_type = reader.string();
                                break;
                            case 6:
                                message.req = $root.qihoo.protocol.messages.Request.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.resp = $root.qihoo.protocol.messages.Response.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.notify = $root.qihoo.protocol.messages.Notify.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.ack = $root.qihoo.protocol.messages.Ack.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.proxy_mesg = $root.qihoo.protocol.messages.Proxy.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.client_data = reader.uint64();
                                break;
                            case 12:
                                message.sender_type = reader.string();
                                break;
                            case 13:
                                message.sender_jid = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if(!message.hasOwnProperty("msgid"))
                        throw $util.ProtocolError("missing required 'msgid'", { instance: message });
                    if(!message.hasOwnProperty("sn"))
                        throw $util.ProtocolError("missing required 'sn'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a Message message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {qihoo.protocol.messages.Message} Message
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Message.decodeDelimited = function decodeDelimited(reader) {
                    if(!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Message message.
                 * @function verify
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Message.verify = function verify(message) {
                    if(typeof message !== "object" || message === null)
                        return "object expected";
                    if(!$util.isInteger(message.msgid))
                        return "msgid: integer expected";
                    if(!$util.isInteger(message.sn) && !(message.sn && $util.isInteger(message.sn.low) && $util.isInteger(message.sn.high)))
                        return "sn: integer|Long expected";
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        if(!$util.isString(message.sender))
                            return "sender: string expected";
                    if(message.receiver != null && message.hasOwnProperty("receiver"))
                        if(!$util.isString(message.receiver))
                            return "receiver: string expected";
                    if(message.receiver_type != null && message.hasOwnProperty("receiver_type"))
                        if(!$util.isString(message.receiver_type))
                            return "receiver_type: string expected";
                    if(message.req != null && message.hasOwnProperty("req")) {
                        let error = $root.qihoo.protocol.messages.Request.verify(message.req);
                        if(error)
                            return "req." + error;
                    }
                    if(message.resp != null && message.hasOwnProperty("resp")) {
                        let error = $root.qihoo.protocol.messages.Response.verify(message.resp);
                        if(error)
                            return "resp." + error;
                    }
                    if(message.notify != null && message.hasOwnProperty("notify")) {
                        let error = $root.qihoo.protocol.messages.Notify.verify(message.notify);
                        if(error)
                            return "notify." + error;
                    }
                    if(message.ack != null && message.hasOwnProperty("ack")) {
                        let error = $root.qihoo.protocol.messages.Ack.verify(message.ack);
                        if(error)
                            return "ack." + error;
                    }
                    if(message.proxy_mesg != null && message.hasOwnProperty("proxy_mesg")) {
                        let error = $root.qihoo.protocol.messages.Proxy.verify(message.proxy_mesg);
                        if(error)
                            return "proxy_mesg." + error;
                    }
                    if(message.client_data != null && message.hasOwnProperty("client_data"))
                        if(!$util.isInteger(message.client_data) && !(message.client_data && $util.isInteger(message.client_data.low) && $util.isInteger(message.client_data.high)))
                            return "client_data: integer|Long expected";
                    if(message.sender_type != null && message.hasOwnProperty("sender_type"))
                        if(!$util.isString(message.sender_type))
                            return "sender_type: string expected";
                    if(message.sender_jid != null && message.hasOwnProperty("sender_jid"))
                        if(!$util.isString(message.sender_jid))
                            return "sender_jid: string expected";
                    return null;
                };

                /**
                 * Creates a Message message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {qihoo.protocol.messages.Message} Message
                 */
                Message.fromObject = function fromObject(object) {
                    if(object instanceof $root.qihoo.protocol.messages.Message)
                        return object;
                    let message = new $root.qihoo.protocol.messages.Message();
                    if(object.msgid != null)
                        message.msgid = object.msgid >>> 0;
                    if(object.sn != null)
                        if($util.Long)
                            (message.sn = $util.Long.fromValue(object.sn)).unsigned = true;
                        else if(typeof object.sn === "string")
                            message.sn = parseInt(object.sn, 10);
                        else if(typeof object.sn === "number")
                            message.sn = object.sn;
                        else if(typeof object.sn === "object")
                            message.sn = new $util.LongBits(object.sn.low >>> 0, object.sn.high >>> 0).toNumber(true);
                    if(object.sender != null)
                        message.sender = String(object.sender);
                    if(object.receiver != null)
                        message.receiver = String(object.receiver);
                    if(object.receiver_type != null)
                        message.receiver_type = String(object.receiver_type);
                    if(object.req != null) {
                        if(typeof object.req !== "object")
                            throw TypeError(".qihoo.protocol.messages.Message.req: object expected");
                        message.req = $root.qihoo.protocol.messages.Request.fromObject(object.req);
                    }
                    if(object.resp != null) {
                        if(typeof object.resp !== "object")
                            throw TypeError(".qihoo.protocol.messages.Message.resp: object expected");
                        message.resp = $root.qihoo.protocol.messages.Response.fromObject(object.resp);
                    }
                    if(object.notify != null) {
                        if(typeof object.notify !== "object")
                            throw TypeError(".qihoo.protocol.messages.Message.notify: object expected");
                        message.notify = $root.qihoo.protocol.messages.Notify.fromObject(object.notify);
                    }
                    if(object.ack != null) {
                        if(typeof object.ack !== "object")
                            throw TypeError(".qihoo.protocol.messages.Message.ack: object expected");
                        message.ack = $root.qihoo.protocol.messages.Ack.fromObject(object.ack);
                    }
                    if(object.proxy_mesg != null) {
                        if(typeof object.proxy_mesg !== "object")
                            throw TypeError(".qihoo.protocol.messages.Message.proxy_mesg: object expected");
                        message.proxy_mesg = $root.qihoo.protocol.messages.Proxy.fromObject(object.proxy_mesg);
                    }
                    if(object.client_data != null)
                        if($util.Long)
                            (message.client_data = $util.Long.fromValue(object.client_data)).unsigned = true;
                        else if(typeof object.client_data === "string")
                            message.client_data = parseInt(object.client_data, 10);
                        else if(typeof object.client_data === "number")
                            message.client_data = object.client_data;
                        else if(typeof object.client_data === "object")
                            message.client_data = new $util.LongBits(object.client_data.low >>> 0, object.client_data.high >>> 0).toNumber(true);
                    if(object.sender_type != null)
                        message.sender_type = String(object.sender_type);
                    if(object.sender_jid != null)
                        message.sender_jid = String(object.sender_jid);
                    return message;
                };

                /**
                 * Creates a plain object from a Message message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof qihoo.protocol.messages.Message
                 * @static
                 * @param {qihoo.protocol.messages.Message} message Message
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Message.toObject = function toObject(message, options) {
                    if(!options)
                        options = {};
                    let object = {};
                    if(options.defaults) {
                        object.msgid = 0;
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.sn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sn = options.longs === String ? "0" : 0;
                        object.sender = "";
                        object.receiver = "";
                        object.receiver_type = "";
                        object.req = null;
                        object.resp = null;
                        object.notify = null;
                        object.ack = null;
                        object.proxy_mesg = null;
                        if($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.client_data = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.client_data = options.longs === String ? "0" : 0;
                        object.sender_type = "";
                        object.sender_jid = "";
                    }
                    if(message.msgid != null && message.hasOwnProperty("msgid"))
                        object.msgid = message.msgid;
                    if(message.sn != null && message.hasOwnProperty("sn"))
                        if(typeof message.sn === "number")
                            object.sn = options.longs === String ? String(message.sn) : message.sn;
                        else
                            object.sn = options.longs === String ? $util.Long.prototype.toString.call(message.sn) : options.longs === Number ? new $util.LongBits(message.sn.low >>> 0, message.sn.high >>> 0).toNumber(true) : message.sn;
                    if(message.sender != null && message.hasOwnProperty("sender"))
                        object.sender = message.sender;
                    if(message.receiver != null && message.hasOwnProperty("receiver"))
                        object.receiver = message.receiver;
                    if(message.receiver_type != null && message.hasOwnProperty("receiver_type"))
                        object.receiver_type = message.receiver_type;
                    if(message.req != null && message.hasOwnProperty("req"))
                        object.req = $root.qihoo.protocol.messages.Request.toObject(message.req, options);
                    if(message.resp != null && message.hasOwnProperty("resp"))
                        object.resp = $root.qihoo.protocol.messages.Response.toObject(message.resp, options);
                    if(message.notify != null && message.hasOwnProperty("notify"))
                        object.notify = $root.qihoo.protocol.messages.Notify.toObject(message.notify, options);
                    if(message.ack != null && message.hasOwnProperty("ack"))
                        object.ack = $root.qihoo.protocol.messages.Ack.toObject(message.ack, options);
                    if(message.proxy_mesg != null && message.hasOwnProperty("proxy_mesg"))
                        object.proxy_mesg = $root.qihoo.protocol.messages.Proxy.toObject(message.proxy_mesg, options);
                    if(message.client_data != null && message.hasOwnProperty("client_data"))
                        if(typeof message.client_data === "number")
                            object.client_data = options.longs === String ? String(message.client_data) : message.client_data;
                        else
                            object.client_data = options.longs === String ? $util.Long.prototype.toString.call(message.client_data) : options.longs === Number ? new $util.LongBits(message.client_data.low >>> 0, message.client_data.high >>> 0).toNumber(true) : message.client_data;
                    if(message.sender_type != null && message.hasOwnProperty("sender_type"))
                        object.sender_type = message.sender_type;
                    if(message.sender_jid != null && message.hasOwnProperty("sender_jid"))
                        object.sender_jid = message.sender_jid;
                    return object;
                };

                /**
                 * Converts this Message to JSON.
                 * @function toJSON
                 * @memberof qihoo.protocol.messages.Message
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Message.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Message;
            })();

            return messages;
        })();

        return protocol;
    })();

    return qihoo;
})();

export { $root as default };
